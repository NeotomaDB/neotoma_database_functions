{
    "name": "neotoma",
    "desc": "The remote Neotoma database.",
    "tables": [
        {
            "name": "ndb.agetypes",
            "type": "BASE TABLE",
            "comment": "Lookup table of Age Types or units. This table is referenced by the Chronologies and Geochronology tables.",
            "columns": [
                {
                    "name": "agetypeid",
                    "type": "integer",
                    "nullable": false,
                    "default": "nextval('ndb.seq_agetypes_agetypeid'::regclass)",
                    "comment": "PK: An arbitrary Age Type identification number"
                },
                {
                    "name": "agetype",
                    "type": "varchar(64)",
                    "nullable": false,
                    "comment": "Age type or units:\n* Calendar years AD/BC\n* Calendar years BP\n* Calibrated radiocarbon years BP\n* Radiocarbon years BP\n* Varve years BP"
                },
                {
                    "name": "precedence",
                    "type": "integer",
                    "nullable": true
                },
                {
                    "name": "shortagetype",
                    "type": "varchar(32)",
                    "nullable": true
                },
                {
                    "name": "recdatecreated",
                    "type": "timestamp(0) without time zone",
                    "nullable": false,
                    "default": "timezone('UTC'::text, now())"
                },
                {
                    "name": "recdatemodified",
                    "type": "timestamp(0) without time zone",
                    "nullable": false
                }
            ],
            "indexes": [
                {
                    "name": "agetypes_pkey",
                    "def": "CREATE UNIQUE INDEX agetypes_pkey ON ndb.agetypes USING btree (agetypeid)",
                    "table": "ndb.agetypes",
                    "columns": [
                        "agetypeid"
                    ]
                }
            ],
            "constraints": [
                {
                    "name": "agetypes_pkey",
                    "type": "PRIMARY KEY",
                    "def": "PRIMARY KEY (agetypeid)",
                    "table": "ndb.agetypes",
                    "referenced_table": "",
                    "columns": [
                        "agetypeid"
                    ]
                }
            ],
            "triggers": [
                {
                    "name": "tr_sites_modifydate",
                    "def": "CREATE TRIGGER tr_sites_modifydate BEFORE INSERT OR UPDATE ON ndb.agetypes FOR EACH ROW EXECUTE FUNCTION ndb.update_recdatemodified()"
                }
            ]
        },
        {
            "name": "ndb.geopoliticalunits",
            "type": "BASE TABLE",
            "comment": "Lookup table of GeoPoliticalUnits. Table is referenced by the SiteGeoPolitical table. These are countries and various subdivisions. Countries and subdivisions were acquired from the U.S. Central Intelligence Agency World Factbook8 and the ISO 3166-1 and ISO 3166-2 databases9.\nEach GeoPolitical Unit has a rank. GeoPolitical Units with Rank 1 are generally countries. There are a few exceptions, including Antarctica and island territories, such as Greenland, which although a Danish territory, is geographically separate and distinct. Rank 2 units are generally secondary political divisions with various designations: e.g. states in the United States, provinces in Canada, and regions in France. For some countries, the secondary divisions are not political but rather distinct geographic entities, such as islands. The secondary divisions of some island nations include either groups of islands or sections of more highly populated islands; however, the actual island on which a site is located is more important information. Some countries also have Rank 3 units, e.g. counties in the United States and metropolitan departments in France. In addition to purely political units, various other administrative regions and geographic entities can be contained in this table. Examples of administrative regions are National Parks and Forests. It might be quite useful, for example, to have a record of all the sites in Yellowstone National Park. These additional units are Rank 4, and they can be added to the database as warranted.",
            "columns": [
                {
                    "name": "geopoliticalid",
                    "type": "integer",
                    "nullable": false,
                    "default": "nextval('ndb.seq_geopoliticalunits_geopoliticalid'::regclass)",
                    "comment": "An arbitrary GeoPolitical identification number."
                },
                {
                    "name": "geopoliticalname",
                    "type": "varchar(255)",
                    "nullable": false,
                    "comment": "Name of the GeoPolitical Unit, e.g. Canada, Saskatchewan."
                },
                {
                    "name": "geopoliticalunit",
                    "type": "varchar(255)",
                    "nullable": true,
                    "comment": "The name of the unit, e.g. country, state, county, island, governorate, oblast."
                },
                {
                    "name": "rank",
                    "type": "integer",
                    "nullable": false,
                    "comment": "The rank of the unit."
                },
                {
                    "name": "highergeopoliticalid",
                    "type": "integer",
                    "nullable": false,
                    "comment": "The GeoPoliticalUnit with higher rank, e.g. the country in which a state lies."
                },
                {
                    "name": "recdatecreated",
                    "type": "timestamp(0) without time zone",
                    "nullable": false,
                    "default": "timezone('UTC'::text, now())"
                },
                {
                    "name": "recdatemodified",
                    "type": "timestamp(0) without time zone",
                    "nullable": false
                }
            ],
            "indexes": [
                {
                    "name": "geopoliticalunits_pkey",
                    "def": "CREATE UNIQUE INDEX geopoliticalunits_pkey ON ndb.geopoliticalunits USING btree (geopoliticalid)",
                    "table": "ndb.geopoliticalunits",
                    "columns": [
                        "geopoliticalid"
                    ]
                },
                {
                    "name": "ix_geopoliticalname_geopoliticalunits",
                    "def": "CREATE INDEX ix_geopoliticalname_geopoliticalunits ON ndb.geopoliticalunits USING btree (geopoliticalname) WITH (fillfactor='10')",
                    "table": "ndb.geopoliticalunits",
                    "columns": [
                        "geopoliticalname"
                    ]
                },
                {
                    "name": "ix_rank_geopoliticalunits",
                    "def": "CREATE INDEX ix_rank_geopoliticalunits ON ndb.geopoliticalunits USING btree (rank) WITH (fillfactor='10')",
                    "table": "ndb.geopoliticalunits",
                    "columns": [
                        "rank"
                    ]
                }
            ],
            "constraints": [
                {
                    "name": "geopoliticalunits_pkey",
                    "type": "PRIMARY KEY",
                    "def": "PRIMARY KEY (geopoliticalid)",
                    "table": "ndb.geopoliticalunits",
                    "referenced_table": "",
                    "columns": [
                        "geopoliticalid"
                    ]
                }
            ],
            "triggers": [
                {
                    "name": "tr_sites_modifydate",
                    "def": "CREATE TRIGGER tr_sites_modifydate BEFORE INSERT OR UPDATE ON ndb.geopoliticalunits FOR EACH ROW EXECUTE FUNCTION ndb.update_recdatemodified()"
                }
            ]
        },
        {
            "name": "ndb.lakeparametertypes",
            "type": "BASE TABLE",
            "columns": [
                {
                    "name": "lakeparameterid",
                    "type": "integer",
                    "nullable": false,
                    "default": "nextval('ndb.seq_lakeparametertypes_lakeparameterid'::regclass)",
                    "comment": "PK: LakeParameterID"
                },
                {
                    "name": "lakeparametercode",
                    "type": "varchar(20)",
                    "nullable": false,
                    "comment": "Code espcially for data entry apps"
                },
                {
                    "name": "lakeparametershortname",
                    "type": "varchar(40)",
                    "nullable": false,
                    "comment": "Short name useful for data entry apps"
                },
                {
                    "name": "lakeparameter",
                    "type": "varchar(80)",
                    "nullable": false,
                    "comment": "Full name"
                },
                {
                    "name": "recdatecreated",
                    "type": "timestamp(0) without time zone",
                    "nullable": false,
                    "default": "timezone('UTC'::text, now())"
                },
                {
                    "name": "recdatemodified",
                    "type": "timestamp(0) without time zone",
                    "nullable": false
                }
            ],
            "indexes": [
                {
                    "name": "lakeparametertypes_pkey",
                    "def": "CREATE UNIQUE INDEX lakeparametertypes_pkey ON ndb.lakeparametertypes USING btree (lakeparameterid)",
                    "table": "ndb.lakeparametertypes",
                    "columns": [
                        "lakeparameterid"
                    ]
                }
            ],
            "constraints": [
                {
                    "name": "lakeparametertypes_pkey",
                    "type": "PRIMARY KEY",
                    "def": "PRIMARY KEY (lakeparameterid)",
                    "table": "ndb.lakeparametertypes",
                    "referenced_table": "",
                    "columns": [
                        "lakeparameterid"
                    ]
                }
            ],
            "triggers": [
                {
                    "name": "tr_sites_modifydate",
                    "def": "CREATE TRIGGER tr_sites_modifydate BEFORE INSERT OR UPDATE ON ndb.lakeparametertypes FOR EACH ROW EXECUTE FUNCTION ndb.update_recdatemodified()"
                }
            ]
        },
        {
            "name": "ndb.publications",
            "type": "BASE TABLE",
            "comment": "This table stores publication or bibliographic data. The table is designed with fields for bibliographic data so that bibliographies can be formatted in different styles and potentially exported to bibliographic software such EndNote®. In the constituent databases that were originally merged into Neotoma, bibliographic entries were not parsed into separate fields, but rather were stored as free-form text. Because complete parsing of these thousands of legacy bibliographic entries into individual fields would have been prohibitively time consuming, the existing bibliographic data were ingested “as is” with a PubTypeID = Other. However, for legacy publications, the year of publication was added to the Year field, and authors were parsed into the PublicationAuthors table and added to the Contacts table. In addition, some global changes were made. For example, «Pp.» was changed to «Pages», «Ed.» to «Editor», and «Eds.» to «Editors». Also for FAUNMAP entries, abbreviated journal names were changed to fully spelled out names.\nThe merged databases used different bibliographic styles, and data entry personnel working on the same database sometimes followed different conventions. Consequently, the current bibliographic entries are not stylistically uniform. Eventually, the legacy bibliographic data will be parsed into separate fields.\nThe Publications table has fields to accommodate a number of different types of publications. Some fields contain different kinds of data for different kinds of publications. For example, the BookTitle field stores the titles of books, but stores the journal name for journal articles. The Publisher field stores the name of the publisher for books, but the name of the university for theses and dissertations.\nAuthors are stored in the PublicationAuthors table. Editors are also stored in the PublicationAuthors table if the entire publication is cited. The PublicationAuthors table has a ContactID field, which links to the Contacts table, where full names and contact information is stored for authors and editors. The PubTypeID «Authored Book» or «Edited Book» indicates whether the Publication Authors records are authors or editors. If a book chapter or section is the primary bibliographic entry, then the book editors are stored in the PublicationEditors table, which does not have a ContactID field.",
            "columns": [
                {
                    "name": "publicationid",
                    "type": "integer",
                    "nullable": false,
                    "default": "nextval('ndb.seq_publications_publicationid'::regclass)",
                    "comment": "An arbitrary Publication identification number."
                },
                {
                    "name": "pubtypeid",
                    "type": "integer",
                    "nullable": true,
                    "comment": "Publication type. Field links to the PublicationTypes lookup table."
                },
                {
                    "name": "year",
                    "type": "varchar(64)",
                    "nullable": true,
                    "comment": "Year of publication."
                },
                {
                    "name": "citation",
                    "type": "text",
                    "nullable": true,
                    "comment": "The complete citation in a standard style. For Legacy citations inherited from other databases, this field holds the citation as ingested from the other databases"
                },
                {
                    "name": "articletitle",
                    "type": "text",
                    "nullable": true,
                    "comment": "The title of a journal or book chapter article."
                },
                {
                    "name": "journal",
                    "type": "text",
                    "nullable": true
                },
                {
                    "name": "volume",
                    "type": "varchar(16)",
                    "nullable": true,
                    "comment": "The volume number of a journal or the volume number of a book in a set. A set of books is comprised of a fixed number of volumes and normally have ISBN numbers, not ISSN numbers. Book sets are often published simultaneously, but not necessarily. For instance, many floras, such as The Flora of North America north of Mexico and Flora Europaea, consist of a set number of volumes planned in advance but published over a period of years."
                },
                {
                    "name": "issue",
                    "type": "varchar(8)",
                    "nullable": true,
                    "comment": "Journal issue number, normally included only if issues are independently paginated."
                },
                {
                    "name": "pages",
                    "type": "varchar(24)",
                    "nullable": true,
                    "comment": "Page numbers for journal or book chapter articles, or the number of pages in theses, dissertations, and reports."
                },
                {
                    "name": "citationnumber",
                    "type": "varchar(24)",
                    "nullable": true,
                    "comment": "A citation or article number used in lieu of page numbers for digital or online publications, typically used in conjunction with the DOI. For example, journals published by the American Geophysical Union since 1999 use citation numbers rather than page numbers."
                },
                {
                    "name": "doi",
                    "type": "varchar(128)",
                    "nullable": true,
                    "comment": "Digital Object Identifier. A unique identifier assigned to digital publications. The DOI consists of a prefix and suffix separated by a slash. The portion before the slash stands for the publisher and is assigned by the International DOI Foundation. For example, 10.1029 is the prefix for the American Geophysical Union. The suffix is assigned by the publisher according to their protocols. For example, the DOI 10.1029/2002PA000768 is for an article submitted to Paleoceanography in 2002 and is article number 768 submitted since the system was installed. An example of CitationNumber and DOI:\nBarron, J. A., L. Heusser, T. Herbert, and M. Lyle. 2003. High-resolution climatic evolution of coastal northern California during the past 16,000 years, Paleoceanography 18(1):1020. DOI:10.1029/2002PA000768.\n"
                },
                {
                    "name": "booktitle",
                    "type": "text",
                    "nullable": true,
                    "comment": "The title of a book or journal"
                },
                {
                    "name": "numvolumes",
                    "type": "varchar(8)",
                    "nullable": true,
                    "comment": "Number of volumes in a set of books. Used when the entire set is referenced. An example of NumVolumes and Edition:\nWilson, D. E., and D. M. Reeder. 2005. Mammal species of the world: a taxonomic and geographic reference. Third edition. 2 volumes. The Johns Hopkins University Press, Baltimore, Maryland, USA.\n"
                },
                {
                    "name": "edition",
                    "type": "varchar(24)",
                    "nullable": true,
                    "comment": "Edition of a publication."
                },
                {
                    "name": "volumetitle",
                    "type": "text",
                    "nullable": true,
                    "comment": "Title of a book volume in a set. Used if the individual volume is referenced. Example of Volume and VolumeTitle:\nFlora of North America Editorial Committee. 2002. Flora of North America north of Mexico. Volume 26. Magnoliophyta: Liliidae: Liliales and Orchidales. Oxford University Press, New York, New York, USA.\n"
                },
                {
                    "name": "seriestitle",
                    "type": "text",
                    "nullable": true,
                    "comment": "Title of a book series. Book series consist of a series of books, typically published at irregular intervals on sometimes related but different topics. The number of volumes in a series is typically open ended. Book series are often assigned ISSN numbers as well as ISBN numbers. However, in contrast to most serials, book series have individual titles and authors or editors. Citation practices for book series vary; sometimes they are cited as books, other times as journals. The default citation for Neotoma includes all information. An example of SeriesTitle and SeriesVolume:\nCurtis, J. H., and D. A. Hodell. 1993. An isotopic and trace element study of ostracods from Lake Miragoane, Haiti: A 10,500 year record of paleosalinity and paleotemperature changes in the Caribbean. Pages 135-152 in P. K. Swart, K. C. Lohmann, J. McKensie, and S. Savin, editors. Climate change in continental isotopic records. Geophysical Monograph 78. American Geophysical Union, Washington, D.C., USA.\n"
                },
                {
                    "name": "seriesvolume",
                    "type": "varchar(24)",
                    "nullable": true,
                    "comment": "Volume number in a series."
                },
                {
                    "name": "publisher",
                    "type": "varchar(255)",
                    "nullable": true,
                    "comment": "Publisher, including commercial publishing houses, university presses, government agencies, and non-governmental organizations, generally the owner of the copyright."
                },
                {
                    "name": "url",
                    "type": "text",
                    "nullable": true
                },
                {
                    "name": "city",
                    "type": "varchar(64)",
                    "nullable": true,
                    "comment": "City in which the publication was published. The first city if a list is given."
                },
                {
                    "name": "state",
                    "type": "varchar(64)",
                    "nullable": true,
                    "comment": "State or province in which the publication was published. Used for the United States and Canada, not used for many countries."
                },
                {
                    "name": "country",
                    "type": "varchar(64)",
                    "nullable": true,
                    "comment": "Country in which the publication was published, generally the complete country name, but «USA» for the United States."
                },
                {
                    "name": "originallanguage",
                    "type": "varchar(64)",
                    "nullable": true,
                    "comment": "The original language if the publication or bibliographic citation is translated from another language or transliterated from a non-Latin character set. Field not needed for non-translated publications in languages using the Latin character set. In the following example, the ArticleTitle is translated from Russian to English and the BookTitle (journal name) is transliterated from Russian:\nTarasov, P.E. 1991. Late Holocene features of the Kokchetav Highland. Vestnik Moskovskogo Universiteta. Series 5. Geography 6:54-60 [in Russian].\n"
                },
                {
                    "name": "notes",
                    "type": "text",
                    "nullable": true,
                    "comment": "Free form notes or comments about the publication, which may be added parenthetically to the citation."
                },
                {
                    "name": "recdatecreated",
                    "type": "timestamp(0) without time zone",
                    "nullable": false,
                    "default": "timezone('UTC'::text, now())"
                },
                {
                    "name": "recdatemodified",
                    "type": "timestamp(0) without time zone",
                    "nullable": false
                },
                {
                    "name": "crossref",
                    "type": "jsonb",
                    "nullable": true
                },
                {
                    "name": "bibtex",
                    "type": "varchar",
                    "nullable": true
                }
            ],
            "indexes": [
                {
                    "name": "publications_pkey",
                    "def": "CREATE UNIQUE INDEX publications_pkey ON ndb.publications USING btree (publicationid)",
                    "table": "ndb.publications",
                    "columns": [
                        "publicationid"
                    ]
                }
            ],
            "constraints": [
                {
                    "name": "publications_pkey",
                    "type": "PRIMARY KEY",
                    "def": "PRIMARY KEY (publicationid)",
                    "table": "ndb.publications",
                    "referenced_table": "",
                    "columns": [
                        "publicationid"
                    ]
                },
                {
                    "name": "pub_pty",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (pubtypeid) REFERENCES ndb.publicationtypes(pubtypeid)",
                    "table": "ndb.publications",
                    "referenced_table": "publicationtypes",
                    "columns": [
                        "pubtypeid"
                    ],
                    "referenced_columns": [
                        "pubtypeid"
                    ]
                }
            ],
            "triggers": [
                {
                    "name": "tr_sites_modifydate",
                    "def": "CREATE TRIGGER tr_sites_modifydate BEFORE INSERT OR UPDATE ON ndb.publications FOR EACH ROW EXECUTE FUNCTION ndb.update_recdatemodified()"
                }
            ]
        },
        {
            "name": "ndb.publicationtypes",
            "type": "BASE TABLE",
            "comment": "Lookup table of Publication Types. This table is referenced by the Publications table.",
            "columns": [
                {
                    "name": "pubtypeid",
                    "type": "integer",
                    "nullable": false,
                    "default": "nextval('ndb.seq_publicationtypes_pubtypeid'::regclass)",
                    "comment": "An arbitrary Publication Type identification number."
                },
                {
                    "name": "pubtype",
                    "type": "varchar(24)",
                    "nullable": false
                },
                {
                    "name": "recdatecreated",
                    "type": "timestamp(0) without time zone",
                    "nullable": false,
                    "default": "timezone('UTC'::text, now())"
                },
                {
                    "name": "recdatemodified",
                    "type": "timestamp(0) without time zone",
                    "nullable": false
                }
            ],
            "indexes": [
                {
                    "name": "publicationtypes_pkey",
                    "def": "CREATE UNIQUE INDEX publicationtypes_pkey ON ndb.publicationtypes USING btree (pubtypeid)",
                    "table": "ndb.publicationtypes",
                    "columns": [
                        "pubtypeid"
                    ]
                }
            ],
            "constraints": [
                {
                    "name": "publicationtypes_pkey",
                    "type": "PRIMARY KEY",
                    "def": "PRIMARY KEY (pubtypeid)",
                    "table": "ndb.publicationtypes",
                    "referenced_table": "",
                    "columns": [
                        "pubtypeid"
                    ]
                }
            ],
            "triggers": [
                {
                    "name": "tr_sites_modifydate",
                    "def": "CREATE TRIGGER tr_sites_modifydate BEFORE INSERT OR UPDATE ON ndb.publicationtypes FOR EACH ROW EXECUTE FUNCTION ndb.update_recdatemodified()"
                }
            ]
        },
        {
            "name": "ndb.synonymtypes",
            "type": "BASE TABLE",
            "comment": "Lookup table of Synonym Types. Table is referenced by the Synonyms table.",
            "columns": [
                {
                    "name": "synonymtypeid",
                    "type": "integer",
                    "nullable": false,
                    "default": "nextval('ndb.seq_synonymtypes_synonymtypeid'::regclass)",
                    "comment": "An arbitrary Synonym Type identification number."
                },
                {
                    "name": "synonymtype",
                    "type": "varchar(255)",
                    "nullable": true,
                    "comment": "SynonymType: Synonym type. Below are some examples:\n*nomenclatural, homotypic, or objective synonym – a synonym that unambiguously refers to the same taxon, particularly one with the same description or type specimen. These synonyms are particularly common above the species level. For example, Gramineae = Poaceae, Clethrionomys gapperi = Myodes gapperi. The term «objective» is used in zoology, whereas «nomenclatural» or «homotypic» is used in botany.\n*taxonomic, heterotypic, or subjective synonym – a synonym typically based on a different type specimen, but which is now regarded as the same taxon as the senior synonym. For example, Iva ciliata = Iva annua. The term «subjective» is used in zoology, whereas «taxonomic» or «heterotypic» is used in botany.\n*genus merged into another genus – heterotypic or subjective synonym; a genus has been merged into another genus and has not been retained at a subgeneric rank. This synonymy may apply to either the generic or specific level, for example: Petalostemon = Dalea, Petalostemon purpureus = Dalea purpurea.\n*family merged into another family – heterotypic or subjective synonym; a family has been merged into another family and has not been retained at a subfamilial rank. For example, the Taxodiaceae has been merged with the Cupressaceae. This synonymy creates issues for data entry, because palynologically the Taxodiaceae sensu stricto is sometimes distinguishable from the Cupressaceae sensu stricto. If a pollen type was identified as «Cupressaceae/Taxodiaceae», then synonymizing to «Cupressaceae» results in no loss of information. However, synonymizing «Taxodiaceae» to «Cupressaceae» potentially does. In this case, consultation with the original literature or knowledge of the local biogeography may point to a logical name change that will retain the precision of the original identification. For example, in the southeastern United States, «Taxodiaceae» can be changed to «Taxodium» or «Taxodium-type» in most situations. If «Cupressaceae» was also identified, then it should be changed to «Cupressaceae undiff.» or possibly «Juniperus-type» if other Cupressaceae such as Chamaecyperus are unlikely.\n*rank change: species reduced to subspecific rank – heterotypic or subjective synonym; a species has been reduced to a subspecies or variety of another species. These synonyms may be treated in two different ways, depending on the situation or protocols of the contributing data cooperative: (1) The taxon is reduced to the subspecific rank (e.g. Alnus fruticosa = Alnus viridis subsp. fruticosa, Canis familiaris = Canis lupus familiaris), either because the fossils can be assigned to the subspecies based on morphology, as is likely the case with the domestic dog, Canis lupus familiaris, or because the subspecies can be assigned confidently based on biogeography. (2) The taxon is changed to the new taxon and the subspecific rank is dropped because the fossil is not distinguishable at the subspecific level. For example, Alnus rugosa = Alnus incana subsp. rugosa, but may simply be changed to Alnus incana because the pollen of A. incana subsp. rugosa and A. incana subsp. incana are indistinguishable morphologically.\n*rank change: genus reduced to subgenus – heterotypic or subjective synonym; a genus has been reduced to subgeneric rank in another family. At the generic level, this synonymy is clear from the naming conventions, e.g. Mictomys = Synaptomys (Mictomys); however, at the species level it is not, e.g. Mictomys borealis = Synaptomys borealis.\n*rank change: family reduced to subfamily – heterotypic or subjective synonym; a family has been reduced to subfamily rank in another family. By botanical convention the family name is retained, e.g. Pyrolaceae = Ericaceae subf. Monotropoideae; whereas by zoological convention it is not, e.g. Desmodontidae = Desmodontinae.\n*rank change: subspecific rank elevated to species – heterotypic or subjective synonym; a subspecies or variety has been raised to the species rank, e.g. Ephedra fragilis subsp. campylopoda = Ephedra foeminea.\n*rank change: subgeneric rank elevated to genus – heterotypic or subjective synonym; a subgenus or other subgeneric rank has been raised to the generic rank. At the subgeneric level, this synonymy is clear from the naming conventions, e.g. Potamogeton subg. Coleogeton = Stuckenia; however, at the species level it is not, e.g. Potamogeton pectinatus = Stuckenia pectinata.\n*rank change: subfamily elevated to family – heterotypic or subjective synonym; a subfamily has been raised to the family rank, e.g. Liliaceae subf. Amaryllidoideae = Amaryllidaceae, Pampatheriinae = Pampatheriidae.\n*rank elevated because of taxonomic uncertainty – because the precise taxonomic identification is uncertain, the rank has been raised to a level that includes the universe of possible taxa. A common cause of such uncertainty is taxonomic splitting subsequent to the original identification, in which case the originally identified taxon is now a much smaller group. For example, the genus Psoralea has been divided into several genera; the genus Psoralea still exists, but now includes a much smaller number of species. Consequently, in the database Psoralea has been synonymized with Fabaceae tribe Psoraleeae, which includes the former Psoralea sensu lato. A zoological example is Mustela sp. The genus Mustela formerly included the minks, which have now been separated into the genus Neovison. Consequently, Mustela sp. = Mustela/Neovison sp.\n*globally monospecific genus – although identified at the genus level, specimens assigned to this genus can be further assigned to the species level because the genus is monospecific.\n*globally monogeneric family – although identified at the family level, specimens assigned to this family can be further assigned to the genus level because the family is monogeneric.\n"
                },
                {
                    "name": "recdatecreated",
                    "type": "timestamp(0) without time zone",
                    "nullable": false,
                    "default": "timezone('UTC'::text, now())"
                },
                {
                    "name": "recdatemodified",
                    "type": "timestamp(0) without time zone",
                    "nullable": false
                }
            ],
            "indexes": [
                {
                    "name": "synonymtypes_pkey",
                    "def": "CREATE UNIQUE INDEX synonymtypes_pkey ON ndb.synonymtypes USING btree (synonymtypeid)",
                    "table": "ndb.synonymtypes",
                    "columns": [
                        "synonymtypeid"
                    ]
                }
            ],
            "constraints": [
                {
                    "name": "synonymtypes_pkey",
                    "type": "PRIMARY KEY",
                    "def": "PRIMARY KEY (synonymtypeid)",
                    "table": "ndb.synonymtypes",
                    "referenced_table": "",
                    "columns": [
                        "synonymtypeid"
                    ]
                }
            ],
            "triggers": [
                {
                    "name": "tr_sites_modifydate",
                    "def": "CREATE TRIGGER tr_sites_modifydate BEFORE INSERT OR UPDATE ON ndb.synonymtypes FOR EACH ROW EXECUTE FUNCTION ndb.update_recdatemodified()"
                }
            ]
        },
        {
            "name": "ndb.unitsdatasettypes",
            "type": "BASE TABLE",
            "columns": [
                {
                    "name": "datasettypeid",
                    "type": "integer",
                    "nullable": false
                },
                {
                    "name": "variableunitsid",
                    "type": "integer",
                    "nullable": false
                },
                {
                    "name": "recdatecreated",
                    "type": "timestamp(0) without time zone",
                    "nullable": false,
                    "default": "timezone('UTC'::text, now())"
                },
                {
                    "name": "recdatemodified",
                    "type": "timestamp(0) without time zone",
                    "nullable": false
                }
            ],
            "indexes": [
                {
                    "name": "unitsdatasettypes_pkey",
                    "def": "CREATE UNIQUE INDEX unitsdatasettypes_pkey ON ndb.unitsdatasettypes USING btree (datasettypeid, variableunitsid)",
                    "table": "ndb.unitsdatasettypes",
                    "columns": [
                        "datasettypeid",
                        "variableunitsid"
                    ]
                }
            ],
            "constraints": [
                {
                    "name": "fk_unitsdatasettypes_datasettypes",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (datasettypeid) REFERENCES ndb.datasettypes(datasettypeid) ON UPDATE CASCADE ON DELETE CASCADE",
                    "table": "ndb.unitsdatasettypes",
                    "referenced_table": "datasettypes",
                    "columns": [
                        "datasettypeid"
                    ],
                    "referenced_columns": [
                        "datasettypeid"
                    ]
                },
                {
                    "name": "unitsdatasettypes_pkey",
                    "type": "PRIMARY KEY",
                    "def": "PRIMARY KEY (datasettypeid, variableunitsid)",
                    "table": "ndb.unitsdatasettypes",
                    "referenced_table": "",
                    "columns": [
                        "datasettypeid",
                        "variableunitsid"
                    ]
                },
                {
                    "name": "fk_unitsdatasettypes_variableunits",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (variableunitsid) REFERENCES ndb.variableunits(variableunitsid) ON UPDATE CASCADE ON DELETE CASCADE",
                    "table": "ndb.unitsdatasettypes",
                    "referenced_table": "variableunits",
                    "columns": [
                        "variableunitsid"
                    ],
                    "referenced_columns": [
                        "variableunitsid"
                    ]
                }
            ],
            "triggers": [
                {
                    "name": "tr_sites_modifydate",
                    "def": "CREATE TRIGGER tr_sites_modifydate BEFORE INSERT OR UPDATE ON ndb.unitsdatasettypes FOR EACH ROW EXECUTE FUNCTION ndb.update_recdatemodified()"
                }
            ]
        },
        {
            "name": "ndb.variables",
            "type": "BASE TABLE",
            "comment": "This table lists Variables, which always consist of a Taxon and Units of measurement. Variables can also have Elements, Contexts, and Modifications. Thus, the same taxon with different measurement units (e.g. present/absent, NISP, MNI) are different Variables.",
            "columns": [
                {
                    "name": "variableid",
                    "type": "integer",
                    "nullable": false,
                    "default": "nextval('ndb.seq_variables_variableid'::regclass)",
                    "comment": "An arbitrary Variable identification number."
                },
                {
                    "name": "taxonid",
                    "type": "integer",
                    "nullable": false,
                    "comment": "Taxon identification number. Field links to the Taxa table."
                },
                {
                    "name": "variableelementid",
                    "type": "integer",
                    "nullable": true,
                    "comment": "Variable Element identification number. Field links to the VariableElements lookup table."
                },
                {
                    "name": "variableunitsid",
                    "type": "integer",
                    "nullable": true,
                    "comment": "Variable Units identification number. Field links to the VariableUnits lookup table."
                },
                {
                    "name": "variablecontextid",
                    "type": "integer",
                    "nullable": true,
                    "comment": "Variable Context identification number. Field links to the VariableContexts lookup table."
                },
                {
                    "name": "recdatecreated",
                    "type": "timestamp(0) without time zone",
                    "nullable": false,
                    "default": "timezone('UTC'::text, now())"
                },
                {
                    "name": "recdatemodified",
                    "type": "timestamp(0) without time zone",
                    "nullable": false
                }
            ],
            "indexes": [
                {
                    "name": "variables_pkey",
                    "def": "CREATE UNIQUE INDEX variables_pkey ON ndb.variables USING btree (variableid)",
                    "table": "ndb.variables",
                    "columns": [
                        "variableid"
                    ]
                },
                {
                    "name": "ix_taxonid_variables",
                    "def": "CREATE INDEX ix_taxonid_variables ON ndb.variables USING btree (taxonid) WITH (fillfactor='10')",
                    "table": "ndb.variables",
                    "columns": [
                        "taxonid"
                    ]
                },
                {
                    "name": "variableel",
                    "def": "CREATE INDEX variableel ON ndb.variables USING btree (taxonid, variableelementid, variableunitsid)",
                    "table": "ndb.variables",
                    "columns": [
                        "taxonid",
                        "variableelementid",
                        "variableunitsid"
                    ]
                },
                {
                    "name": "variables_unique",
                    "def": "CREATE UNIQUE INDEX variables_unique ON ndb.variables USING btree (taxonid, variableelementid, variableunitsid, variablecontextid)",
                    "table": "ndb.variables",
                    "columns": [
                        "taxonid",
                        "variableelementid",
                        "variableunitsid",
                        "variablecontextid"
                    ]
                }
            ],
            "constraints": [
                {
                    "name": "fk_variables_taxa",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (taxonid) REFERENCES ndb.taxa(taxonid) ON UPDATE CASCADE ON DELETE CASCADE",
                    "table": "ndb.variables",
                    "referenced_table": "taxa",
                    "columns": [
                        "taxonid"
                    ],
                    "referenced_columns": [
                        "taxonid"
                    ]
                },
                {
                    "name": "fk_variables_variablecontexts",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (variablecontextid) REFERENCES ndb.variablecontexts(variablecontextid) ON UPDATE CASCADE ON DELETE CASCADE",
                    "table": "ndb.variables",
                    "referenced_table": "variablecontexts",
                    "columns": [
                        "variablecontextid"
                    ],
                    "referenced_columns": [
                        "variablecontextid"
                    ]
                },
                {
                    "name": "fk_variables_variableelements",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (variableelementid) REFERENCES ndb.variableelements(variableelementid) ON UPDATE CASCADE ON DELETE CASCADE",
                    "table": "ndb.variables",
                    "referenced_table": "variableelements",
                    "columns": [
                        "variableelementid"
                    ],
                    "referenced_columns": [
                        "variableelementid"
                    ]
                },
                {
                    "name": "variables_pkey",
                    "type": "PRIMARY KEY",
                    "def": "PRIMARY KEY (variableid)",
                    "table": "ndb.variables",
                    "referenced_table": "",
                    "columns": [
                        "variableid"
                    ]
                },
                {
                    "name": "fk_variables_variableunits",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (variableunitsid) REFERENCES ndb.variableunits(variableunitsid) ON UPDATE CASCADE ON DELETE CASCADE",
                    "table": "ndb.variables",
                    "referenced_table": "variableunits",
                    "columns": [
                        "variableunitsid"
                    ],
                    "referenced_columns": [
                        "variableunitsid"
                    ]
                },
                {
                    "name": "variables_unique",
                    "type": "UNIQUE",
                    "def": "UNIQUE (taxonid, variableelementid, variableunitsid, variablecontextid)",
                    "table": "ndb.variables",
                    "referenced_table": "",
                    "columns": [
                        "taxonid",
                        "variableelementid",
                        "variableunitsid",
                        "variablecontextid"
                    ]
                }
            ],
            "triggers": [
                {
                    "name": "tr_sites_modifydate",
                    "def": "CREATE TRIGGER tr_sites_modifydate BEFORE INSERT OR UPDATE ON ndb.variables FOR EACH ROW EXECUTE FUNCTION ndb.update_recdatemodified()"
                }
            ]
        },
        {
            "name": "ndb.variableunits",
            "type": "BASE TABLE",
            "comment": "Lookup table of Variable Units. Table is referenced by the Variables table.",
            "columns": [
                {
                    "name": "variableunitsid",
                    "type": "integer",
                    "nullable": false,
                    "default": "nextval('ndb.seq_variableunits_variableunitsid'::regclass)",
                    "comment": "An arbitrary Variable Units identification number."
                },
                {
                    "name": "variableunits",
                    "type": "varchar(64)",
                    "nullable": false,
                    "comment": "The units of measurement. For fauna, these are «present/absent», «NISP» (Number of Individual Specimens), and «MNI» (Minimum Number of Individuals). For pollen, these are «NISP» (pollen counts) and «percent». Units for plant macrofossils include «present/absent» and «NISP», as well as a number of quantitative concentration measurements and semi-quantitative abundance measurements such as «1-5 scale». Examples of charcoal measurement units are «fragments/ml» and «µm^2/ml»."
                },
                {
                    "name": "recdatecreated",
                    "type": "timestamp(0) without time zone",
                    "nullable": false,
                    "default": "timezone('UTC'::text, now())"
                },
                {
                    "name": "recdatemodified",
                    "type": "timestamp(0) without time zone",
                    "nullable": false
                }
            ],
            "indexes": [
                {
                    "name": "variableunits_pkey",
                    "def": "CREATE UNIQUE INDEX variableunits_pkey ON ndb.variableunits USING btree (variableunitsid)",
                    "table": "ndb.variableunits",
                    "columns": [
                        "variableunitsid"
                    ]
                }
            ],
            "constraints": [
                {
                    "name": "variableunits_pkey",
                    "type": "PRIMARY KEY",
                    "def": "PRIMARY KEY (variableunitsid)",
                    "table": "ndb.variableunits",
                    "referenced_table": "",
                    "columns": [
                        "variableunitsid"
                    ]
                }
            ],
            "triggers": [
                {
                    "name": "tr_sites_modifydate",
                    "def": "CREATE TRIGGER tr_sites_modifydate BEFORE INSERT OR UPDATE ON ndb.variableunits FOR EACH ROW EXECUTE FUNCTION ndb.update_recdatemodified()"
                }
            ]
        },
        {
            "name": "ndb.samplekeywords",
            "type": "BASE TABLE",
            "comment": "This table lists the Sample Analysts.",
            "columns": [
                {
                    "name": "sampleid",
                    "type": "integer",
                    "nullable": false,
                    "comment": "Sample identification number. Field links to the Samples table."
                },
                {
                    "name": "keywordid",
                    "type": "integer",
                    "nullable": false,
                    "comment": "Keyword identification number. Field links to the Keywords lookup table."
                },
                {
                    "name": "recdatecreated",
                    "type": "timestamp(0) without time zone",
                    "nullable": false,
                    "default": "timezone('UTC'::text, now())"
                },
                {
                    "name": "recdatemodified",
                    "type": "timestamp(0) without time zone",
                    "nullable": false
                }
            ],
            "indexes": [
                {
                    "name": "samplekeywords_pkey",
                    "def": "CREATE UNIQUE INDEX samplekeywords_pkey ON ndb.samplekeywords USING btree (sampleid, keywordid)",
                    "table": "ndb.samplekeywords",
                    "columns": [
                        "sampleid",
                        "keywordid"
                    ]
                },
                {
                    "name": "ix_keywordid_samplekeywords",
                    "def": "CREATE INDEX ix_keywordid_samplekeywords ON ndb.samplekeywords USING btree (keywordid) WITH (fillfactor='10')",
                    "table": "ndb.samplekeywords",
                    "columns": [
                        "keywordid"
                    ]
                },
                {
                    "name": "ix_sampleid_samplekeywords",
                    "def": "CREATE INDEX ix_sampleid_samplekeywords ON ndb.samplekeywords USING btree (sampleid) WITH (fillfactor='10')",
                    "table": "ndb.samplekeywords",
                    "columns": [
                        "sampleid"
                    ]
                }
            ],
            "constraints": [
                {
                    "name": "fk_samplekeywords_keywords",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (keywordid) REFERENCES ndb.keywords(keywordid)",
                    "table": "ndb.samplekeywords",
                    "referenced_table": "keywords",
                    "columns": [
                        "keywordid"
                    ],
                    "referenced_columns": [
                        "keywordid"
                    ]
                },
                {
                    "name": "samplekeywords_pkey",
                    "type": "PRIMARY KEY",
                    "def": "PRIMARY KEY (sampleid, keywordid)",
                    "table": "ndb.samplekeywords",
                    "referenced_table": "",
                    "columns": [
                        "sampleid",
                        "keywordid"
                    ]
                },
                {
                    "name": "fk_samplekeywords_samples",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (sampleid) REFERENCES ndb.samples(sampleid) ON UPDATE CASCADE ON DELETE CASCADE",
                    "table": "ndb.samplekeywords",
                    "referenced_table": "samples",
                    "columns": [
                        "sampleid"
                    ],
                    "referenced_columns": [
                        "sampleid"
                    ]
                }
            ],
            "triggers": [
                {
                    "name": "tr_sites_modifydate",
                    "def": "CREATE TRIGGER tr_sites_modifydate BEFORE INSERT OR UPDATE ON ndb.samplekeywords FOR EACH ROW EXECUTE FUNCTION ndb.update_recdatemodified()"
                }
            ]
        },
        {
            "name": "ndb.samples",
            "type": "BASE TABLE",
            "comment": "This table stores sample data. Samples belong to Analysis Units, which belong to Collection Units, which belong to Sites. Samples also belong to a Dataset, and the Dataset determines the type of sample. Thus, there could be two different samples from the same Analysis Unit, one belonging to a pollen dataset, the other to a plant macrofossil dataset.",
            "columns": [
                {
                    "name": "sampleid",
                    "type": "integer",
                    "nullable": false,
                    "default": "nextval('ndb.seq_samples_sampleid'::regclass)",
                    "comment": "An arbitrary Sample identification number."
                },
                {
                    "name": "analysisunitid",
                    "type": "integer",
                    "nullable": false,
                    "comment": "Analysis Unit identification number. Field links to the AnalysisUnits table."
                },
                {
                    "name": "datasetid",
                    "type": "integer",
                    "nullable": false,
                    "comment": "Dataset identification number. Field links to the Datasets table."
                },
                {
                    "name": "samplename",
                    "type": "varchar(80)",
                    "nullable": true,
                    "comment": "Sample name if any."
                },
                {
                    "name": "analysisdate",
                    "type": "date",
                    "nullable": true,
                    "comment": "Date of analysis."
                },
                {
                    "name": "labnumber",
                    "type": "varchar(40)",
                    "nullable": true,
                    "comment": "Laboratory number for the sample. A special case regards geochronologic samples, for which the LabNumber is the number, if any, assigned by the submitter, not the number assigned by the radiocarbon laboratory, which is in the Geochronology table."
                },
                {
                    "name": "preparationmethod",
                    "type": "text",
                    "nullable": true,
                    "comment": "Description, notes, or comments on preparation methods. For faunal samples, notes on screening methods or screen size are stored here."
                },
                {
                    "name": "notes",
                    "type": "text",
                    "nullable": true,
                    "comment": "Free form note or comments about the sample."
                },
                {
                    "name": "recdatecreated",
                    "type": "timestamp(0) without time zone",
                    "nullable": false,
                    "default": "timezone('UTC'::text, now())"
                },
                {
                    "name": "recdatemodified",
                    "type": "timestamp(0) without time zone",
                    "nullable": false
                },
                {
                    "name": "sampledate",
                    "type": "date",
                    "nullable": true
                },
                {
                    "name": "taxonid",
                    "type": "integer",
                    "nullable": true
                }
            ],
            "indexes": [
                {
                    "name": "samples_pkey",
                    "def": "CREATE UNIQUE INDEX samples_pkey ON ndb.samples USING btree (sampleid)",
                    "table": "ndb.samples",
                    "columns": [
                        "sampleid"
                    ]
                },
                {
                    "name": "ix_analysisunitid_samples",
                    "def": "CREATE INDEX ix_analysisunitid_samples ON ndb.samples USING btree (analysisunitid) WITH (fillfactor='10')",
                    "table": "ndb.samples",
                    "columns": [
                        "analysisunitid"
                    ]
                },
                {
                    "name": "ix_datasetid_samples",
                    "def": "CREATE INDEX ix_datasetid_samples ON ndb.samples USING btree (datasetid) WITH (fillfactor='10')",
                    "table": "ndb.samples",
                    "columns": [
                        "datasetid"
                    ]
                },
                {
                    "name": "sample_taxon_idx",
                    "def": "CREATE INDEX sample_taxon_idx ON ndb.samples USING btree (taxonid)",
                    "table": "ndb.samples",
                    "columns": [
                        "taxonid"
                    ]
                }
            ],
            "constraints": [
                {
                    "name": "fk_samples_analysisunits",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (analysisunitid) REFERENCES ndb.analysisunits(analysisunitid) ON UPDATE CASCADE ON DELETE CASCADE",
                    "table": "ndb.samples",
                    "referenced_table": "analysisunits",
                    "columns": [
                        "analysisunitid"
                    ],
                    "referenced_columns": [
                        "analysisunitid"
                    ]
                },
                {
                    "name": "fk_samples_datasets",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (datasetid) REFERENCES ndb.datasets(datasetid) ON UPDATE CASCADE ON DELETE CASCADE",
                    "table": "ndb.samples",
                    "referenced_table": "datasets",
                    "columns": [
                        "datasetid"
                    ],
                    "referenced_columns": [
                        "datasetid"
                    ]
                },
                {
                    "name": "samples_pkey",
                    "type": "PRIMARY KEY",
                    "def": "PRIMARY KEY (sampleid)",
                    "table": "ndb.samples",
                    "referenced_table": "",
                    "columns": [
                        "sampleid"
                    ]
                },
                {
                    "name": "fk_samples_taxa",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (taxonid) REFERENCES ndb.taxa(taxonid)",
                    "table": "ndb.samples",
                    "referenced_table": "taxa",
                    "columns": [
                        "taxonid"
                    ],
                    "referenced_columns": [
                        "taxonid"
                    ]
                }
            ],
            "triggers": [
                {
                    "name": "tr_sites_modifydate",
                    "def": "CREATE TRIGGER tr_sites_modifydate BEFORE INSERT OR UPDATE ON ndb.samples FOR EACH ROW EXECUTE FUNCTION ndb.update_recdatemodified()"
                }
            ]
        },
        {
            "name": "ap.datasetkeywords",
            "type": "VIEW",
            "columns": [
                {
                    "name": "datasetid",
                    "type": "integer",
                    "nullable": true
                },
                {
                    "name": "keywordid",
                    "type": "integer",
                    "nullable": true
                }
            ],
            "def": "CREATE VIEW datasetkeywords AS (\n SELECT DISTINCT s.datasetid,\n    k.keywordid\n   FROM (ndb.samples s\n     JOIN ndb.samplekeywords k ON ((s.sampleid = k.sampleid)))\n)",
            "referenced_tables": [
                "ndb.samples",
                "ndb.samplekeywords"
            ]
        },
        {
            "name": "ndb.datasetpis",
            "type": "BASE TABLE",
            "columns": [
                {
                    "name": "datasetid",
                    "type": "integer",
                    "nullable": false,
                    "comment": "Dataset identification number. Field links to Dataset table."
                },
                {
                    "name": "contactid",
                    "type": "integer",
                    "nullable": false,
                    "comment": "Contact identification number. Field links to Contacts table."
                },
                {
                    "name": "piorder",
                    "type": "integer",
                    "nullable": true,
                    "comment": "Order in which PIs are listed."
                },
                {
                    "name": "recdatecreated",
                    "type": "timestamp(0) without time zone",
                    "nullable": false,
                    "default": "timezone('UTC'::text, now())"
                },
                {
                    "name": "recdatemodified",
                    "type": "timestamp(0) without time zone",
                    "nullable": false
                }
            ],
            "indexes": [
                {
                    "name": "ix_contactid_datasetpis",
                    "def": "CREATE INDEX ix_contactid_datasetpis ON ndb.datasetpis USING btree (contactid) WITH (fillfactor='10')",
                    "table": "ndb.datasetpis",
                    "columns": [
                        "contactid"
                    ]
                },
                {
                    "name": "ix_datasetid_datasetpis",
                    "def": "CREATE INDEX ix_datasetid_datasetpis ON ndb.datasetpis USING btree (datasetid) WITH (fillfactor='10')",
                    "table": "ndb.datasetpis",
                    "columns": [
                        "datasetid"
                    ]
                }
            ],
            "constraints": [
                {
                    "name": "fk_datasetpis_contacts",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (contactid) REFERENCES ndb.contacts(contactid) ON UPDATE CASCADE",
                    "table": "ndb.datasetpis",
                    "referenced_table": "contacts",
                    "columns": [
                        "contactid"
                    ],
                    "referenced_columns": [
                        "contactid"
                    ]
                },
                {
                    "name": "fk_datasetpis_datasets",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (datasetid) REFERENCES ndb.datasets(datasetid) ON UPDATE CASCADE ON DELETE CASCADE",
                    "table": "ndb.datasetpis",
                    "referenced_table": "datasets",
                    "columns": [
                        "datasetid"
                    ],
                    "referenced_columns": [
                        "datasetid"
                    ]
                }
            ],
            "triggers": [
                {
                    "name": "tr_sites_modifydate",
                    "def": "CREATE TRIGGER tr_sites_modifydate BEFORE INSERT OR UPDATE ON ndb.datasetpis FOR EACH ROW EXECUTE FUNCTION ndb.update_recdatemodified()"
                }
            ]
        },
        {
            "name": "ndb.datasetpublications",
            "type": "BASE TABLE",
            "comment": "This table lists the publications for datasets.",
            "columns": [
                {
                    "name": "datasetid",
                    "type": "integer",
                    "nullable": false,
                    "comment": "Dataset identification number. Field links to Dataset table."
                },
                {
                    "name": "publicationid",
                    "type": "integer",
                    "nullable": false,
                    "comment": "Publication identification number. Field links to Publications table."
                },
                {
                    "name": "primarypub",
                    "type": "boolean",
                    "nullable": true,
                    "comment": "Is «True» if the publication is the primary publication for the dataset."
                },
                {
                    "name": "recdatecreated",
                    "type": "timestamp(0) without time zone",
                    "nullable": false,
                    "default": "timezone('UTC'::text, now())"
                },
                {
                    "name": "recdatemodified",
                    "type": "timestamp(0) without time zone",
                    "nullable": false
                }
            ],
            "indexes": [
                {
                    "name": "datasetpublications_pkey",
                    "def": "CREATE UNIQUE INDEX datasetpublications_pkey ON ndb.datasetpublications USING btree (datasetid, publicationid)",
                    "table": "ndb.datasetpublications",
                    "columns": [
                        "datasetid",
                        "publicationid"
                    ]
                },
                {
                    "name": "ix_datasetid_datasetpublications",
                    "def": "CREATE INDEX ix_datasetid_datasetpublications ON ndb.datasetpublications USING btree (datasetid) WITH (fillfactor='10')",
                    "table": "ndb.datasetpublications",
                    "columns": [
                        "datasetid"
                    ]
                },
                {
                    "name": "ix_publicationid_datasetpublications",
                    "def": "CREATE INDEX ix_publicationid_datasetpublications ON ndb.datasetpublications USING btree (publicationid) WITH (fillfactor='10')",
                    "table": "ndb.datasetpublications",
                    "columns": [
                        "publicationid"
                    ]
                }
            ],
            "constraints": [
                {
                    "name": "datasetpublications_pkey",
                    "type": "PRIMARY KEY",
                    "def": "PRIMARY KEY (datasetid, publicationid)",
                    "table": "ndb.datasetpublications",
                    "referenced_table": "",
                    "columns": [
                        "datasetid",
                        "publicationid"
                    ]
                },
                {
                    "name": "fk_datasetpublications_datasets",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (datasetid) REFERENCES ndb.datasets(datasetid) ON UPDATE CASCADE ON DELETE CASCADE",
                    "table": "ndb.datasetpublications",
                    "referenced_table": "datasets",
                    "columns": [
                        "datasetid"
                    ],
                    "referenced_columns": [
                        "datasetid"
                    ]
                },
                {
                    "name": "fk_datasetpublications_publications",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (publicationid) REFERENCES ndb.publications(publicationid)",
                    "table": "ndb.datasetpublications",
                    "referenced_table": "publications",
                    "columns": [
                        "publicationid"
                    ],
                    "referenced_columns": [
                        "publicationid"
                    ]
                }
            ],
            "triggers": [
                {
                    "name": "tr_sites_modifydate",
                    "def": "CREATE TRIGGER tr_sites_modifydate BEFORE INSERT OR UPDATE ON ndb.datasetpublications FOR EACH ROW EXECUTE FUNCTION ndb.update_recdatemodified()"
                }
            ]
        },
        {
            "name": "ndb.publicationauthors",
            "type": "BASE TABLE",
            "comment": "This table lists authors as their names are given in publications. Only the initials are stored for authors’ given names. The ContactID links to the author’s full name and contact data in the Contacts table. Thus, for a bibliographic entry, Charles Robert Darwin is listed as C. R. Darwin, or as C. Darwin if the publication did not include his middle name. Book editors are also stored in this table if the entire book is cited. However, if a book chapter or section is cited, authors are stored in this table, but the book editors are stored in the PublicationEditors table. Thus, for the following reference, G. C. Frison is stored in the PublicationAuthors table.\nFrison, G. C., editor. 1996. The Mill Iron site. University of New Mexico Press, Albuquerque, New Mexico, USA.\nWhereas for the following publication, L. S. Cummings is listed in the PublicationAuthors table, and G. C. Frison is listed in the PublicationEditors table.\nCummings, L. S. 1996. Paleoenvironmental interpretations for the Mill Iron site: stratigraphic pollen and phyrolith analysis. Pages 177-193 in G. C. Frison, editor. The Mill Iron site. University of New Mexico Press, Albuquerque, New Mexico, USA.",
            "columns": [
                {
                    "name": "authorid",
                    "type": "integer",
                    "nullable": false,
                    "default": "nextval('ndb.seq_publicationauthors_authorid'::regclass)",
                    "comment": "An arbitrary Author identification number."
                },
                {
                    "name": "publicationid",
                    "type": "integer",
                    "nullable": false,
                    "comment": "Publication identification number. Field links to the Publications table."
                },
                {
                    "name": "authororder",
                    "type": "integer",
                    "nullable": true,
                    "comment": "Ordinal number for the position in which the author’s name appears in the publication’s author list."
                },
                {
                    "name": "familyname",
                    "type": "varchar(80)",
                    "nullable": true,
                    "comment": "Family name of author"
                },
                {
                    "name": "initials",
                    "type": "varchar(8)",
                    "nullable": true,
                    "comment": "Initials of author’s given names"
                },
                {
                    "name": "suffix",
                    "type": "varchar(8)",
                    "nullable": true,
                    "comment": "Authors suffix (e.g. «Jr.»)"
                },
                {
                    "name": "contactid",
                    "type": "integer",
                    "nullable": true,
                    "comment": "Contact identification number. Field links to the Contacts table."
                },
                {
                    "name": "recdatecreated",
                    "type": "timestamp(0) without time zone",
                    "nullable": false,
                    "default": "timezone('UTC'::text, now())"
                },
                {
                    "name": "recdatemodified",
                    "type": "timestamp(0) without time zone",
                    "nullable": false
                }
            ],
            "indexes": [
                {
                    "name": "publicationauthors_pkey",
                    "def": "CREATE UNIQUE INDEX publicationauthors_pkey ON ndb.publicationauthors USING btree (authorid)",
                    "table": "ndb.publicationauthors",
                    "columns": [
                        "authorid"
                    ]
                },
                {
                    "name": "ix_contactid_publicationauthors",
                    "def": "CREATE INDEX ix_contactid_publicationauthors ON ndb.publicationauthors USING btree (contactid) WITH (fillfactor='10')",
                    "table": "ndb.publicationauthors",
                    "columns": [
                        "contactid"
                    ]
                },
                {
                    "name": "ix_publicationid_publicationauthors",
                    "def": "CREATE INDEX ix_publicationid_publicationauthors ON ndb.publicationauthors USING btree (publicationid) WITH (fillfactor='10')",
                    "table": "ndb.publicationauthors",
                    "columns": [
                        "publicationid"
                    ]
                }
            ],
            "constraints": [
                {
                    "name": "fk_publicationauthors_contacts",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (contactid) REFERENCES ndb.contacts(contactid) ON UPDATE CASCADE",
                    "table": "ndb.publicationauthors",
                    "referenced_table": "contacts",
                    "columns": [
                        "contactid"
                    ],
                    "referenced_columns": [
                        "contactid"
                    ]
                },
                {
                    "name": "publicationauthors_pkey",
                    "type": "PRIMARY KEY",
                    "def": "PRIMARY KEY (authorid)",
                    "table": "ndb.publicationauthors",
                    "referenced_table": "",
                    "columns": [
                        "authorid"
                    ]
                },
                {
                    "name": "fk_publicationauthors_publications",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (publicationid) REFERENCES ndb.publications(publicationid) ON UPDATE CASCADE ON DELETE CASCADE",
                    "table": "ndb.publicationauthors",
                    "referenced_table": "publications",
                    "columns": [
                        "publicationid"
                    ],
                    "referenced_columns": [
                        "publicationid"
                    ]
                }
            ],
            "triggers": [
                {
                    "name": "tr_sites_modifydate",
                    "def": "CREATE TRIGGER tr_sites_modifydate BEFORE INSERT OR UPDATE ON ndb.publicationauthors FOR EACH ROW EXECUTE FUNCTION ndb.update_recdatemodified()"
                }
            ]
        },
        {
            "name": "ap.datasetpisauthors",
            "type": "VIEW",
            "columns": [
                {
                    "name": "datasetid",
                    "type": "integer",
                    "nullable": true
                },
                {
                    "name": "contactid",
                    "type": "integer",
                    "nullable": true
                }
            ],
            "def": "CREATE VIEW datasetpisauthors AS (\n SELECT datasetpublications.datasetid,\n    publicationauthors.contactid\n   FROM ((ndb.datasetpublications\n     JOIN ndb.publications ON ((datasetpublications.publicationid = publications.publicationid)))\n     JOIN ndb.publicationauthors ON ((publications.publicationid = publicationauthors.publicationid)))\nUNION\n SELECT datasetpis.datasetid,\n    datasetpis.contactid\n   FROM ndb.datasetpis\n)",
            "referenced_tables": [
                "ndb.datasetpublications",
                "ndb.publications",
                "ndb.publicationauthors",
                "ndb.datasetpis"
            ]
        },
        {
            "name": "ap.faunranges",
            "type": "BASE TABLE",
            "columns": [
                {
                    "name": "gid",
                    "type": "integer",
                    "nullable": false,
                    "default": "nextval('ap.faunranges_gid_seq'::regclass)"
                },
                {
                    "name": "spid",
                    "type": "varchar(10)",
                    "nullable": true
                },
                {
                    "name": "sciname",
                    "type": "varchar(254)",
                    "nullable": true
                },
                {
                    "name": "the_geom",
                    "type": "geometry(MultiPolygon,4326)",
                    "nullable": true
                }
            ],
            "indexes": [
                {
                    "name": "faunranges_pkey",
                    "def": "CREATE UNIQUE INDEX faunranges_pkey ON ap.faunranges USING btree (gid)",
                    "table": "ap.faunranges",
                    "columns": [
                        "gid"
                    ]
                },
                {
                    "name": "geom_idx",
                    "def": "CREATE INDEX geom_idx ON ap.faunranges USING gist (the_geom)",
                    "table": "ap.faunranges",
                    "columns": [
                        "the_geom"
                    ]
                },
                {
                    "name": "sciname_idx",
                    "def": "CREATE INDEX sciname_idx ON ap.faunranges USING btree (sciname)",
                    "table": "ap.faunranges",
                    "columns": [
                        "sciname"
                    ]
                }
            ],
            "constraints": [
                {
                    "name": "faunranges_pkey",
                    "type": "PRIMARY KEY",
                    "def": "PRIMARY KEY (gid)",
                    "table": "ap.faunranges",
                    "referenced_table": "",
                    "columns": [
                        "gid"
                    ]
                }
            ]
        },
        {
            "name": "ap.querytable",
            "type": "BASE TABLE",
            "columns": [
                {
                    "name": "siteid",
                    "type": "integer",
                    "nullable": true
                },
                {
                    "name": "sitename",
                    "type": "varchar(128)",
                    "nullable": true
                },
                {
                    "name": "datasetid",
                    "type": "integer",
                    "nullable": true
                },
                {
                    "name": "chronologyid",
                    "type": "integer",
                    "nullable": true
                },
                {
                    "name": "altitude",
                    "type": "double precision",
                    "nullable": true
                },
                {
                    "name": "datasettype",
                    "type": "varchar(64)",
                    "nullable": true
                },
                {
                    "name": "databaseid",
                    "type": "integer",
                    "nullable": true
                },
                {
                    "name": "collectionunitid",
                    "type": "integer",
                    "nullable": true
                },
                {
                    "name": "colltype",
                    "type": "varchar(64)",
                    "nullable": true
                },
                {
                    "name": "depenvt",
                    "type": "varchar(255)",
                    "nullable": true
                },
                {
                    "name": "geog",
                    "type": "geography",
                    "nullable": true
                },
                {
                    "name": "older",
                    "type": "double precision",
                    "nullable": true
                },
                {
                    "name": "younger",
                    "type": "double precision",
                    "nullable": true
                },
                {
                    "name": "agetype",
                    "type": "varchar(64)",
                    "nullable": true
                },
                {
                    "name": "publications",
                    "type": "integer[]",
                    "nullable": true
                },
                {
                    "name": "taxa",
                    "type": "integer[]",
                    "nullable": true
                },
                {
                    "name": "keywords",
                    "type": "integer[]",
                    "nullable": true
                },
                {
                    "name": "contacts",
                    "type": "integer[]",
                    "nullable": true
                },
                {
                    "name": "collectionunit",
                    "type": "jsonb",
                    "nullable": true
                },
                {
                    "name": "geopol",
                    "type": "integer[]",
                    "nullable": true
                }
            ],
            "indexes": [
                {
                    "name": "altitudeidx",
                    "def": "CREATE INDEX altitudeidx ON ap.querytable USING btree (altitude)",
                    "table": "ap.querytable",
                    "columns": [
                        "altitude"
                    ]
                },
                {
                    "name": "atyindex",
                    "def": "CREATE INDEX atyindex ON ap.querytable USING btree (agetype)",
                    "table": "ap.querytable",
                    "columns": [
                        "agetype"
                    ]
                },
                {
                    "name": "contactidindex",
                    "def": "CREATE INDEX contactidindex ON ap.querytable USING gin (contacts gin__int_ops)",
                    "table": "ap.querytable",
                    "columns": [
                        "contacts"
                    ]
                },
                {
                    "name": "datasetidindex",
                    "def": "CREATE INDEX datasetidindex ON ap.querytable USING btree (datasetid)",
                    "table": "ap.querytable",
                    "columns": [
                        "datasetid"
                    ]
                },
                {
                    "name": "depenvindex",
                    "def": "CREATE INDEX depenvindex ON ap.querytable USING btree (depenvt)",
                    "table": "ap.querytable",
                    "columns": [
                        "depenvt"
                    ]
                },
                {
                    "name": "distinctrows",
                    "def": "CREATE UNIQUE INDEX distinctrows ON ap.querytable USING btree (datasetid, chronologyid)",
                    "table": "ap.querytable",
                    "columns": [
                        "datasetid",
                        "chronologyid"
                    ]
                },
                {
                    "name": "dstindex",
                    "def": "CREATE INDEX dstindex ON ap.querytable USING btree (datasettype)",
                    "table": "ap.querytable",
                    "columns": [
                        "datasettype"
                    ]
                },
                {
                    "name": "geoidindex",
                    "def": "CREATE INDEX geoidindex ON ap.querytable USING gin (geopol gin__int_ops)",
                    "table": "ap.querytable",
                    "columns": [
                        "geopol"
                    ]
                },
                {
                    "name": "keywordidindex",
                    "def": "CREATE INDEX keywordidindex ON ap.querytable USING gin (keywords gin__int_ops)",
                    "table": "ap.querytable",
                    "columns": [
                        "keywords"
                    ]
                },
                {
                    "name": "olderidx",
                    "def": "CREATE INDEX olderidx ON ap.querytable USING btree (older)",
                    "table": "ap.querytable",
                    "columns": [
                        "older"
                    ]
                },
                {
                    "name": "publicationidindex",
                    "def": "CREATE INDEX publicationidindex ON ap.querytable USING gin (publications gin__int_ops)",
                    "table": "ap.querytable",
                    "columns": [
                        "publications"
                    ]
                },
                {
                    "name": "siteidindex",
                    "def": "CREATE INDEX siteidindex ON ap.querytable USING btree (siteid)",
                    "table": "ap.querytable",
                    "columns": [
                        "siteid"
                    ]
                },
                {
                    "name": "sitename",
                    "def": "CREATE INDEX sitename ON ap.querytable USING gist (sitename gist_trgm_ops)",
                    "table": "ap.querytable",
                    "columns": [
                        "sitename"
                    ]
                },
                {
                    "name": "spatialgeom",
                    "def": "CREATE INDEX spatialgeom ON ap.querytable USING gist (geog)",
                    "table": "ap.querytable",
                    "columns": [
                        "geog"
                    ]
                },
                {
                    "name": "taxonidindex",
                    "def": "CREATE INDEX taxonidindex ON ap.querytable USING gin (taxa gin__int_ops)",
                    "table": "ap.querytable",
                    "columns": [
                        "taxa"
                    ]
                },
                {
                    "name": "youngeridx",
                    "def": "CREATE INDEX youngeridx ON ap.querytable USING btree (younger)",
                    "table": "ap.querytable",
                    "columns": [
                        "younger"
                    ]
                }
            ]
        },
        {
            "name": "ap.geopolnames",
            "type": "MATERIALIZED VIEW",
            "columns": [
                {
                    "name": "siteid",
                    "type": "integer",
                    "nullable": true
                },
                {
                    "name": "names",
                    "type": "varchar[]",
                    "nullable": true
                }
            ],
            "indexes": [
                {
                    "name": "gpsiteidindex",
                    "def": "CREATE UNIQUE INDEX gpsiteidindex ON ap.geopolnames USING btree (siteid)",
                    "table": "ap.geopolnames",
                    "columns": [
                        "siteid"
                    ]
                }
            ],
            "def": "CREATE MATERIALIZED VIEW geopolnames AS (\n SELECT DISTINCT sq.siteid,\n    array_agg(sq.geopoliticalname) AS names\n   FROM ( SELECT DISTINCT p.siteid,\n            gpu.geopoliticalname,\n            gpu.rank\n           FROM (ndb.geopoliticalunits gpu\n             JOIN ( SELECT p_1.siteid,\n                    unnest(p_1.geopol) AS unnest\n                   FROM ap.querytable p_1) p ON ((p.unnest = gpu.geopoliticalid)))\n          ORDER BY p.siteid, gpu.rank) sq\n  GROUP BY sq.siteid\n)",
            "referenced_tables": [
                "ndb.geopoliticalunits",
                "ap.querytable"
            ]
        },
        {
            "name": "ap.icesheets",
            "type": "BASE TABLE",
            "columns": [
                {
                    "name": "gid",
                    "type": "integer",
                    "nullable": false,
                    "default": "nextval('ap.icesheets_gid_seq'::regclass)"
                },
                {
                    "name": "area_km2",
                    "type": "numeric",
                    "nullable": true
                },
                {
                    "name": "geom",
                    "type": "geometry(MultiPolygon,4326)",
                    "nullable": true
                },
                {
                    "name": "age",
                    "type": "integer",
                    "nullable": true
                },
                {
                    "name": "ka",
                    "type": "numeric",
                    "nullable": true
                },
                {
                    "name": "cal",
                    "type": "numeric",
                    "nullable": true
                },
                {
                    "name": "symb",
                    "type": "varchar(10)",
                    "nullable": true
                },
                {
                    "name": "calage",
                    "type": "integer",
                    "nullable": true
                }
            ],
            "indexes": [
                {
                    "name": "icesheets_pkey",
                    "def": "CREATE UNIQUE INDEX icesheets_pkey ON ap.icesheets USING btree (gid)",
                    "table": "ap.icesheets",
                    "columns": [
                        "gid"
                    ]
                },
                {
                    "name": "icesheets_geom_idx",
                    "def": "CREATE INDEX icesheets_geom_idx ON ap.icesheets USING gist (geom)",
                    "table": "ap.icesheets",
                    "columns": [
                        "geom"
                    ]
                }
            ],
            "constraints": [
                {
                    "name": "icesheets_pkey",
                    "type": "PRIMARY KEY",
                    "def": "PRIMARY KEY (gid)",
                    "table": "ap.icesheets",
                    "referenced_table": "",
                    "columns": [
                        "gid"
                    ]
                }
            ]
        },
        {
            "name": "ap.pollensumgroups",
            "type": "BASE TABLE",
            "columns": [
                {
                    "name": "recid",
                    "type": "integer",
                    "nullable": false
                },
                {
                    "name": "ecolgroupid",
                    "type": "varchar(4)",
                    "nullable": false
                },
                {
                    "name": "sumgroupid",
                    "type": "integer",
                    "nullable": false
                }
            ],
            "indexes": [
                {
                    "name": "pollensumgroups_pkey",
                    "def": "CREATE UNIQUE INDEX pollensumgroups_pkey ON ap.pollensumgroups USING btree (recid)",
                    "table": "ap.pollensumgroups",
                    "columns": [
                        "recid"
                    ]
                }
            ],
            "constraints": [
                {
                    "name": "pollensumgroups_pkey",
                    "type": "PRIMARY KEY",
                    "def": "PRIMARY KEY (recid)",
                    "table": "ap.pollensumgroups",
                    "referenced_table": "",
                    "columns": [
                        "recid"
                    ]
                }
            ]
        },
        {
            "name": "ap.pollensums",
            "type": "BASE TABLE",
            "columns": [
                {
                    "name": "sampleid",
                    "type": "integer",
                    "nullable": false
                },
                {
                    "name": "trsh",
                    "type": "double precision",
                    "nullable": true
                },
                {
                    "name": "palm",
                    "type": "double precision",
                    "nullable": true
                },
                {
                    "name": "uphe",
                    "type": "double precision",
                    "nullable": true
                },
                {
                    "name": "succ",
                    "type": "double precision",
                    "nullable": true
                },
                {
                    "name": "vacr",
                    "type": "double precision",
                    "nullable": true
                },
                {
                    "name": "upbr",
                    "type": "double precision",
                    "nullable": true
                },
                {
                    "name": "fung",
                    "type": "double precision",
                    "nullable": true
                },
                {
                    "name": "aqvp",
                    "type": "double precision",
                    "nullable": true
                },
                {
                    "name": "aqbr",
                    "type": "double precision",
                    "nullable": true
                },
                {
                    "name": "mang",
                    "type": "double precision",
                    "nullable": true
                },
                {
                    "name": "unid",
                    "type": "double precision",
                    "nullable": true
                },
                {
                    "name": "anac",
                    "type": "double precision",
                    "nullable": true
                },
                {
                    "name": "seed",
                    "type": "double precision",
                    "nullable": true
                },
                {
                    "name": "total",
                    "type": "double precision",
                    "nullable": false
                }
            ]
        },
        {
            "name": "ap.sitegadm",
            "type": "BASE TABLE",
            "columns": [
                {
                    "name": "siteid",
                    "type": "integer",
                    "nullable": true
                },
                {
                    "name": "fid",
                    "type": "integer",
                    "nullable": true
                }
            ]
        },
        {
            "name": "ap.summaries",
            "type": "BASE TABLE",
            "columns": [
                {
                    "name": "dbdate",
                    "type": "date",
                    "nullable": false
                },
                {
                    "name": "sites",
                    "type": "bigint",
                    "nullable": true
                },
                {
                    "name": "datasets",
                    "type": "bigint",
                    "nullable": true
                },
                {
                    "name": "publications",
                    "type": "bigint",
                    "nullable": true
                },
                {
                    "name": "observations",
                    "type": "bigint",
                    "nullable": true
                }
            ],
            "indexes": [
                {
                    "name": "summaries_pkey",
                    "def": "CREATE UNIQUE INDEX summaries_pkey ON ap.summaries USING btree (dbdate)",
                    "table": "ap.summaries",
                    "columns": [
                        "dbdate"
                    ]
                }
            ],
            "constraints": [
                {
                    "name": "summaries_pkey",
                    "type": "PRIMARY KEY",
                    "def": "PRIMARY KEY (dbdate)",
                    "table": "ap.summaries",
                    "referenced_table": "",
                    "columns": [
                        "dbdate"
                    ]
                }
            ]
        },
        {
            "name": "ndb.datasettaxagrouptypes",
            "type": "BASE TABLE",
            "columns": [
                {
                    "name": "datasettypeid",
                    "type": "integer",
                    "nullable": false
                },
                {
                    "name": "taxagroupid",
                    "type": "varchar(3)",
                    "nullable": false
                },
                {
                    "name": "recdatecreated",
                    "type": "timestamp(0) without time zone",
                    "nullable": false,
                    "default": "timezone('UTC'::text, now())"
                },
                {
                    "name": "recdatemodified",
                    "type": "timestamp(0) without time zone",
                    "nullable": false
                }
            ],
            "indexes": [
                {
                    "name": "datasettaxagrouptypes_pkey",
                    "def": "CREATE UNIQUE INDEX datasettaxagrouptypes_pkey ON ndb.datasettaxagrouptypes USING btree (datasettypeid, taxagroupid)",
                    "table": "ndb.datasettaxagrouptypes",
                    "columns": [
                        "datasettypeid",
                        "taxagroupid"
                    ]
                }
            ],
            "constraints": [
                {
                    "name": "datasettaxagrouptypes_pkey",
                    "type": "PRIMARY KEY",
                    "def": "PRIMARY KEY (datasettypeid, taxagroupid)",
                    "table": "ndb.datasettaxagrouptypes",
                    "referenced_table": "",
                    "columns": [
                        "datasettypeid",
                        "taxagroupid"
                    ]
                },
                {
                    "name": "fk_datasettaxagrouptypes_datasettypes",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (datasettypeid) REFERENCES ndb.datasettypes(datasettypeid) ON UPDATE CASCADE ON DELETE CASCADE",
                    "table": "ndb.datasettaxagrouptypes",
                    "referenced_table": "datasettypes",
                    "columns": [
                        "datasettypeid"
                    ],
                    "referenced_columns": [
                        "datasettypeid"
                    ]
                },
                {
                    "name": "fk_datasettaxagrouptypes_taxagrouptypes",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (taxagroupid) REFERENCES ndb.taxagrouptypes(taxagroupid) ON UPDATE CASCADE ON DELETE CASCADE",
                    "table": "ndb.datasettaxagrouptypes",
                    "referenced_table": "taxagrouptypes",
                    "columns": [
                        "taxagroupid"
                    ],
                    "referenced_columns": [
                        "taxagroupid"
                    ]
                }
            ],
            "triggers": [
                {
                    "name": "tr_sites_modifydate",
                    "def": "CREATE TRIGGER tr_sites_modifydate BEFORE INSERT OR UPDATE ON ndb.datasettaxagrouptypes FOR EACH ROW EXECUTE FUNCTION ndb.update_recdatemodified()"
                }
            ]
        },
        {
            "name": "ndb.taxa",
            "type": "BASE TABLE",
            "comment": "This table lists all taxa in the database. Most taxa are biological taxa; however, some are biometric measures and some are physical parameters.",
            "columns": [
                {
                    "name": "taxonid",
                    "type": "integer",
                    "nullable": false,
                    "default": "nextval('ndb.seq_taxa_taxonid'::regclass)",
                    "comment": "An arbitrary Taxon identification number."
                },
                {
                    "name": "taxoncode",
                    "type": "varchar(64)",
                    "nullable": false,
                    "comment": "A code for the Taxon. These codes are useful for other software or output for which the complete name is too long. Because of the very large number of taxa, codes can be duplicated for different Taxa Groups. In general, these various Taxa Groups are analyzed separately, and no duplication will occur within a dataset. However, if Taxa Groups are combined, unique codes can be generated by prefixing with the TaxaGroupID, For example:\n*VPL:Cle Clethra\n*MAM:Cle Clethrionomys\nA set of conventions has been established for codes. In some cases conventions differ depending on whether the organism is covered by rules of botanical nomenclature (BN) or zoological nomenclature (ZN).\n*Genus – Three-letter code, first letter capitalized, generally the first three unless already used.\n**Ace Acer\n**Cle Clethrionomys\n*Subgenus – The genus code plus a two-letter subgenus code, first letter capitalized, separated by a period.\n**Pin.Pi Pinus subg. Pinus\n**Syn.Mi Synaptomys (Mictomys)\n*Species – The genus code plus a two-letter, lower-case species code, separated by a period.\n**Ace.sa Acer saccharum\n**Ace.sc Acer saccharinum\n**Cle.ga Clethrionomys gapperi\n*Subspecies or variety – The species code a two-letter, lower-case subspecies code, separated by a period.\n**Aln.vi.si Alnus viridis subsp. Sinuata\n**Bis.bi.an Bison bison antiquus\n*Family – Six-letter code, first letter capitalized, consisting of three letters followed by «eae» (BN) or «dae» (ZN).\n**Roseae Rosaceae\n**Bovdae Bovidae\n*Subfamily or tribe – (BN) Family code plus two-letter subfamily code, first letter capitalized, separated by a priod. (ZN) Six-letter code, first letter capitalized, consisting of three letters followed by «nae».\n**Asteae.As Asteraceae subf. Asteroideae\n**Asteae.Cy Asteraceae tribe Cynarea\n**Arvnae Arvicolinae\n*Order – (BN) Six-letter code, first letter capitalized, consisting of three letters followed by «les». (ZN) Six-letter code, first letter capitalized, consisting of three letters, followed by the last three letters of the order name, unless the order name is ≤6 letters long, in which case the code = the order name. Zoological orders do not have a common ending.\n**Ercles Ericales\n**Artyla Artiodactyla\n**Rodtia Rodentia\n*Taxonomic levels higher than order – Six-letter code, first letter capitalized, consisting of three letters, followed by the last three letters of the order name, unless the order name is ≤6 letters long, in which case the code = the order name..\n**Magida Magnoliopsida\n**Magyta Magnoliophyta\n**Mamlia Mammalia\n*Types – The conventional taxon code followed by «-type».\n**Aln.in-t Alnus incana-type\n**Amb-t Ambrosia-type\n*cf. – «cf. » is placed in the proper position.\n**Odc.cf.he Odocoileus cf. O. hemionus\n**cf.Odc.he cf. Odocoileus hemionus\n**cf.Odc cf. Odocoileus\n*aff. – «aff. » is abbreviated to «af. ».\n**af.Can.di aff. Canis dirus\n*? – «?» is placed in the proper position.\n**?Pro.lo ?Procyon lotor\n*Alternative names – A slash is placed between the conventional abbreviations for the alternative taxa.\n**Ost/Cpn Ostrya/Carpinus\n**Mstdae/Mepdae Mustelidae/Mephitidae\n*Undifferentiated taxa – (BN) «.ud» is added to the code. (ZN) «.sp » is added to the code.\n**Aln.ud Alnus undiff.\n**Roseae.ud Rosaceae undiff.\n**Mms.sp Mammuthus sp.\n**Taydae.sp Tayassuidae sp\n*Parenthetic modifiers – The conventional taxon code with an appropriate abbreviation for the modifier separated by periods. Multiple modifiers also separated by periods. *Abbreviations for pollen morphological modifiers follow Iversen and Troels-Smith (1950).\n**Raneae.C3 Ranunculaceae (tricolpate)\n**Raneae.Cperi Ranunculaceae (pericolpate)\n**Pineae.ves.ud Pinaceae (vesiculate) undiff.\n**Myteae.Csyn.psi Myrtaceae (syncolpate, psilate)\n**Bet.>20µ Betula (>20 µm)\n*Non-biological taxa – Use appropriate abbreviations.\n**bulk.dens Bulk density\n**LOI Loss-on-ignition\n**Bet.pol.diam Betula mean pollen-grain diameter\n"
                },
                {
                    "name": "taxonname",
                    "type": "text",
                    "nullable": false,
                    "comment": "Name of the taxon. Most TaxonNames are biological taxa; however, some are biometric measures and some are physical parameters. In addition, some biological taxa may have parenthetic non-Latin modifers, e.g. «Betula (>20 µm)» for Betula pollen grains >20 µm in diameter. In general, the names used in Neotoma are those used by the original investigator. In particular, identifications are not changed, although Dataset notes can be added to the database regarding particular identifications. However, some corrections and synonymizations are made. These include:\n*Misspellings are corrected.\n*Nomenclatural, homotypic, or objective synonyms may be applied. Because these synonyms unambiguously refer to the same taxon, no change in identification is implied. For example, the old family name for the grasses «Gramineae» is changed to «Poaceae».\n*Taxonomic, heterotypic, or subjective synonyms may be applied if the change does not effectively assign the specimen to a different taxon. Although two names may have been based on different type specimens, if further research has shown that these are in fact the same taxon, the name is changed to the accepted name. These synonymizations should not cause confusion. However, uncritical synonymization, although taxonomically correct, can result in loss of information, and should be avoided. For example, although a number of recent studies have shown that the Taxodiaceae should be merged with the Cupressaceae, simply synonymizing Taxodiaceae with Cupressaceae may expand the universe of taxa beyond that implied by the original investigator. For example, a palynologist in the southeastern United States may have used «Taxodiaceae» to imply «Taxodium», which is the only genus of the family that has occurred in the region since the Pliocene, but used the the family name because, palynologically, Taxodiuim cannot be differentiated from other Taxodiaceae. However, well preserved Taxodium pollen grains can be differentiated from the other Cupressaceous genera in the region, Juniperus and Chamaecyperus. Thus, the appropriate synonymization for «Taxodiaceae» in this region would be «Taxodium» or «Taxodium-type», which would retain the original taxonomic precision. On the other hand, the old «TCT» shorthand for «Taxodiaceae/Cupressaceae/Taxaceae» now becomes «Cupressaceae/Taxaceae» with no loss of information.\n*For alternative taxonomic designations, the order may be changed. For example, «Ostrya/Carpinus» would be substituted for «Carpinus/Ostrya».\n"
                },
                {
                    "name": "author",
                    "type": "varchar(128)",
                    "nullable": true,
                    "comment": "Author(s) of the name. Neither the pollen database nor FAUNMAP stored author names, so these do not currently exist in Neotoma for plant and mammal names. These databases follow standard taxonomic references (e.g. Flora of North America, Flora Europaea, Wilson and Reeder's Mammal Species of the World), which, of course, do cite the original authors. However, for beetles, the standard practice is to cite original author names; therefore, this field was added to Neotoma."
                },
                {
                    "name": "valid",
                    "type": "boolean",
                    "nullable": true
                },
                {
                    "name": "highertaxonid",
                    "type": "integer",
                    "nullable": true,
                    "comment": "The TaxonID of the next higher taxonomic rank, for example, the HigherTaxonID for «Bison» is the TaxonID for «Bovidae». For «cf.'s» and «-types», the next higher rank may be much higher owing to the uncertainty of the identification; the HigherTaxonID for «cf. Bison bison» is the TaxonId for «Mammalia». The HigherTaxonID implements the taxonomic hierarchy in Neotoma."
                },
                {
                    "name": "extinct",
                    "type": "boolean",
                    "nullable": false,
                    "comment": "True if the taxon is extinct, False if extant."
                },
                {
                    "name": "taxagroupid",
                    "type": "varchar(3)",
                    "nullable": false,
                    "comment": "The TaxaGroupID facilitates rapid extraction of taxa groups that are typically grouped together for analysis. Some of these groups contain taxa in different classes or phyla. For example, vascular plants include the Spermatophyta and Pteridophyta; the herps include Reptilia and Amphibia; the testate amoebae include taxa from different phyla. Field links to the TaxaGroupTypes table."
                },
                {
                    "name": "publicationid",
                    "type": "integer",
                    "nullable": true,
                    "comment": "Publication identification number. Field links to the Publications table."
                },
                {
                    "name": "validatorid",
                    "type": "integer",
                    "nullable": true
                },
                {
                    "name": "validatedate",
                    "type": "date",
                    "nullable": true
                },
                {
                    "name": "notes",
                    "type": "text",
                    "nullable": true,
                    "comment": "Free form notes or comments about the Taxon."
                },
                {
                    "name": "recdatecreated",
                    "type": "timestamp(0) without time zone",
                    "nullable": true,
                    "default": "timezone('UTC'::text, now())"
                },
                {
                    "name": "recdatemodified",
                    "type": "timestamp(0) without time zone",
                    "nullable": true
                }
            ],
            "indexes": [
                {
                    "name": "taxa_pkey",
                    "def": "CREATE UNIQUE INDEX taxa_pkey ON ndb.taxa USING btree (taxonid)",
                    "table": "ndb.taxa",
                    "columns": [
                        "taxonid"
                    ]
                },
                {
                    "name": "ix_taxagroupid_taxa",
                    "def": "CREATE INDEX ix_taxagroupid_taxa ON ndb.taxa USING btree (taxagroupid) WITH (fillfactor='10')",
                    "table": "ndb.taxa",
                    "columns": [
                        "taxagroupid"
                    ]
                },
                {
                    "name": "ix_taxonname_taxa",
                    "def": "CREATE INDEX ix_taxonname_taxa ON ndb.taxa USING btree (taxonname) WITH (fillfactor='10')",
                    "table": "ndb.taxa",
                    "columns": [
                        "taxonname"
                    ]
                },
                {
                    "name": "taxonames_idx",
                    "def": "CREATE INDEX taxonames_idx ON ndb.taxa USING gin (taxonname gin_trgm_ops)",
                    "table": "ndb.taxa",
                    "columns": [
                        "taxonname"
                    ]
                },
                {
                    "name": "taxonname_btree",
                    "def": "CREATE INDEX taxonname_btree ON ndb.taxa USING btree (taxonname)",
                    "table": "ndb.taxa",
                    "columns": [
                        "taxonname"
                    ]
                }
            ],
            "constraints": [
                {
                    "name": "fk_validatorid",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (validatorid) REFERENCES ndb.contacts(contactid)",
                    "table": "ndb.taxa",
                    "referenced_table": "contacts",
                    "columns": [
                        "validatorid"
                    ],
                    "referenced_columns": [
                        "contactid"
                    ]
                },
                {
                    "name": "fk_publicationid",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (publicationid) REFERENCES ndb.publications(publicationid)",
                    "table": "ndb.taxa",
                    "referenced_table": "publications",
                    "columns": [
                        "publicationid"
                    ],
                    "referenced_columns": [
                        "publicationid"
                    ]
                },
                {
                    "name": "fk_highertaxonid",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (highertaxonid) REFERENCES ndb.taxa(taxonid)",
                    "table": "ndb.taxa",
                    "referenced_table": "taxa",
                    "columns": [
                        "highertaxonid"
                    ],
                    "referenced_columns": [
                        "taxonid"
                    ]
                },
                {
                    "name": "taxa_pkey",
                    "type": "PRIMARY KEY",
                    "def": "PRIMARY KEY (taxonid)",
                    "table": "ndb.taxa",
                    "referenced_table": "",
                    "columns": [
                        "taxonid"
                    ]
                },
                {
                    "name": "fk_taxagroupid",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (taxagroupid) REFERENCES ndb.taxagrouptypes(taxagroupid)",
                    "table": "ndb.taxa",
                    "referenced_table": "taxagrouptypes",
                    "columns": [
                        "taxagroupid"
                    ],
                    "referenced_columns": [
                        "taxagroupid"
                    ]
                }
            ],
            "triggers": [
                {
                    "name": "tr_sites_modifydate",
                    "def": "CREATE TRIGGER tr_sites_modifydate BEFORE INSERT OR UPDATE ON ndb.taxa FOR EACH ROW EXECUTE FUNCTION ndb.update_recdatemodified()"
                }
            ]
        },
        {
            "name": "ap.taxaindatasetview",
            "type": "VIEW",
            "columns": [
                {
                    "name": "taxonid",
                    "type": "integer",
                    "nullable": true
                },
                {
                    "name": "taxonname",
                    "type": "text",
                    "nullable": true
                },
                {
                    "name": "taxagroupid",
                    "type": "varchar(3)",
                    "nullable": true
                },
                {
                    "name": "datasettypeids",
                    "type": "jsonb",
                    "nullable": true
                }
            ],
            "def": "CREATE VIEW taxaindatasetview AS (\n SELECT t.taxonid,\n    t.taxonname,\n    t.taxagroupid,\n    jsonb_agg(dtgt.datasettypeid) AS datasettypeids\n   FROM ((ndb.taxa t\n     LEFT JOIN ndb.datasettaxagrouptypes dtgt ON (((t.taxagroupid)::text = (dtgt.taxagroupid)::text)))\n     JOIN ndb.variables v ON ((t.taxonid = v.taxonid)))\n  WHERE (t.valid = true)\n  GROUP BY t.taxonid, t.taxonname, t.taxagroupid\n  ORDER BY t.taxonname\n)",
            "referenced_tables": [
                "ndb.taxa",
                "ndb.datasettaxagrouptypes",
                "ndb.variables"
            ]
        },
        {
            "name": "ndb.contacts",
            "type": "BASE TABLE",
            "comment": "This table lists persons and organizations referenced by the Chronologies, Collectors, DatasetPIs, DatasetSubmissions, Projects, PublicationAuthors, SampleAnalysts, and SiteImages tables.",
            "columns": [
                {
                    "name": "contactid",
                    "type": "integer",
                    "nullable": false,
                    "default": "nextval('ndb.seq_contacts_contactid'::regclass)",
                    "comment": "An arbitrary Contact identification number."
                },
                {
                    "name": "aliasid",
                    "type": "integer",
                    "nullable": true,
                    "comment": "The ContactID of a person’s current name. If the AliasID is different from the ContactID, the ContactID refers to the person’s former name. For example, if J. L. Bouvier became J. B. Kennedy, the ContactID for J. B. Kennedy is the AliasID for J. L. Bouvier."
                },
                {
                    "name": "contactname",
                    "type": "varchar(80)",
                    "nullable": false,
                    "comment": "Full name of the person, last name first (e.g. «Simpson, George Gaylord») or name of organization or project (e.g. «Great Plains Flora Association»)."
                },
                {
                    "name": "contactstatusid",
                    "type": "integer",
                    "nullable": true,
                    "comment": "Current status of the person, organization, or project. Field links to the ContactStatuses lookup table."
                },
                {
                    "name": "familyname",
                    "type": "varchar(80)",
                    "nullable": true,
                    "comment": "Family or surname name of a person."
                },
                {
                    "name": "leadinginitials",
                    "type": "varchar(16)",
                    "nullable": true,
                    "comment": "Leading initials for given or forenames without spaces (e.g. «G.G.»)."
                },
                {
                    "name": "givennames",
                    "type": "varchar(80)",
                    "nullable": true,
                    "comment": "Given or forenames of a person (e.g. «George Gaylord»). Initials with spaces are used if full given names are not known (e.g. «G. G»)."
                },
                {
                    "name": "suffix",
                    "type": "varchar(16)",
                    "nullable": true,
                    "comment": "Suffix of a person’s name (e.g. «Jr.», «III»)."
                },
                {
                    "name": "title",
                    "type": "varchar(16)",
                    "nullable": true,
                    "comment": "A person’s title (e.g. «Dr.», «Prof.», «Prof. Dr»)."
                },
                {
                    "name": "phone",
                    "type": "varchar(64)",
                    "nullable": true,
                    "comment": "Telephone number."
                },
                {
                    "name": "fax",
                    "type": "varchar(64)",
                    "nullable": true,
                    "comment": "Fax number."
                },
                {
                    "name": "email",
                    "type": "varchar(64)",
                    "nullable": true,
                    "comment": "Email address."
                },
                {
                    "name": "url",
                    "type": "varchar(255)",
                    "nullable": true,
                    "comment": "Universal Resource Locator, an Internet World Wide Web address."
                },
                {
                    "name": "address",
                    "type": "text",
                    "nullable": true,
                    "comment": "Full mailing address."
                },
                {
                    "name": "notes",
                    "type": "text",
                    "nullable": true,
                    "comment": "Free form notes or comments about the person, organization, or project."
                },
                {
                    "name": "recdatecreated",
                    "type": "timestamp(0) without time zone",
                    "nullable": false,
                    "default": "timezone('UTC'::text, now())"
                },
                {
                    "name": "recdatemodified",
                    "type": "timestamp(0) without time zone",
                    "nullable": false
                }
            ],
            "indexes": [
                {
                    "name": "contacts_pkey",
                    "def": "CREATE UNIQUE INDEX contacts_pkey ON ndb.contacts USING btree (contactid)",
                    "table": "ndb.contacts",
                    "columns": [
                        "contactid"
                    ]
                },
                {
                    "name": "familynames_idx",
                    "def": "CREATE INDEX familynames_idx ON ndb.contacts USING gin (familyname gin_trgm_ops)",
                    "table": "ndb.contacts",
                    "columns": [
                        "familyname"
                    ]
                }
            ],
            "constraints": [
                {
                    "name": "contacts_pkey",
                    "type": "PRIMARY KEY",
                    "def": "PRIMARY KEY (contactid)",
                    "table": "ndb.contacts",
                    "referenced_table": "",
                    "columns": [
                        "contactid"
                    ]
                },
                {
                    "name": "fk_contacts_contactstatuses",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (contactstatusid) REFERENCES ndb.contactstatuses(contactstatusid) ON UPDATE CASCADE ON DELETE SET NULL",
                    "table": "ndb.contacts",
                    "referenced_table": "contactstatuses",
                    "columns": [
                        "contactstatusid"
                    ],
                    "referenced_columns": [
                        "contactstatusid"
                    ]
                }
            ],
            "triggers": [
                {
                    "name": "tr_sites_modifydate",
                    "def": "CREATE TRIGGER tr_sites_modifydate BEFORE INSERT OR UPDATE ON ndb.contacts FOR EACH ROW EXECUTE FUNCTION ndb.update_recdatemodified()"
                }
            ]
        },
        {
            "name": "ndb.contactstatuses",
            "type": "BASE TABLE",
            "comment": "Lookup table of Contact Statuses. Table is referenced by the Contacts table.",
            "columns": [
                {
                    "name": "contactstatusid",
                    "type": "integer",
                    "nullable": false,
                    "default": "nextval('ndb.seq_contactstatuses_contactstatusid'::regclass)",
                    "comment": "An arbitrary Contact Status identification number."
                },
                {
                    "name": "contactstatus",
                    "type": "varchar(16)",
                    "nullable": true,
                    "comment": "Status of person, organization, or project."
                },
                {
                    "name": "statusdescription",
                    "type": "varchar(255)",
                    "nullable": true,
                    "comment": "Description of the status."
                },
                {
                    "name": "recdatecreated",
                    "type": "timestamp(0) without time zone",
                    "nullable": false,
                    "default": "timezone('UTC'::text, now())"
                },
                {
                    "name": "recdatemodified",
                    "type": "timestamp(0) without time zone",
                    "nullable": false
                }
            ],
            "indexes": [
                {
                    "name": "contactstatuses_pkey",
                    "def": "CREATE UNIQUE INDEX contactstatuses_pkey ON ndb.contactstatuses USING btree (contactstatusid)",
                    "table": "ndb.contactstatuses",
                    "columns": [
                        "contactstatusid"
                    ]
                }
            ],
            "constraints": [
                {
                    "name": "contactstatuses_pkey",
                    "type": "PRIMARY KEY",
                    "def": "PRIMARY KEY (contactstatusid)",
                    "table": "ndb.contactstatuses",
                    "referenced_table": "",
                    "columns": [
                        "contactstatusid"
                    ]
                }
            ],
            "triggers": [
                {
                    "name": "tr_sites_modifydate",
                    "def": "CREATE TRIGGER tr_sites_modifydate BEFORE INSERT OR UPDATE ON ndb.contactstatuses FOR EACH ROW EXECUTE FUNCTION ndb.update_recdatemodified()"
                }
            ]
        },
        {
            "name": "ndb.data",
            "type": "BASE TABLE",
            "comment": "The primary data table in the database. Each occurrence of a Variable in a sample comprises a record in the Data table.",
            "columns": [
                {
                    "name": "dataid",
                    "type": "integer",
                    "nullable": false,
                    "default": "nextval('ndb.seq_data_dataid'::regclass)"
                },
                {
                    "name": "sampleid",
                    "type": "integer",
                    "nullable": false,
                    "comment": "Sample identification number. Field links to Samples table."
                },
                {
                    "name": "variableid",
                    "type": "integer",
                    "nullable": false,
                    "comment": "Variable identification number. Field links to Variables table."
                },
                {
                    "name": "value",
                    "type": "double precision",
                    "nullable": true,
                    "comment": "The value of the variable."
                },
                {
                    "name": "recdatecreated",
                    "type": "timestamp(0) without time zone",
                    "nullable": false,
                    "default": "timezone('UTC'::text, now())"
                },
                {
                    "name": "recdatemodified",
                    "type": "timestamp(0) without time zone",
                    "nullable": false
                }
            ],
            "indexes": [
                {
                    "name": "data_pkey",
                    "def": "CREATE UNIQUE INDEX data_pkey ON ndb.data USING btree (dataid)",
                    "table": "ndb.data",
                    "columns": [
                        "dataid"
                    ]
                },
                {
                    "name": "data_sample_idx",
                    "def": "CREATE INDEX data_sample_idx ON ndb.data USING btree (sampleid)",
                    "table": "ndb.data",
                    "columns": [
                        "sampleid"
                    ]
                },
                {
                    "name": "data_variable_idx",
                    "def": "CREATE INDEX data_variable_idx ON ndb.data USING btree (variableid)",
                    "table": "ndb.data",
                    "columns": [
                        "variableid"
                    ]
                }
            ],
            "constraints": [
                {
                    "name": "data_pkey",
                    "type": "PRIMARY KEY",
                    "def": "PRIMARY KEY (dataid)",
                    "table": "ndb.data",
                    "referenced_table": "",
                    "columns": [
                        "dataid"
                    ]
                },
                {
                    "name": "fk_data_samples",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (sampleid) REFERENCES ndb.samples(sampleid) ON UPDATE CASCADE ON DELETE CASCADE",
                    "table": "ndb.data",
                    "referenced_table": "samples",
                    "columns": [
                        "sampleid"
                    ],
                    "referenced_columns": [
                        "sampleid"
                    ]
                },
                {
                    "name": "fk_data_variables",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (variableid) REFERENCES ndb.variables(variableid) ON UPDATE CASCADE ON DELETE CASCADE",
                    "table": "ndb.data",
                    "referenced_table": "variables",
                    "columns": [
                        "variableid"
                    ],
                    "referenced_columns": [
                        "variableid"
                    ]
                }
            ],
            "triggers": [
                {
                    "name": "tr_sites_modifydate",
                    "def": "CREATE TRIGGER tr_sites_modifydate BEFORE INSERT OR UPDATE ON ndb.data FOR EACH ROW EXECUTE FUNCTION ndb.update_recdatemodified()"
                }
            ]
        },
        {
            "name": "ndb.chronologies",
            "type": "BASE TABLE",
            "comment": "This table stores Chronology data. A Chronology refers to an explicit chronology assigned to a Collection Unit. A Chronology has Chronology Controls, the actual age-depth control points, which are stored in the ChronControls table. A Chronology is also based on an Age Model, which may be a numerical method that fits a curve to a set of age-depth control points or may simply be individually dated Analysis Units.\nA Collection Unit may have more than one Chronology, for example one in radiocarbon years and another in calibrated radiocarbon years. There may be a Chronology developed by the original author and another developed by a later research project. Chronologies may be stored for archival reasons, even though they are now believed to have problems, if they were used for an important research project. One Chronology per Age Type may be designated the default Chronology, which is the Chronology currently preferred by the database stewards.\nBased upon the Chronology, which includes the Age Model and the Chron Controls, ages are assigned to individual samples, which are stored in the SampleAges table.\nA younger and older age bounds are assigned to the Chronology. Within these bounds the Chronology is regarded as reliable. Ages may be assigned to samples beyond the reliable age bounds, but these are not considered reliable",
            "columns": [
                {
                    "name": "chronologyid",
                    "type": "integer",
                    "nullable": false,
                    "default": "nextval('ndb.seq_chronologies_chronologyid'::regclass)",
                    "comment": "An arbitrary Chronology identification number."
                },
                {
                    "name": "collectionunitid",
                    "type": "integer",
                    "nullable": false,
                    "comment": "Collection Unit to which the Chronology applies. Field links to the CollectionUnits table."
                },
                {
                    "name": "agetypeid",
                    "type": "integer",
                    "nullable": false,
                    "comment": "Age type or units. Field links to the AgeTypes table."
                },
                {
                    "name": "contactid",
                    "type": "integer",
                    "nullable": true,
                    "comment": "Person who developed the Age Model. Field links to the Contacts table."
                },
                {
                    "name": "isdefault",
                    "type": "boolean",
                    "nullable": false,
                    "comment": "Indicates whether the Chronology is a default chronology or not. Default status is determined by a Neotoma data steward. Collection Units may have more than one default Chronology, but may have only one default Chronology per Age Type. Thus, there may be a default radiocarbon year Chronology and a default calibrated radiocarbon year Chronology, but only one of each. Default Chronologies may be used by the Neotoma web site, or other web sites, for displaying default diagrams or time series of data. Default Chronologies may also be of considerable use for actual research purposes; however, users may of course choose to develop their own chronologies."
                },
                {
                    "name": "chronologyname",
                    "type": "varchar(80)",
                    "nullable": true,
                    "comment": "Optional name for the Chronology. Some examples are:\nCOHMAP chron 1 A Chronology assigned by the COHMAP project.\nCOHMAP chron 2 An alternative Chronology assigned by the COHMAP project\nNAPD 1 A Chronology assigned by the North American Pollen Database.\nGajewski 1995 A Chronology assigned by Gajewski (1995)."
                },
                {
                    "name": "dateprepared",
                    "type": "date",
                    "nullable": true,
                    "comment": "Date that the Chronology was prepared."
                },
                {
                    "name": "agemodel",
                    "type": "varchar(80)",
                    "nullable": true,
                    "comment": "The age model used for the Chronology. Some examples are: linear interpolation, 3rd order polynomial, and individually dated analysis units."
                },
                {
                    "name": "ageboundyounger",
                    "type": "integer",
                    "nullable": true,
                    "comment": "The younger reliable age bound for the Chronology. Younger ages may be assigned to samples, but are not regarded as reliable. If the entire Chronology is considered reliable, AgeBoundYounger is assigned the youngest sample age rounded down to the nearest 10. Thus, for 72 BP, AgeBoundYounger = 70 BP; for -45 BP, AgeBoundYounger = -50 BP."
                },
                {
                    "name": "ageboundolder",
                    "type": "integer",
                    "nullable": true,
                    "comment": "The older reliable age bound for the Chronology. Ages older than AgeOlderBound may be assigned to samples, but are not regarded as reliable. This situation is particularly true for ages extrapolated beyond the oldest Chron Control. . If the entire Chronology is considered reliable, AgeBoundOlder is assigned the oldest sample age rounded up to the nearest 10. Thus, for 12564 BP, AgeBoundOlder is 12570."
                },
                {
                    "name": "notes",
                    "type": "text",
                    "nullable": true,
                    "comment": "Free form notes or comments about the Chronology."
                },
                {
                    "name": "recdatecreated",
                    "type": "timestamp(0) without time zone",
                    "nullable": false,
                    "default": "timezone('UTC'::text, now())"
                },
                {
                    "name": "recdatemodified",
                    "type": "timestamp(0) without time zone",
                    "nullable": false
                }
            ],
            "indexes": [
                {
                    "name": "chronologies_pkey",
                    "def": "CREATE UNIQUE INDEX chronologies_pkey ON ndb.chronologies USING btree (chronologyid)",
                    "table": "ndb.chronologies",
                    "columns": [
                        "chronologyid"
                    ]
                },
                {
                    "name": "chroldage_idx",
                    "def": "CREATE INDEX chroldage_idx ON ndb.chronologies USING btree (ageboundolder)",
                    "table": "ndb.chronologies",
                    "columns": [
                        "ageboundolder"
                    ]
                },
                {
                    "name": "chryoungage_idx",
                    "def": "CREATE INDEX chryoungage_idx ON ndb.chronologies USING btree (ageboundyounger)",
                    "table": "ndb.chronologies",
                    "columns": [
                        "ageboundyounger"
                    ]
                },
                {
                    "name": "oldage_idx",
                    "def": "CREATE INDEX oldage_idx ON ndb.chronologies USING btree (ageboundolder)",
                    "table": "ndb.chronologies",
                    "columns": [
                        "ageboundolder"
                    ]
                },
                {
                    "name": "youngage_idx",
                    "def": "CREATE INDEX youngage_idx ON ndb.chronologies USING btree (ageboundyounger)",
                    "table": "ndb.chronologies",
                    "columns": [
                        "ageboundyounger"
                    ]
                }
            ],
            "constraints": [
                {
                    "name": "fk_chronologies_agetypes",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (agetypeid) REFERENCES ndb.agetypes(agetypeid) ON UPDATE CASCADE ON DELETE CASCADE",
                    "table": "ndb.chronologies",
                    "referenced_table": "agetypes",
                    "columns": [
                        "agetypeid"
                    ],
                    "referenced_columns": [
                        "agetypeid"
                    ]
                },
                {
                    "name": "chronologies_pkey",
                    "type": "PRIMARY KEY",
                    "def": "PRIMARY KEY (chronologyid)",
                    "table": "ndb.chronologies",
                    "referenced_table": "",
                    "columns": [
                        "chronologyid"
                    ]
                },
                {
                    "name": "fk_chronologies_collectionunits",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (collectionunitid) REFERENCES ndb.collectionunits(collectionunitid) ON UPDATE CASCADE ON DELETE CASCADE",
                    "table": "ndb.chronologies",
                    "referenced_table": "collectionunits",
                    "columns": [
                        "collectionunitid"
                    ],
                    "referenced_columns": [
                        "collectionunitid"
                    ]
                },
                {
                    "name": "fk_chronologies_contacts",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (contactid) REFERENCES ndb.contacts(contactid) ON UPDATE CASCADE",
                    "table": "ndb.chronologies",
                    "referenced_table": "contacts",
                    "columns": [
                        "contactid"
                    ],
                    "referenced_columns": [
                        "contactid"
                    ]
                }
            ],
            "triggers": [
                {
                    "name": "tr_sites_modifydate",
                    "def": "CREATE TRIGGER tr_sites_modifydate BEFORE INSERT OR UPDATE ON ndb.chronologies FOR EACH ROW EXECUTE FUNCTION ndb.update_recdatemodified()"
                }
            ]
        },
        {
            "name": "ndb.radiocarboncalibration",
            "type": "BASE TABLE",
            "comment": "Radiocarbon calibration table. This table is intended for quick calibration of age-model radiocarbon dates. These calibrated dates are for perusal and data exploration only. Please see Section 2.5 for a full discussion.",
            "columns": [
                {
                    "name": "c14yrbp",
                    "type": "integer",
                    "nullable": false,
                    "comment": "Age in radiocarbon years BP. The range is -100 to 45,000 by 1-year increments."
                },
                {
                    "name": "calyrbp",
                    "type": "integer",
                    "nullable": false,
                    "comment": "Age in calibrated radiocarbon years BP."
                }
            ],
            "indexes": [
                {
                    "name": "radiocarboncalibration_pkey",
                    "def": "CREATE UNIQUE INDEX radiocarboncalibration_pkey ON ndb.radiocarboncalibration USING btree (c14yrbp)",
                    "table": "ndb.radiocarboncalibration",
                    "columns": [
                        "c14yrbp"
                    ]
                }
            ],
            "constraints": [
                {
                    "name": "radiocarboncalibration_pkey",
                    "type": "PRIMARY KEY",
                    "def": "PRIMARY KEY (c14yrbp)",
                    "table": "ndb.radiocarboncalibration",
                    "referenced_table": "",
                    "columns": [
                        "c14yrbp"
                    ]
                }
            ]
        },
        {
            "name": "ndb.sampleages",
            "type": "BASE TABLE",
            "comment": "This table stores sample ages. Ages are assigned to a Chronology. Because there may be more than one Chronology for a Collection Unit, samples may be assigned different ages for different Chronologies. A simple example is one sample age in radiocarbon years and another in calibrated radiocarbon years. The age units are an attribute of the Chronology.",
            "columns": [
                {
                    "name": "sampleageid",
                    "type": "integer",
                    "nullable": false,
                    "default": "nextval('ndb.seq_sampleages_sampleageid'::regclass)",
                    "comment": "An arbitrary Sample Age identification number."
                },
                {
                    "name": "sampleid",
                    "type": "integer",
                    "nullable": false,
                    "comment": "Sample identification number. Field links to the Samples table."
                },
                {
                    "name": "chronologyid",
                    "type": "integer",
                    "nullable": false,
                    "comment": "Chronology identification number. Field links to the Chronologies table."
                },
                {
                    "name": "age",
                    "type": "double precision",
                    "nullable": true,
                    "comment": "Age of the sample"
                },
                {
                    "name": "ageyounger",
                    "type": "double precision",
                    "nullable": true,
                    "comment": "Younger error estimate of the age. The definition of this estimate is an attribute of the Chronology. Many ages do not have explicit error estimates assigned."
                },
                {
                    "name": "ageolder",
                    "type": "double precision",
                    "nullable": true,
                    "comment": "Older error estimate of the age."
                },
                {
                    "name": "recdatecreated",
                    "type": "timestamp(0) without time zone",
                    "nullable": false,
                    "default": "timezone('UTC'::text, now())"
                },
                {
                    "name": "recdatemodified",
                    "type": "timestamp(0) without time zone",
                    "nullable": false
                }
            ],
            "indexes": [
                {
                    "name": "sampleages_pkey",
                    "def": "CREATE UNIQUE INDEX sampleages_pkey ON ndb.sampleages USING btree (sampleageid)",
                    "table": "ndb.sampleages",
                    "columns": [
                        "sampleageid"
                    ]
                },
                {
                    "name": "ix_chronologyid_sampleages",
                    "def": "CREATE INDEX ix_chronologyid_sampleages ON ndb.sampleages USING btree (chronologyid) WITH (fillfactor='10')",
                    "table": "ndb.sampleages",
                    "columns": [
                        "chronologyid"
                    ]
                },
                {
                    "name": "ix_sampleid_sampleages",
                    "def": "CREATE INDEX ix_sampleid_sampleages ON ndb.sampleages USING btree (sampleid) WITH (fillfactor='10')",
                    "table": "ndb.sampleages",
                    "columns": [
                        "sampleid"
                    ]
                },
                {
                    "name": "smpage_idx",
                    "def": "CREATE INDEX smpage_idx ON ndb.sampleages USING btree (age)",
                    "table": "ndb.sampleages",
                    "columns": [
                        "age"
                    ]
                },
                {
                    "name": "smpageold_idx",
                    "def": "CREATE INDEX smpageold_idx ON ndb.sampleages USING btree (ageolder)",
                    "table": "ndb.sampleages",
                    "columns": [
                        "ageolder"
                    ]
                },
                {
                    "name": "smpageyoung_idx",
                    "def": "CREATE INDEX smpageyoung_idx ON ndb.sampleages USING btree (ageyounger)",
                    "table": "ndb.sampleages",
                    "columns": [
                        "ageyounger"
                    ]
                }
            ],
            "constraints": [
                {
                    "name": "fk_sampleages_chronologies",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (chronologyid) REFERENCES ndb.chronologies(chronologyid) ON UPDATE CASCADE ON DELETE CASCADE",
                    "table": "ndb.sampleages",
                    "referenced_table": "chronologies",
                    "columns": [
                        "chronologyid"
                    ],
                    "referenced_columns": [
                        "chronologyid"
                    ]
                },
                {
                    "name": "sampleages_pkey",
                    "type": "PRIMARY KEY",
                    "def": "PRIMARY KEY (sampleageid)",
                    "table": "ndb.sampleages",
                    "referenced_table": "",
                    "columns": [
                        "sampleageid"
                    ]
                },
                {
                    "name": "fk_sampleages_samples",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (sampleid) REFERENCES ndb.samples(sampleid) ON UPDATE CASCADE ON DELETE CASCADE",
                    "table": "ndb.sampleages",
                    "referenced_table": "samples",
                    "columns": [
                        "sampleid"
                    ],
                    "referenced_columns": [
                        "sampleid"
                    ]
                }
            ],
            "triggers": [
                {
                    "name": "tr_sites_modifydate",
                    "def": "CREATE TRIGGER tr_sites_modifydate BEFORE INSERT OR UPDATE ON ndb.sampleages FOR EACH ROW EXECUTE FUNCTION ndb.update_recdatemodified()"
                }
            ]
        },
        {
            "name": "ndb.collectiontypes",
            "type": "BASE TABLE",
            "comment": "This table is a lookup table for types of Collection Units, or Collection Types. Table is referenced by the CollectionUnits table.",
            "columns": [
                {
                    "name": "colltypeid",
                    "type": "integer",
                    "nullable": false,
                    "default": "nextval('ndb.seq_collectiontypes_colltypeid'::regclass)",
                    "comment": "An arbitrary Collection Type identification number."
                },
                {
                    "name": "colltype",
                    "type": "varchar(64)",
                    "nullable": true,
                    "comment": "The Collection Type. Types include cores, sections, excavations, and animal middens. Collection Units may be modern collections, surface float, or isolated specimens. Composite Collections Units include different kinds of Analysis Units, for example a modern surface sample for ostracodes and an associated water sample."
                },
                {
                    "name": "recdatecreated",
                    "type": "timestamp(0) without time zone",
                    "nullable": false,
                    "default": "timezone('UTC'::text, now())"
                },
                {
                    "name": "recdatemodified",
                    "type": "timestamp(0) without time zone",
                    "nullable": false
                }
            ],
            "indexes": [
                {
                    "name": "collectiontypes_pkey",
                    "def": "CREATE UNIQUE INDEX collectiontypes_pkey ON ndb.collectiontypes USING btree (colltypeid)",
                    "table": "ndb.collectiontypes",
                    "columns": [
                        "colltypeid"
                    ]
                }
            ],
            "constraints": [
                {
                    "name": "collectiontypes_pkey",
                    "type": "PRIMARY KEY",
                    "def": "PRIMARY KEY (colltypeid)",
                    "table": "ndb.collectiontypes",
                    "referenced_table": "",
                    "columns": [
                        "colltypeid"
                    ]
                }
            ],
            "triggers": [
                {
                    "name": "tr_sites_modifydate",
                    "def": "CREATE TRIGGER tr_sites_modifydate BEFORE INSERT OR UPDATE ON ndb.collectiontypes FOR EACH ROW EXECUTE FUNCTION ndb.update_recdatemodified()"
                }
            ]
        },
        {
            "name": "ndb.collectionunits",
            "type": "BASE TABLE",
            "comment": "This table stores data for Collection Units.",
            "columns": [
                {
                    "name": "collectionunitid",
                    "type": "integer",
                    "nullable": false,
                    "default": "nextval('ndb.seq_collectionunits_collectionunitid'::regclass)",
                    "comment": "An arbitrary Collection Unit identification number."
                },
                {
                    "name": "handle",
                    "type": "varchar(10)",
                    "nullable": false,
                    "comment": "Code name for the Collection Unit. This code may be up to 10 characters, but an effort is made to keep these to 8 characters or less. Data are frequently distributed by Collection Unit, and the Handle is used for file names."
                },
                {
                    "name": "siteid",
                    "type": "integer",
                    "nullable": false,
                    "comment": "Site where CollectionUnit was located. Field links to Sites table."
                },
                {
                    "name": "colltypeid",
                    "type": "integer",
                    "nullable": true,
                    "comment": "Type of Collection Unit. Field links to the CollectionTypes table."
                },
                {
                    "name": "depenvtid",
                    "type": "integer",
                    "nullable": true,
                    "comment": "Depositional environment of the CollectionUnit. Normally, this key refers to the modern environment. For example, the site may be located on a colluvial slope, in which case the Depositional Environment may be Colluvium or Colluvial Fan. However, an excavation may extend into alluvial sediments, which represent a different depositional environment. These are accounted for by the Facies of the AnalysisUnit. Field links to the DepEnvtTypes table."
                },
                {
                    "name": "collunitname",
                    "type": "varchar(255)",
                    "nullable": true,
                    "comment": "Name of the Collection Unit. Examples: Core BPT82A, Structure 9, P4A Test 57. If faunal data are reported from a site or locality without explicit Collection Units, then data are assigned to a single Collection Unit with the name «Locality»."
                },
                {
                    "name": "colldate",
                    "type": "date",
                    "nullable": true,
                    "comment": "Date Collection Unit was collected."
                },
                {
                    "name": "colldevice",
                    "type": "varchar(255)",
                    "nullable": true,
                    "comment": "Device used for obtain Collection Unit. This field applies primarily to cores, for example «Wright square-rod piston corer (5 cm)»."
                },
                {
                    "name": "gpslatitude",
                    "type": "double precision",
                    "nullable": true,
                    "comment": "Precise latitude of the Collection Unit, typically taken with a GPS, although may be precisely measured from a map."
                },
                {
                    "name": "gpslongitude",
                    "type": "double precision",
                    "nullable": true,
                    "comment": "Precise longitude of the Collection Unit, typically taken with a GPS, although may be precisely measured from a map."
                },
                {
                    "name": "gpsaltitude",
                    "type": "double precision",
                    "nullable": true,
                    "comment": "Precise altitude of the Collection Unit, typically taken with a GPS or precisely obtained from a map."
                },
                {
                    "name": "gpserror",
                    "type": "double precision",
                    "nullable": true,
                    "comment": "Error in the horizontal GPS coordinates, if known."
                },
                {
                    "name": "waterdepth",
                    "type": "double precision",
                    "nullable": true,
                    "comment": "Depth of water at the Collection Unit location. This field applies mainly to Collection Units from lakes."
                },
                {
                    "name": "substrateid",
                    "type": "integer",
                    "nullable": true,
                    "comment": "Substrate or rock type on which the Collection Unit lies. Field links to the RockTypes table. This field is especially used for rodent middens."
                },
                {
                    "name": "slopeaspect",
                    "type": "integer",
                    "nullable": true,
                    "comment": "For Collection Units on slopes, the horizontal direction to which a slope faces measured in degrees clockwise from north. This field is especially used for rodent middens."
                },
                {
                    "name": "slopeangle",
                    "type": "integer",
                    "nullable": true,
                    "comment": "For Collection Units on slopes, the angle of slope from horizontal. field is especially used for rodent middens."
                },
                {
                    "name": "location",
                    "type": "varchar(255)",
                    "nullable": true,
                    "comment": "Short description of the location of the Collection Unit within the site."
                },
                {
                    "name": "notes",
                    "type": "text",
                    "nullable": true,
                    "comment": "Free form notes or comments about the Collection Unit."
                },
                {
                    "name": "recdatecreated",
                    "type": "timestamp(0) without time zone",
                    "nullable": false,
                    "default": "timezone('UTC'::text, now())"
                },
                {
                    "name": "recdatemodified",
                    "type": "timestamp(0) without time zone",
                    "nullable": false
                }
            ],
            "indexes": [
                {
                    "name": "collectionunits_pkey",
                    "def": "CREATE UNIQUE INDEX collectionunits_pkey ON ndb.collectionunits USING btree (collectionunitid)",
                    "table": "ndb.collectionunits",
                    "columns": [
                        "collectionunitid"
                    ]
                },
                {
                    "name": "ix_collectionunitid_collectionunits",
                    "def": "CREATE INDEX ix_collectionunitid_collectionunits ON ndb.collectionunits USING btree (collectionunitid) WITH (fillfactor='10')",
                    "table": "ndb.collectionunits",
                    "columns": [
                        "collectionunitid"
                    ]
                },
                {
                    "name": "ix_depenvtid_collectionunits",
                    "def": "CREATE INDEX ix_depenvtid_collectionunits ON ndb.collectionunits USING btree (depenvtid) WITH (fillfactor='10')",
                    "table": "ndb.collectionunits",
                    "columns": [
                        "depenvtid"
                    ]
                },
                {
                    "name": "ix_siteid_collectionunits",
                    "def": "CREATE INDEX ix_siteid_collectionunits ON ndb.collectionunits USING btree (siteid) WITH (fillfactor='10')",
                    "table": "ndb.collectionunits",
                    "columns": [
                        "siteid"
                    ]
                }
            ],
            "constraints": [
                {
                    "name": "fk_collectionunits_collectiontypes",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (colltypeid) REFERENCES ndb.collectiontypes(colltypeid) ON UPDATE CASCADE ON DELETE CASCADE",
                    "table": "ndb.collectionunits",
                    "referenced_table": "collectiontypes",
                    "columns": [
                        "colltypeid"
                    ],
                    "referenced_columns": [
                        "colltypeid"
                    ]
                },
                {
                    "name": "collectionunits_pkey",
                    "type": "PRIMARY KEY",
                    "def": "PRIMARY KEY (collectionunitid)",
                    "table": "ndb.collectionunits",
                    "referenced_table": "",
                    "columns": [
                        "collectionunitid"
                    ]
                },
                {
                    "name": "fk_collectionunits_depenvttypes",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (depenvtid) REFERENCES ndb.depenvttypes(depenvtid) ON UPDATE CASCADE ON DELETE CASCADE",
                    "table": "ndb.collectionunits",
                    "referenced_table": "depenvttypes",
                    "columns": [
                        "depenvtid"
                    ],
                    "referenced_columns": [
                        "depenvtid"
                    ]
                },
                {
                    "name": "fk_collectionunits_rocktypes",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (substrateid) REFERENCES ndb.rocktypes(rocktypeid) ON UPDATE CASCADE ON DELETE CASCADE",
                    "table": "ndb.collectionunits",
                    "referenced_table": "rocktypes",
                    "columns": [
                        "substrateid"
                    ],
                    "referenced_columns": [
                        "rocktypeid"
                    ]
                },
                {
                    "name": "fk_collectionunits_sites",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (siteid) REFERENCES ndb.sites(siteid) ON UPDATE CASCADE ON DELETE CASCADE",
                    "table": "ndb.collectionunits",
                    "referenced_table": "sites",
                    "columns": [
                        "siteid"
                    ],
                    "referenced_columns": [
                        "siteid"
                    ]
                }
            ],
            "triggers": [
                {
                    "name": "tr_sites_modifydate",
                    "def": "CREATE TRIGGER tr_sites_modifydate BEFORE INSERT OR UPDATE ON ndb.collectionunits FOR EACH ROW EXECUTE FUNCTION ndb.update_recdatemodified()"
                }
            ]
        },
        {
            "name": "ndb.constituentdatabases",
            "type": "BASE TABLE",
            "columns": [
                {
                    "name": "databaseid",
                    "type": "integer",
                    "nullable": false,
                    "default": "nextval('ndb.seq_constituentdatabases_databaseid'::regclass)"
                },
                {
                    "name": "databasename",
                    "type": "varchar(80)",
                    "nullable": false
                },
                {
                    "name": "contactid",
                    "type": "integer",
                    "nullable": true
                },
                {
                    "name": "url",
                    "type": "varchar(128)",
                    "nullable": true
                },
                {
                    "name": "recdatecreated",
                    "type": "timestamp(0) without time zone",
                    "nullable": false,
                    "default": "timezone('UTC'::text, now())"
                },
                {
                    "name": "recdatemodified",
                    "type": "timestamp(0) without time zone",
                    "nullable": false
                },
                {
                    "name": "description",
                    "type": "text",
                    "nullable": true
                }
            ],
            "indexes": [
                {
                    "name": "constituentdatabases_pkey",
                    "def": "CREATE UNIQUE INDEX constituentdatabases_pkey ON ndb.constituentdatabases USING btree (databaseid)",
                    "table": "ndb.constituentdatabases",
                    "columns": [
                        "databaseid"
                    ]
                }
            ],
            "constraints": [
                {
                    "name": "constituentdatabases_pkey",
                    "type": "PRIMARY KEY",
                    "def": "PRIMARY KEY (databaseid)",
                    "table": "ndb.constituentdatabases",
                    "referenced_table": "",
                    "columns": [
                        "databaseid"
                    ]
                },
                {
                    "name": "fk_constituentdatabases_contacts",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (contactid) REFERENCES ndb.contacts(contactid)",
                    "table": "ndb.constituentdatabases",
                    "referenced_table": "contacts",
                    "columns": [
                        "contactid"
                    ],
                    "referenced_columns": [
                        "contactid"
                    ]
                }
            ],
            "triggers": [
                {
                    "name": "tr_sites_modifydate",
                    "def": "CREATE TRIGGER tr_sites_modifydate BEFORE INSERT OR UPDATE ON ndb.constituentdatabases FOR EACH ROW EXECUTE FUNCTION ndb.update_recdatemodified()"
                }
            ]
        },
        {
            "name": "ndb.datasetdatabases",
            "type": "BASE TABLE",
            "columns": [
                {
                    "name": "datasetid",
                    "type": "integer",
                    "nullable": false
                },
                {
                    "name": "databaseid",
                    "type": "integer",
                    "nullable": false
                },
                {
                    "name": "recdatecreated",
                    "type": "timestamp(0) without time zone",
                    "nullable": false,
                    "default": "timezone('UTC'::text, now())"
                },
                {
                    "name": "recdatemodified",
                    "type": "timestamp(0) without time zone",
                    "nullable": false
                }
            ],
            "indexes": [
                {
                    "name": "datasetdatabases_pkey",
                    "def": "CREATE UNIQUE INDEX datasetdatabases_pkey ON ndb.datasetdatabases USING btree (datasetid, databaseid)",
                    "table": "ndb.datasetdatabases",
                    "columns": [
                        "datasetid",
                        "databaseid"
                    ]
                },
                {
                    "name": "ix_datasetid_datasetdatabases",
                    "def": "CREATE INDEX ix_datasetid_datasetdatabases ON ndb.datasetdatabases USING btree (datasetid) WITH (fillfactor='10')",
                    "table": "ndb.datasetdatabases",
                    "columns": [
                        "datasetid"
                    ]
                },
                {
                    "name": "ix_projectid_datasetdatabases",
                    "def": "CREATE INDEX ix_projectid_datasetdatabases ON ndb.datasetdatabases USING btree (databaseid) WITH (fillfactor='10')",
                    "table": "ndb.datasetdatabases",
                    "columns": [
                        "databaseid"
                    ]
                }
            ],
            "constraints": [
                {
                    "name": "fk_datasetdatabases_constituentdatabases",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (databaseid) REFERENCES ndb.constituentdatabases(databaseid) ON UPDATE CASCADE ON DELETE CASCADE",
                    "table": "ndb.datasetdatabases",
                    "referenced_table": "constituentdatabases",
                    "columns": [
                        "databaseid"
                    ],
                    "referenced_columns": [
                        "databaseid"
                    ]
                },
                {
                    "name": "datasetdatabases_pkey",
                    "type": "PRIMARY KEY",
                    "def": "PRIMARY KEY (datasetid, databaseid)",
                    "table": "ndb.datasetdatabases",
                    "referenced_table": "",
                    "columns": [
                        "datasetid",
                        "databaseid"
                    ]
                },
                {
                    "name": "fk_datasetdatabases_datasets",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (datasetid) REFERENCES ndb.datasets(datasetid) ON UPDATE CASCADE ON DELETE CASCADE",
                    "table": "ndb.datasetdatabases",
                    "referenced_table": "datasets",
                    "columns": [
                        "datasetid"
                    ],
                    "referenced_columns": [
                        "datasetid"
                    ]
                }
            ],
            "triggers": [
                {
                    "name": "tr_sites_modifydate",
                    "def": "CREATE TRIGGER tr_sites_modifydate BEFORE INSERT OR UPDATE ON ndb.datasetdatabases FOR EACH ROW EXECUTE FUNCTION ndb.update_recdatemodified()"
                }
            ]
        },
        {
            "name": "ndb.datasetdoi",
            "type": "BASE TABLE",
            "columns": [
                {
                    "name": "datasetid",
                    "type": "integer",
                    "nullable": false
                },
                {
                    "name": "doi",
                    "type": "varchar(50)",
                    "nullable": false
                },
                {
                    "name": "recdatecreated",
                    "type": "timestamp(0) without time zone",
                    "nullable": false,
                    "default": "timezone('UTC'::text, now())"
                },
                {
                    "name": "recdatemodified",
                    "type": "timestamp(0) without time zone",
                    "nullable": false
                },
                {
                    "name": "published",
                    "type": "boolean",
                    "nullable": false,
                    "default": "true"
                }
            ],
            "indexes": [
                {
                    "name": "datasetdoi_pkey",
                    "def": "CREATE UNIQUE INDEX datasetdoi_pkey ON ndb.datasetdoi USING btree (datasetid, doi)",
                    "table": "ndb.datasetdoi",
                    "columns": [
                        "datasetid",
                        "doi"
                    ]
                }
            ],
            "constraints": [
                {
                    "name": "datasetdoi_pkey",
                    "type": "PRIMARY KEY",
                    "def": "PRIMARY KEY (datasetid, doi)",
                    "table": "ndb.datasetdoi",
                    "referenced_table": "",
                    "columns": [
                        "datasetid",
                        "doi"
                    ]
                }
            ],
            "triggers": [
                {
                    "name": "tr_sites_modifydate",
                    "def": "CREATE TRIGGER tr_sites_modifydate BEFORE INSERT OR UPDATE ON ndb.datasetdoi FOR EACH ROW EXECUTE FUNCTION ndb.update_recdatemodified()"
                }
            ]
        },
        {
            "name": "ndb.datasets",
            "type": "BASE TABLE",
            "comment": "This table stores the data for Datasets. A Dataset is the set of samples for a particular data type from a Collection Unit. A Collection Unit may have multiple Datasets for different data types, for example one dataset for pollen and another for plant macrofossils. Every Sample is assigned to a Dataset, and every Dataset is assigned to a Collection Unit. Samples from different Collection Units cannot be assigned to the same Dataset (although they may be assigned to Aggregate Datasets).",
            "columns": [
                {
                    "name": "datasetid",
                    "type": "integer",
                    "nullable": false,
                    "default": "nextval('ndb.seq_datasets_datasetid'::regclass)",
                    "comment": "An arbitrary Dataset identification number."
                },
                {
                    "name": "collectionunitid",
                    "type": "integer",
                    "nullable": false,
                    "comment": "Collection Unit identification number. Field links to the CollectionUnits table."
                },
                {
                    "name": "datasettypeid",
                    "type": "integer",
                    "nullable": false,
                    "comment": "Dataset Type identification number. Field links to the DatasetTypes lookup table."
                },
                {
                    "name": "datasetname",
                    "type": "varchar(80)",
                    "nullable": true,
                    "comment": "Optional name for the Dataset."
                },
                {
                    "name": "notes",
                    "type": "text",
                    "nullable": true,
                    "comment": "Free form notes or comments about the Dataset."
                },
                {
                    "name": "recdatecreated",
                    "type": "timestamp(0) without time zone",
                    "nullable": false,
                    "default": "timezone('UTC'::text, now())"
                },
                {
                    "name": "recdatemodified",
                    "type": "timestamp(0) without time zone",
                    "nullable": false
                },
                {
                    "name": "embargoid",
                    "type": "integer",
                    "nullable": true
                }
            ],
            "indexes": [
                {
                    "name": "datasets_pkey",
                    "def": "CREATE UNIQUE INDEX datasets_pkey ON ndb.datasets USING btree (datasetid)",
                    "table": "ndb.datasets",
                    "columns": [
                        "datasetid"
                    ]
                },
                {
                    "name": "ix_collectionunitid_datasets",
                    "def": "CREATE INDEX ix_collectionunitid_datasets ON ndb.datasets USING btree (collectionunitid) WITH (fillfactor='10')",
                    "table": "ndb.datasets",
                    "columns": [
                        "collectionunitid"
                    ]
                },
                {
                    "name": "ix_datasettypeid_datasets",
                    "def": "CREATE INDEX ix_datasettypeid_datasets ON ndb.datasets USING btree (datasettypeid) WITH (fillfactor='10')",
                    "table": "ndb.datasets",
                    "columns": [
                        "datasettypeid"
                    ]
                }
            ],
            "constraints": [
                {
                    "name": "fk_datasets_collectionunits",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (collectionunitid) REFERENCES ndb.collectionunits(collectionunitid) ON UPDATE CASCADE ON DELETE CASCADE",
                    "table": "ndb.datasets",
                    "referenced_table": "collectionunits",
                    "columns": [
                        "collectionunitid"
                    ],
                    "referenced_columns": [
                        "collectionunitid"
                    ]
                },
                {
                    "name": "datasets_pkey",
                    "type": "PRIMARY KEY",
                    "def": "PRIMARY KEY (datasetid)",
                    "table": "ndb.datasets",
                    "referenced_table": "",
                    "columns": [
                        "datasetid"
                    ]
                },
                {
                    "name": "fk_datasets_datasettypes",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (datasettypeid) REFERENCES ndb.datasettypes(datasettypeid) ON UPDATE CASCADE ON DELETE CASCADE",
                    "table": "ndb.datasets",
                    "referenced_table": "datasettypes",
                    "columns": [
                        "datasettypeid"
                    ],
                    "referenced_columns": [
                        "datasettypeid"
                    ]
                },
                {
                    "name": "fk_datasets_embargo",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (embargoid) REFERENCES ndb.embargo(embargoid) ON UPDATE CASCADE ON DELETE CASCADE",
                    "table": "ndb.datasets",
                    "referenced_table": "embargo",
                    "columns": [
                        "embargoid"
                    ],
                    "referenced_columns": [
                        "embargoid"
                    ]
                }
            ],
            "triggers": [
                {
                    "name": "tr_sites_modifydate",
                    "def": "CREATE TRIGGER tr_sites_modifydate BEFORE INSERT OR UPDATE ON ndb.datasets FOR EACH ROW EXECUTE FUNCTION ndb.update_recdatemodified()"
                }
            ]
        },
        {
            "name": "ndb.datasettypes",
            "type": "BASE TABLE",
            "comment": "Lookup table for Dataset Types. Table is referenced by the Datasets table.",
            "columns": [
                {
                    "name": "datasettypeid",
                    "type": "integer",
                    "nullable": false,
                    "default": "nextval('ndb.seq_datasettypes_datasettypeid'::regclass)",
                    "comment": "An arbitrary Dataset Type identification number."
                },
                {
                    "name": "datasettype",
                    "type": "varchar(64)",
                    "nullable": false,
                    "comment": "The Dataset type, including the following:\ngeochronologic\nloss-on-ignition\npollen\nplant macrofossils\nvertebrate fauna\nmollusks"
                },
                {
                    "name": "recdatecreated",
                    "type": "timestamp(0) without time zone",
                    "nullable": false,
                    "default": "timezone('UTC'::text, now())"
                },
                {
                    "name": "recdatemodified",
                    "type": "timestamp(0) without time zone",
                    "nullable": false
                }
            ],
            "indexes": [
                {
                    "name": "datasettypes_pkey",
                    "def": "CREATE UNIQUE INDEX datasettypes_pkey ON ndb.datasettypes USING btree (datasettypeid)",
                    "table": "ndb.datasettypes",
                    "columns": [
                        "datasettypeid"
                    ]
                }
            ],
            "constraints": [
                {
                    "name": "datasettypes_pkey",
                    "type": "PRIMARY KEY",
                    "def": "PRIMARY KEY (datasettypeid)",
                    "table": "ndb.datasettypes",
                    "referenced_table": "",
                    "columns": [
                        "datasettypeid"
                    ]
                }
            ],
            "triggers": [
                {
                    "name": "tr_sites_modifydate",
                    "def": "CREATE TRIGGER tr_sites_modifydate BEFORE INSERT OR UPDATE ON ndb.datasettypes FOR EACH ROW EXECUTE FUNCTION ndb.update_recdatemodified()"
                }
            ]
        },
        {
            "name": "ndb.sites",
            "type": "BASE TABLE",
            "comment": "The Sites table stores information about sites or localities, including name, geographic coordinates, and description. Sites generally have an areal extent and can be circumscribed by a latitude-longitude box. However, site data ingested from legacy databases have included only point locations. The lat-long box can be used either to circumscribe the aerial extent of a site or to provide purposeful imprecision to the site location. Site location may be imprecise because the original description was vague, e.g. «a gravel bar 5 miles east of town», or because the investigators, land owner, or land management agency may not want the exact location made public, perhaps to prevent looting and vandalism. In the first case, the lat-long box can be made sufficiently large to encompass the true location and in the second case to prevent exact location.",
            "columns": [
                {
                    "name": "siteid",
                    "type": "integer",
                    "nullable": false,
                    "default": "nextval('ndb.seq_sites_siteid'::regclass)",
                    "comment": "An arbitrary Site identification number."
                },
                {
                    "name": "sitename",
                    "type": "varchar(128)",
                    "nullable": true,
                    "comment": "Name of the site. Alternative names, including archaeological site numbers, are placed in square brackets, for example:\nNew Paris #4 [Lloyd's Rock Hole]\nModoc Rock Shelter [11RA501]\nA search of the SiteName field for any of the alternative names or for the archaeological site number will find the site. Some archaeological sites are known only by their site number.\nModifiers to site names are placed in parentheses. Authors are added for generic sites names, especially for surface samples, that are duplicated in the database, for example:\nSite 1 (Heusser 1978)\nSite 1 (Delcourt et al. 1983)\nSite 1 (Elliot-Fisk et al. 1982)\nSite 1 (Whitehead and Jackson 1990)\nFor actual site names duplicated in the database, the name is followed by the 2-letter country code and state or province, for example:\nSilver Lake (US:Minnesota)\nSilver Lake (CA:Nova Scotia)\nSilver Lake (US:Ohio)\nSilver Lake (US:Pennsylvania)\n"
                },
                {
                    "name": "longitudeeast",
                    "type": "double precision",
                    "nullable": true,
                    "comment": "East bounding longitude for a site."
                },
                {
                    "name": "latitudenorth",
                    "type": "double precision",
                    "nullable": true,
                    "comment": "North bounding latitude for a site."
                },
                {
                    "name": "longitudewest",
                    "type": "double precision",
                    "nullable": true,
                    "comment": "West bounding longitude for a site."
                },
                {
                    "name": "latitudesouth",
                    "type": "double precision",
                    "nullable": true,
                    "comment": "South bounding latitude for a site."
                },
                {
                    "name": "altitude",
                    "type": "double precision",
                    "nullable": true,
                    "comment": "Altitude of a site in meters."
                },
                {
                    "name": "area",
                    "type": "double precision",
                    "nullable": true,
                    "comment": "Area of a site in hectares."
                },
                {
                    "name": "sitedescription",
                    "type": "text",
                    "nullable": true,
                    "comment": "Free form description of a site, including such information as physiography and vegetation around the site."
                },
                {
                    "name": "notes",
                    "type": "text",
                    "nullable": true,
                    "comment": "Free form notes or comments about the site."
                },
                {
                    "name": "recdatecreated",
                    "type": "timestamp(0) without time zone",
                    "nullable": false,
                    "default": "timezone('UTC'::text, now())"
                },
                {
                    "name": "recdatemodified",
                    "type": "timestamp(0) without time zone",
                    "nullable": false
                },
                {
                    "name": "geog",
                    "type": "geography",
                    "nullable": true
                }
            ],
            "indexes": [
                {
                    "name": "sites_pkey",
                    "def": "CREATE UNIQUE INDEX sites_pkey ON ndb.sites USING btree (siteid)",
                    "table": "ndb.sites",
                    "columns": [
                        "siteid"
                    ]
                },
                {
                    "name": "ix_siteid_sites",
                    "def": "CREATE INDEX ix_siteid_sites ON ndb.sites USING btree (siteid) WITH (fillfactor='10')",
                    "table": "ndb.sites",
                    "columns": [
                        "siteid"
                    ]
                },
                {
                    "name": "sitegeog_gix",
                    "def": "CREATE INDEX sitegeog_gix ON ndb.sites USING gist (geog)",
                    "table": "ndb.sites",
                    "columns": [
                        "geog"
                    ]
                },
                {
                    "name": "sitenames_idx",
                    "def": "CREATE INDEX sitenames_idx ON ndb.sites USING gin (sitename gin_trgm_ops)",
                    "table": "ndb.sites",
                    "columns": [
                        "sitename"
                    ]
                }
            ],
            "constraints": [
                {
                    "name": "sites_pkey",
                    "type": "PRIMARY KEY",
                    "def": "PRIMARY KEY (siteid)",
                    "table": "ndb.sites",
                    "referenced_table": "",
                    "columns": [
                        "siteid"
                    ]
                }
            ],
            "triggers": [
                {
                    "name": "tr_sites_modifydate",
                    "def": "CREATE TRIGGER tr_sites_modifydate BEFORE INSERT OR UPDATE ON ndb.sites FOR EACH ROW EXECUTE FUNCTION ndb.update_recdatemodified()"
                },
                {
                    "name": "updategeopol",
                    "def": "CREATE TRIGGER updategeopol AFTER INSERT OR DELETE ON ndb.sites FOR EACH STATEMENT EXECUTE FUNCTION ap.updategpsites()"
                },
                {
                    "name": "updatelocations",
                    "def": "CREATE TRIGGER updatelocations AFTER INSERT OR UPDATE ON ndb.sites FOR EACH ROW EXECUTE FUNCTION ti.site_bounding()"
                }
            ]
        },
        {
            "name": "ndb.sitegeopolitical",
            "type": "BASE TABLE",
            "comment": "This table lists the GeoPolitical units in which sites occur.",
            "columns": [
                {
                    "name": "sitegeopoliticalid",
                    "type": "integer",
                    "nullable": false,
                    "default": "nextval('ndb.seq_sitegeopolitical_sitegeopoliticalid'::regclass)",
                    "comment": "An arbitrary Site GeoPolitical identification number."
                },
                {
                    "name": "siteid",
                    "type": "integer",
                    "nullable": false,
                    "comment": "Site identification number. Field links to the Sites table."
                },
                {
                    "name": "geopoliticalid",
                    "type": "integer",
                    "nullable": false,
                    "comment": "GeoPolitical identification number. Field links to the GeoPoliticalUnits lookup table."
                },
                {
                    "name": "recdatecreated",
                    "type": "timestamp(0) without time zone",
                    "nullable": false,
                    "default": "timezone('UTC'::text, now())"
                },
                {
                    "name": "recdatemodified",
                    "type": "timestamp(0) without time zone",
                    "nullable": false
                },
                {
                    "name": "objectid",
                    "type": "integer",
                    "nullable": true
                }
            ],
            "indexes": [
                {
                    "name": "sitegeopolitical_pkey",
                    "def": "CREATE UNIQUE INDEX sitegeopolitical_pkey ON ndb.sitegeopolitical USING btree (sitegeopoliticalid)",
                    "table": "ndb.sitegeopolitical",
                    "columns": [
                        "sitegeopoliticalid"
                    ]
                },
                {
                    "name": "ix_geopoliticalid_sitegeopolitical",
                    "def": "CREATE INDEX ix_geopoliticalid_sitegeopolitical ON ndb.sitegeopolitical USING btree (geopoliticalid) WITH (fillfactor='10')",
                    "table": "ndb.sitegeopolitical",
                    "columns": [
                        "geopoliticalid"
                    ]
                },
                {
                    "name": "ix_siteid_sitegeopolitical",
                    "def": "CREATE INDEX ix_siteid_sitegeopolitical ON ndb.sitegeopolitical USING btree (siteid) WITH (fillfactor='10')",
                    "table": "ndb.sitegeopolitical",
                    "columns": [
                        "siteid"
                    ]
                }
            ],
            "constraints": [
                {
                    "name": "fk_sitegeopolitical_geopoliticalunits",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (geopoliticalid) REFERENCES ndb.geopoliticalunits(geopoliticalid)",
                    "table": "ndb.sitegeopolitical",
                    "referenced_table": "geopoliticalunits",
                    "columns": [
                        "geopoliticalid"
                    ],
                    "referenced_columns": [
                        "geopoliticalid"
                    ]
                },
                {
                    "name": "sitegeopolitical_pkey",
                    "type": "PRIMARY KEY",
                    "def": "PRIMARY KEY (sitegeopoliticalid)",
                    "table": "ndb.sitegeopolitical",
                    "referenced_table": "",
                    "columns": [
                        "sitegeopoliticalid"
                    ]
                },
                {
                    "name": "fk_sitegeopolitical_sites",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (siteid) REFERENCES ndb.sites(siteid) ON UPDATE CASCADE ON DELETE CASCADE",
                    "table": "ndb.sitegeopolitical",
                    "referenced_table": "sites",
                    "columns": [
                        "siteid"
                    ],
                    "referenced_columns": [
                        "siteid"
                    ]
                },
                {
                    "name": "fk_objectid",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (objectid) REFERENCES ap.gadm(objectid)",
                    "table": "ndb.sitegeopolitical",
                    "referenced_table": "gadm",
                    "columns": [
                        "objectid"
                    ],
                    "referenced_columns": [
                        "objectid"
                    ]
                }
            ],
            "triggers": [
                {
                    "name": "tr_sites_modifydate",
                    "def": "CREATE TRIGGER tr_sites_modifydate BEFORE INSERT OR UPDATE ON ndb.sitegeopolitical FOR EACH ROW EXECUTE FUNCTION ndb.update_recdatemodified()"
                }
            ]
        },
        {
            "name": "doi.doimeta",
            "type": "BASE TABLE",
            "columns": [
                {
                    "name": "doi",
                    "type": "varchar",
                    "nullable": false
                },
                {
                    "name": "meta",
                    "type": "jsonb",
                    "nullable": true
                },
                {
                    "name": "datasetid",
                    "type": "integer",
                    "nullable": true
                },
                {
                    "name": "recdatecreated",
                    "type": "timestamp with time zone",
                    "nullable": false,
                    "default": "now()"
                },
                {
                    "name": "recdatemodified",
                    "type": "timestamp with time zone",
                    "nullable": false,
                    "default": "now()"
                }
            ],
            "indexes": [
                {
                    "name": "doimeta_pkey",
                    "def": "CREATE UNIQUE INDEX doimeta_pkey ON doi.doimeta USING btree (doi)",
                    "table": "doi.doimeta",
                    "columns": [
                        "doi"
                    ]
                },
                {
                    "name": "doimeta_doi_idx",
                    "def": "CREATE UNIQUE INDEX doimeta_doi_idx ON doi.doimeta USING btree (doi, datasetid)",
                    "table": "doi.doimeta",
                    "columns": [
                        "doi",
                        "datasetid"
                    ]
                }
            ],
            "constraints": [
                {
                    "name": "doimeta_pkey",
                    "type": "PRIMARY KEY",
                    "def": "PRIMARY KEY (doi)",
                    "table": "doi.doimeta",
                    "referenced_table": "",
                    "columns": [
                        "doi"
                    ]
                }
            ],
            "triggers": [
                {
                    "name": "update_modified",
                    "def": "CREATE TRIGGER update_modified AFTER UPDATE ON doi.doimeta FOR EACH ROW EXECUTE FUNCTION ndb.update_recdatemodified()"
                }
            ]
        },
        {
            "name": "doi.frozen",
            "type": "BASE TABLE",
            "columns": [
                {
                    "name": "datasetid",
                    "type": "integer",
                    "nullable": true
                },
                {
                    "name": "download",
                    "type": "jsonb",
                    "nullable": false
                },
                {
                    "name": "recdatecreated",
                    "type": "timestamp(6) without time zone",
                    "nullable": true,
                    "default": "now()"
                },
                {
                    "name": "recmodified",
                    "type": "timestamp(6) without time zone",
                    "nullable": true,
                    "default": "now()"
                }
            ],
            "indexes": [
                {
                    "name": "frozen_datasetid_idx",
                    "def": "CREATE INDEX frozen_datasetid_idx ON doi.frozen USING btree (datasetid)",
                    "table": "doi.frozen",
                    "columns": [
                        "datasetid"
                    ]
                }
            ]
        },
        {
            "name": "ndb.accumulationrates",
            "type": "BASE TABLE",
            "columns": [
                {
                    "name": "analysisunitid",
                    "type": "integer",
                    "nullable": false
                },
                {
                    "name": "chronologyid",
                    "type": "integer",
                    "nullable": false
                },
                {
                    "name": "accumulationrate",
                    "type": "double precision",
                    "nullable": false
                },
                {
                    "name": "variableunitsid",
                    "type": "integer",
                    "nullable": false
                },
                {
                    "name": "recdatecreated",
                    "type": "timestamp(0) without time zone",
                    "nullable": false,
                    "default": "timezone('UTC'::text, now())"
                },
                {
                    "name": "recdatemodified",
                    "type": "timestamp(0) without time zone",
                    "nullable": false
                }
            ],
            "indexes": [
                {
                    "name": "accumulationrates_pkey",
                    "def": "CREATE UNIQUE INDEX accumulationrates_pkey ON ndb.accumulationrates USING btree (analysisunitid, chronologyid)",
                    "table": "ndb.accumulationrates",
                    "columns": [
                        "analysisunitid",
                        "chronologyid"
                    ]
                }
            ],
            "constraints": [
                {
                    "name": "accumulationrates_pkey",
                    "type": "PRIMARY KEY",
                    "def": "PRIMARY KEY (analysisunitid, chronologyid)",
                    "table": "ndb.accumulationrates",
                    "referenced_table": "",
                    "columns": [
                        "analysisunitid",
                        "chronologyid"
                    ]
                },
                {
                    "name": "fk_accumulationrates_analysisunits",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (analysisunitid) REFERENCES ndb.analysisunits(analysisunitid) ON UPDATE CASCADE ON DELETE CASCADE",
                    "table": "ndb.accumulationrates",
                    "referenced_table": "analysisunits",
                    "columns": [
                        "analysisunitid"
                    ],
                    "referenced_columns": [
                        "analysisunitid"
                    ]
                },
                {
                    "name": "fk_accumulationrates_chronologies",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (chronologyid) REFERENCES ndb.chronologies(chronologyid)",
                    "table": "ndb.accumulationrates",
                    "referenced_table": "chronologies",
                    "columns": [
                        "chronologyid"
                    ],
                    "referenced_columns": [
                        "chronologyid"
                    ]
                },
                {
                    "name": "fk_accumulationrates_variableunits",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (variableunitsid) REFERENCES ndb.variableunits(variableunitsid) ON UPDATE CASCADE ON DELETE CASCADE",
                    "table": "ndb.accumulationrates",
                    "referenced_table": "variableunits",
                    "columns": [
                        "variableunitsid"
                    ],
                    "referenced_columns": [
                        "variableunitsid"
                    ]
                }
            ],
            "triggers": [
                {
                    "name": "tr_sites_modifydate",
                    "def": "CREATE TRIGGER tr_sites_modifydate BEFORE INSERT OR UPDATE ON ndb.accumulationrates FOR EACH ROW EXECUTE FUNCTION ndb.update_recdatemodified()"
                }
            ]
        },
        {
            "name": "ndb.aggregatechronologies",
            "type": "BASE TABLE",
            "comment": "This table stores metadata for Aggregate Chronologies. An Aggregate Chronology refers to an explicit chronology assigned to a sample Aggregate. The individual Aggregate Samples have ages assigned in the AggregateSampleAges table. An Aggregate Chronology would be used, for example, for a set of packrat middens assigned to an AggregateDataset. The Aggregate Chronology is analogous to the Chronology assigned to samples from a single Collection Unit.\nAn Aggregate may have more than one Aggregate Chronology, for example one in radiocarbon years and another in calibrated radiocarbon years. One Aggregate Chronology per Age Type may be designated the default, which is the Aggregate Chronology currently preferred by the database stewards.",
            "columns": [
                {
                    "name": "aggregatechronid",
                    "type": "integer",
                    "nullable": false,
                    "default": "nextval('ndb.seq_aggregatechronologies_aggregatechronid'::regclass)",
                    "comment": "PK: An arbitrary Aggregate Chronology identification number"
                },
                {
                    "name": "aggregatedatasetid",
                    "type": "integer",
                    "nullable": false,
                    "comment": "Dataset to which the Aggregate Chronology applies. Field links to the AggregateDatasets table."
                },
                {
                    "name": "agetypeid",
                    "type": "integer",
                    "nullable": false,
                    "comment": "Age type or units. Field links to the AgeTypes table."
                },
                {
                    "name": "isdefault",
                    "type": "boolean",
                    "nullable": false,
                    "comment": "Indicates whether the Aggregate Chronology is a default or not. Default status is determined by a Neotoma data steward. Aggregate Datasets may have more than one default Aggregate Chronology, but may have only one default Aggregate Chronology per Age Type."
                },
                {
                    "name": "chronologyname",
                    "type": "varchar(80)",
                    "nullable": true,
                    "comment": "Optional name for the Chronology."
                },
                {
                    "name": "ageboundyounger",
                    "type": "integer",
                    "nullable": true,
                    "comment": "The younger reliable age bound for the Aggregate Chronology. Younger ages may be assigned to samples, but are not regarded as reliable. If the entire Chronology is considered reliable, AgeBoundYounger is assigned the youngest sample age rounded down to the nearest 10. Thus, for 72 BP, AgeBoundYounger = 70 BP; for -45 BP, AgeBoundYounger = -50 BP."
                },
                {
                    "name": "ageboundolder",
                    "type": "integer",
                    "nullable": true,
                    "comment": "The older reliable age bound for the Aggregate Chronology. Ages older than AgeOlderBound may be assigned to samples, but are not regarded as reliable. This situation is particularly true for ages extrapolated beyond the oldest Chron Control. If the entire Chronology is considered reliable, AgeBoundOlder is assigned the oldest sample age rounded up to the nearest 10. Thus, for 12564 BP, AgeBoundOlder is 12570."
                },
                {
                    "name": "notes",
                    "type": "text",
                    "nullable": true,
                    "comment": "Free form notes or comments about the Aggregate Chronology."
                },
                {
                    "name": "recdatecreated",
                    "type": "timestamp(0) without time zone",
                    "nullable": false,
                    "default": "timezone('UTC'::text, now())"
                },
                {
                    "name": "recdatemodified",
                    "type": "timestamp(0) without time zone",
                    "nullable": false
                }
            ],
            "indexes": [
                {
                    "name": "aggregatechronologies_pkey",
                    "def": "CREATE UNIQUE INDEX aggregatechronologies_pkey ON ndb.aggregatechronologies USING btree (aggregatechronid)",
                    "table": "ndb.aggregatechronologies",
                    "columns": [
                        "aggregatechronid"
                    ]
                }
            ],
            "constraints": [
                {
                    "name": "fk_aggregatechronologies_agetypes",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (agetypeid) REFERENCES ndb.agetypes(agetypeid) ON UPDATE CASCADE ON DELETE CASCADE",
                    "table": "ndb.aggregatechronologies",
                    "referenced_table": "agetypes",
                    "columns": [
                        "agetypeid"
                    ],
                    "referenced_columns": [
                        "agetypeid"
                    ]
                },
                {
                    "name": "aggregatechronologies_pkey",
                    "type": "PRIMARY KEY",
                    "def": "PRIMARY KEY (aggregatechronid)",
                    "table": "ndb.aggregatechronologies",
                    "referenced_table": "",
                    "columns": [
                        "aggregatechronid"
                    ]
                },
                {
                    "name": "fk_aggregatechronologies_aggregatedatasets",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (aggregatedatasetid) REFERENCES ndb.aggregatedatasets(aggregatedatasetid) ON UPDATE CASCADE ON DELETE CASCADE",
                    "table": "ndb.aggregatechronologies",
                    "referenced_table": "aggregatedatasets",
                    "columns": [
                        "aggregatedatasetid"
                    ],
                    "referenced_columns": [
                        "aggregatedatasetid"
                    ]
                }
            ],
            "triggers": [
                {
                    "name": "tr_sites_modifydate",
                    "def": "CREATE TRIGGER tr_sites_modifydate BEFORE INSERT OR UPDATE ON ndb.aggregatechronologies FOR EACH ROW EXECUTE FUNCTION ndb.update_recdatemodified()"
                }
            ]
        },
        {
            "name": "ndb.aggregatedatasets",
            "type": "BASE TABLE",
            "comment": "Aggregate Datasets are aggregates of samples of a particular data type. Some examples:  \n* Plant macrofossil samples from a group of packrat middens collected from a particular valley, mountain range, or other similarly defined geographic area. Each midden is from a different Site or Collection Unit, but they are grouped into time series for that area and are published as a single dataset.\n* Samples collected from 32 cutbanks along several km of Roberts Creek, northeast Iowa. Each sample is from a different site, but they form a time series from 0-12,510 14C yr BP, and pollen, plant macrofossils, and beetles were published and graphed as if from a single site.\n* A set of pollen surface samples from a particular region or study that were published and analyzed as a single dataset and submitted to the database as a single dataset.\nThe examples above are datasets predefined in the database. New aggregate datasets could be assembled for particular studies, for example all the pollen samples for a given time slice for a given geographic region.",
            "columns": [
                {
                    "name": "aggregatedatasetid",
                    "type": "integer",
                    "nullable": false,
                    "default": "nextval('ndb.seq_aggregatedatasets_aggregatedatasetid'::regclass)",
                    "comment": "An arbitrary Aggregate Dataset identification number."
                },
                {
                    "name": "aggregatedatasetname",
                    "type": "varchar(255)",
                    "nullable": false,
                    "comment": "Name of Aggregate Dataset."
                },
                {
                    "name": "aggregateordertypeid",
                    "type": "integer",
                    "nullable": false,
                    "comment": "Aggregate Order Type identification number. Field links to the AggregateOrderTypes lookup table."
                },
                {
                    "name": "notes",
                    "type": "text",
                    "nullable": true,
                    "comment": "Free form notes about the Aggregate Order Type."
                },
                {
                    "name": "recdatecreated",
                    "type": "timestamp(0) without time zone",
                    "nullable": false,
                    "default": "timezone('UTC'::text, now())"
                },
                {
                    "name": "recdatemodified",
                    "type": "timestamp(0) without time zone",
                    "nullable": false
                }
            ],
            "indexes": [
                {
                    "name": "aggregatedatasets_pkey",
                    "def": "CREATE UNIQUE INDEX aggregatedatasets_pkey ON ndb.aggregatedatasets USING btree (aggregatedatasetid)",
                    "table": "ndb.aggregatedatasets",
                    "columns": [
                        "aggregatedatasetid"
                    ]
                }
            ],
            "constraints": [
                {
                    "name": "aggregatedatasets_pkey",
                    "type": "PRIMARY KEY",
                    "def": "PRIMARY KEY (aggregatedatasetid)",
                    "table": "ndb.aggregatedatasets",
                    "referenced_table": "",
                    "columns": [
                        "aggregatedatasetid"
                    ]
                },
                {
                    "name": "fk_aggregatedatasets_aggregateordertypes",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (aggregateordertypeid) REFERENCES ndb.aggregateordertypes(aggregateordertypeid) ON UPDATE CASCADE ON DELETE CASCADE",
                    "table": "ndb.aggregatedatasets",
                    "referenced_table": "aggregateordertypes",
                    "columns": [
                        "aggregateordertypeid"
                    ],
                    "referenced_columns": [
                        "aggregateordertypeid"
                    ]
                }
            ],
            "triggers": [
                {
                    "name": "tr_sites_modifydate",
                    "def": "CREATE TRIGGER tr_sites_modifydate BEFORE INSERT OR UPDATE ON ndb.aggregatedatasets FOR EACH ROW EXECUTE FUNCTION ndb.update_recdatemodified()"
                }
            ]
        },
        {
            "name": "ndb.aggregateordertypes",
            "type": "BASE TABLE",
            "comment": "Lookup table for Aggregate Order Types. Table is referenced by the AggregateDatasets table.",
            "columns": [
                {
                    "name": "aggregateordertypeid",
                    "type": "integer",
                    "nullable": false,
                    "default": "nextval('ndb.seq_aggregateordertypes_aggregateordertypeid'::regclass)",
                    "comment": "An arbitrary Aggregate Order Type identification number."
                },
                {
                    "name": "aggregateordertype",
                    "type": "varchar(64)",
                    "nullable": false,
                    "comment": "The Aggregate Order Type."
                },
                {
                    "name": "notes",
                    "type": "text",
                    "nullable": true,
                    "comment": "Free form notes or comments about the Aggregate Order Type."
                },
                {
                    "name": "recdatecreated",
                    "type": "timestamp(0) without time zone",
                    "nullable": false,
                    "default": "timezone('UTC'::text, now())"
                },
                {
                    "name": "recdatemodified",
                    "type": "timestamp(0) without time zone",
                    "nullable": false
                }
            ],
            "indexes": [
                {
                    "name": "aggregateordertypes_pkey",
                    "def": "CREATE UNIQUE INDEX aggregateordertypes_pkey ON ndb.aggregateordertypes USING btree (aggregateordertypeid)",
                    "table": "ndb.aggregateordertypes",
                    "columns": [
                        "aggregateordertypeid"
                    ]
                }
            ],
            "constraints": [
                {
                    "name": "aggregateordertypes_pkey",
                    "type": "PRIMARY KEY",
                    "def": "PRIMARY KEY (aggregateordertypeid)",
                    "table": "ndb.aggregateordertypes",
                    "referenced_table": "",
                    "columns": [
                        "aggregateordertypeid"
                    ]
                }
            ],
            "triggers": [
                {
                    "name": "tr_sites_modifydate",
                    "def": "CREATE TRIGGER tr_sites_modifydate BEFORE INSERT OR UPDATE ON ndb.aggregateordertypes FOR EACH ROW EXECUTE FUNCTION ndb.update_recdatemodified()"
                }
            ]
        },
        {
            "name": "ndb.aggregatesampleages",
            "type": "BASE TABLE",
            "comment": "This table stores the links to the ages of samples in an Aggregate Dataset. The table is necessary because samples may be from Collection Units with multiple chronologies, and this table stores the links to the sample ages desired for the Aggregate Dataset.",
            "columns": [
                {
                    "name": "aggregatedatasetid",
                    "type": "integer",
                    "nullable": false,
                    "comment": "Aggregate Dataset identification number. Field links to the AggregateDatasets table."
                },
                {
                    "name": "aggregatechronid",
                    "type": "integer",
                    "nullable": false,
                    "comment": "Aggregate Chronology identification number Field links to the AggregateChronologies table."
                },
                {
                    "name": "sampleageid",
                    "type": "integer",
                    "nullable": false,
                    "comment": "Sample Age ID number. Field links to the SampleAges table."
                },
                {
                    "name": "recdatecreated",
                    "type": "timestamp(0) without time zone",
                    "nullable": false,
                    "default": "timezone('UTC'::text, now())"
                },
                {
                    "name": "recdatemodified",
                    "type": "timestamp(0) without time zone",
                    "nullable": false
                }
            ],
            "indexes": [
                {
                    "name": "aggregatesampleages_pkey",
                    "def": "CREATE UNIQUE INDEX aggregatesampleages_pkey ON ndb.aggregatesampleages USING btree (aggregatedatasetid, aggregatechronid, sampleageid)",
                    "table": "ndb.aggregatesampleages",
                    "columns": [
                        "aggregatedatasetid",
                        "aggregatechronid",
                        "sampleageid"
                    ]
                }
            ],
            "constraints": [
                {
                    "name": "fk_aggregatesampleages_aggregatechronologies",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (aggregatechronid) REFERENCES ndb.aggregatechronologies(aggregatechronid)",
                    "table": "ndb.aggregatesampleages",
                    "referenced_table": "aggregatechronologies",
                    "columns": [
                        "aggregatechronid"
                    ],
                    "referenced_columns": [
                        "aggregatechronid"
                    ]
                },
                {
                    "name": "fk_aggregatesampleages_aggregatedatasets",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (aggregatedatasetid) REFERENCES ndb.aggregatedatasets(aggregatedatasetid) ON UPDATE CASCADE ON DELETE CASCADE",
                    "table": "ndb.aggregatesampleages",
                    "referenced_table": "aggregatedatasets",
                    "columns": [
                        "aggregatedatasetid"
                    ],
                    "referenced_columns": [
                        "aggregatedatasetid"
                    ]
                },
                {
                    "name": "aggregatesampleages_pkey",
                    "type": "PRIMARY KEY",
                    "def": "PRIMARY KEY (aggregatedatasetid, aggregatechronid, sampleageid)",
                    "table": "ndb.aggregatesampleages",
                    "referenced_table": "",
                    "columns": [
                        "aggregatedatasetid",
                        "aggregatechronid",
                        "sampleageid"
                    ]
                },
                {
                    "name": "fk_aggregatesampleages_sampleages",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (sampleageid) REFERENCES ndb.sampleages(sampleageid) ON UPDATE CASCADE ON DELETE CASCADE",
                    "table": "ndb.aggregatesampleages",
                    "referenced_table": "sampleages",
                    "columns": [
                        "sampleageid"
                    ],
                    "referenced_columns": [
                        "sampleageid"
                    ]
                }
            ],
            "triggers": [
                {
                    "name": "tr_sites_modifydate",
                    "def": "CREATE TRIGGER tr_sites_modifydate BEFORE INSERT OR UPDATE ON ndb.aggregatesampleages FOR EACH ROW EXECUTE FUNCTION ndb.update_recdatemodified()"
                }
            ]
        },
        {
            "name": "ndb.aggregatesamples",
            "type": "BASE TABLE",
            "comment": "This table stores the samples in Aggregate Datasets.",
            "columns": [
                {
                    "name": "aggregatedatasetid",
                    "type": "integer",
                    "nullable": false,
                    "comment": "An arbitrary Aggregate Dataset identification number. Field links to the AggregateDatasets table.\n"
                },
                {
                    "name": "sampleid",
                    "type": "integer",
                    "nullable": false,
                    "comment": "Sample ID number. Field links to the Samples table."
                },
                {
                    "name": "recdatecreated",
                    "type": "timestamp(0) without time zone",
                    "nullable": false,
                    "default": "timezone('UTC'::text, now())"
                },
                {
                    "name": "recdatemodified",
                    "type": "timestamp(0) without time zone",
                    "nullable": false
                }
            ],
            "indexes": [
                {
                    "name": "aggregatesamples_pkey",
                    "def": "CREATE UNIQUE INDEX aggregatesamples_pkey ON ndb.aggregatesamples USING btree (aggregatedatasetid, sampleid)",
                    "table": "ndb.aggregatesamples",
                    "columns": [
                        "aggregatedatasetid",
                        "sampleid"
                    ]
                }
            ],
            "constraints": [
                {
                    "name": "fk_aggregatesamples_aggregatedatasets",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (aggregatedatasetid) REFERENCES ndb.aggregatedatasets(aggregatedatasetid) ON UPDATE CASCADE ON DELETE CASCADE",
                    "table": "ndb.aggregatesamples",
                    "referenced_table": "aggregatedatasets",
                    "columns": [
                        "aggregatedatasetid"
                    ],
                    "referenced_columns": [
                        "aggregatedatasetid"
                    ]
                },
                {
                    "name": "aggregatesamples_pkey",
                    "type": "PRIMARY KEY",
                    "def": "PRIMARY KEY (aggregatedatasetid, sampleid)",
                    "table": "ndb.aggregatesamples",
                    "referenced_table": "",
                    "columns": [
                        "aggregatedatasetid",
                        "sampleid"
                    ]
                },
                {
                    "name": "fk_aggregatesamples_samples",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (sampleid) REFERENCES ndb.samples(sampleid) ON UPDATE CASCADE ON DELETE CASCADE",
                    "table": "ndb.aggregatesamples",
                    "referenced_table": "samples",
                    "columns": [
                        "sampleid"
                    ],
                    "referenced_columns": [
                        "sampleid"
                    ]
                }
            ],
            "triggers": [
                {
                    "name": "tr_sites_modifydate",
                    "def": "CREATE TRIGGER tr_sites_modifydate BEFORE INSERT OR UPDATE ON ndb.aggregatesamples FOR EACH ROW EXECUTE FUNCTION ndb.update_recdatemodified()"
                }
            ]
        },
        {
            "name": "ndb.analysisunitaltdepths",
            "type": "BASE TABLE",
            "columns": [
                {
                    "name": "analysisunitid",
                    "type": "integer",
                    "nullable": false
                },
                {
                    "name": "altdepthscaleid",
                    "type": "integer",
                    "nullable": false
                },
                {
                    "name": "altdepth",
                    "type": "double precision",
                    "nullable": false
                },
                {
                    "name": "recdatecreated",
                    "type": "timestamp(0) without time zone",
                    "nullable": false,
                    "default": "timezone('UTC'::text, now())"
                },
                {
                    "name": "recdatemodified",
                    "type": "timestamp(0) without time zone",
                    "nullable": false
                }
            ],
            "indexes": [
                {
                    "name": "analysisunitaltdepths_pkey",
                    "def": "CREATE UNIQUE INDEX analysisunitaltdepths_pkey ON ndb.analysisunitaltdepths USING btree (altdepthscaleid, analysisunitid)",
                    "table": "ndb.analysisunitaltdepths",
                    "columns": [
                        "altdepthscaleid",
                        "analysisunitid"
                    ]
                }
            ],
            "constraints": [
                {
                    "name": "analysisunitaltdepths_pkey",
                    "type": "PRIMARY KEY",
                    "def": "PRIMARY KEY (altdepthscaleid, analysisunitid)",
                    "table": "ndb.analysisunitaltdepths",
                    "referenced_table": "",
                    "columns": [
                        "altdepthscaleid",
                        "analysisunitid"
                    ]
                },
                {
                    "name": "fk_analysisunitaltdepths_analysisunitaltdepthscales",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (altdepthscaleid) REFERENCES ndb.analysisunitaltdepthscales(altdepthscaleid) ON UPDATE CASCADE ON DELETE CASCADE",
                    "table": "ndb.analysisunitaltdepths",
                    "referenced_table": "analysisunitaltdepthscales",
                    "columns": [
                        "altdepthscaleid"
                    ],
                    "referenced_columns": [
                        "altdepthscaleid"
                    ]
                },
                {
                    "name": "fk_analysisunitaltdepths_analysisunits",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (analysisunitid) REFERENCES ndb.analysisunits(analysisunitid) ON UPDATE CASCADE ON DELETE CASCADE",
                    "table": "ndb.analysisunitaltdepths",
                    "referenced_table": "analysisunits",
                    "columns": [
                        "analysisunitid"
                    ],
                    "referenced_columns": [
                        "analysisunitid"
                    ]
                }
            ],
            "triggers": [
                {
                    "name": "tr_sites_modifydate",
                    "def": "CREATE TRIGGER tr_sites_modifydate BEFORE INSERT OR UPDATE ON ndb.analysisunitaltdepths FOR EACH ROW EXECUTE FUNCTION ndb.update_recdatemodified()"
                }
            ]
        },
        {
            "name": "ndb.analysisunitaltdepthscales",
            "type": "BASE TABLE",
            "columns": [
                {
                    "name": "altdepthscaleid",
                    "type": "integer",
                    "nullable": false,
                    "default": "nextval('ndb.seq_analysisunitaltdepthscales_altdepthscaleid'::regclass)"
                },
                {
                    "name": "altdepthid",
                    "type": "integer",
                    "nullable": false
                },
                {
                    "name": "altdepthname",
                    "type": "varchar(80)",
                    "nullable": false
                },
                {
                    "name": "variableunitsid",
                    "type": "integer",
                    "nullable": false
                },
                {
                    "name": "notes",
                    "type": "text",
                    "nullable": true
                },
                {
                    "name": "recdatecreated",
                    "type": "timestamp(0) without time zone",
                    "nullable": false,
                    "default": "timezone('UTC'::text, now())"
                },
                {
                    "name": "recdatemodified",
                    "type": "timestamp(0) without time zone",
                    "nullable": false
                }
            ],
            "indexes": [
                {
                    "name": "analysisunitaltdepthscales_pkey",
                    "def": "CREATE UNIQUE INDEX analysisunitaltdepthscales_pkey ON ndb.analysisunitaltdepthscales USING btree (altdepthscaleid)",
                    "table": "ndb.analysisunitaltdepthscales",
                    "columns": [
                        "altdepthscaleid"
                    ]
                }
            ],
            "constraints": [
                {
                    "name": "analysisunitaltdepthscales_pkey",
                    "type": "PRIMARY KEY",
                    "def": "PRIMARY KEY (altdepthscaleid)",
                    "table": "ndb.analysisunitaltdepthscales",
                    "referenced_table": "",
                    "columns": [
                        "altdepthscaleid"
                    ]
                },
                {
                    "name": "fk_analysisunitaltdepths_variableunits",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (variableunitsid) REFERENCES ndb.variableunits(variableunitsid) ON UPDATE CASCADE ON DELETE CASCADE",
                    "table": "ndb.analysisunitaltdepthscales",
                    "referenced_table": "variableunits",
                    "columns": [
                        "variableunitsid"
                    ],
                    "referenced_columns": [
                        "variableunitsid"
                    ]
                }
            ],
            "triggers": [
                {
                    "name": "tr_sites_modifydate",
                    "def": "CREATE TRIGGER tr_sites_modifydate BEFORE INSERT OR UPDATE ON ndb.analysisunitaltdepthscales FOR EACH ROW EXECUTE FUNCTION ndb.update_recdatemodified()"
                }
            ]
        },
        {
            "name": "ndb.analysisunitlithostrat",
            "type": "BASE TABLE",
            "columns": [
                {
                    "name": "analysisunitid",
                    "type": "integer",
                    "nullable": false
                },
                {
                    "name": "lithostratid",
                    "type": "integer",
                    "nullable": false
                },
                {
                    "name": "recdatecreated",
                    "type": "timestamp(0) without time zone",
                    "nullable": false,
                    "default": "timezone('UTC'::text, now())"
                },
                {
                    "name": "recdatemodified",
                    "type": "timestamp(0) without time zone",
                    "nullable": false
                }
            ],
            "indexes": [
                {
                    "name": "analysisunitlithostrat_pkey",
                    "def": "CREATE UNIQUE INDEX analysisunitlithostrat_pkey ON ndb.analysisunitlithostrat USING btree (analysisunitid, lithostratid)",
                    "table": "ndb.analysisunitlithostrat",
                    "columns": [
                        "analysisunitid",
                        "lithostratid"
                    ]
                }
            ],
            "constraints": [
                {
                    "name": "analysisunitlithostrat_pkey",
                    "type": "PRIMARY KEY",
                    "def": "PRIMARY KEY (analysisunitid, lithostratid)",
                    "table": "ndb.analysisunitlithostrat",
                    "referenced_table": "",
                    "columns": [
                        "analysisunitid",
                        "lithostratid"
                    ]
                },
                {
                    "name": "fk_analysisunitlithostrat_analysisunits",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (analysisunitid) REFERENCES ndb.analysisunits(analysisunitid) ON UPDATE CASCADE ON DELETE CASCADE",
                    "table": "ndb.analysisunitlithostrat",
                    "referenced_table": "analysisunits",
                    "columns": [
                        "analysisunitid"
                    ],
                    "referenced_columns": [
                        "analysisunitid"
                    ]
                },
                {
                    "name": "fk_analysisunitlithostrat_lithostrat",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (lithostratid) REFERENCES ndb.lithostrat(lithostratid) ON UPDATE CASCADE ON DELETE CASCADE",
                    "table": "ndb.analysisunitlithostrat",
                    "referenced_table": "lithostrat",
                    "columns": [
                        "lithostratid"
                    ],
                    "referenced_columns": [
                        "lithostratid"
                    ]
                }
            ],
            "triggers": [
                {
                    "name": "tr_sites_modifydate",
                    "def": "CREATE TRIGGER tr_sites_modifydate BEFORE INSERT OR UPDATE ON ndb.analysisunitlithostrat FOR EACH ROW EXECUTE FUNCTION ndb.update_recdatemodified()"
                }
            ]
        },
        {
            "name": "ndb.analysisunits",
            "type": "BASE TABLE",
            "comment": "This table stores the data for Analysis Units.",
            "columns": [
                {
                    "name": "analysisunitid",
                    "type": "integer",
                    "nullable": false,
                    "default": "nextval('ndb.seq_analysisunits_analysisunitid'::regclass)",
                    "comment": "An arbitrary Analysis Unit identification number."
                },
                {
                    "name": "collectionunitid",
                    "type": "integer",
                    "nullable": false,
                    "comment": "Collection Unit ID number. Field links to CollectionUnits table. Every Analysis Unit belongs to a Collection Unit."
                },
                {
                    "name": "analysisunitname",
                    "type": "varchar(80)",
                    "nullable": true,
                    "comment": "Optional name for an Analysis Unit. Analysis Units are usually designated with either a depth or a name, sometimes both."
                },
                {
                    "name": "depth",
                    "type": "double precision",
                    "nullable": true,
                    "comment": "Optional depth of the Analysis Unit in cm. Depths are typically designated for Analysis Units from cores and for Analysis Units excavated in arbitrary (e.g. 10 cm) levels. Depths are normally the midpoints of arbitrary levels. For example, for a level excavated from 10 to 20 cm or for a core section from 10 to 15 cm, the depth is 15. Designating depths as midpoints and thicknesses facilitates calculation of ages from age models that utilize single midpoint depths for Analysis Units rather than top and bottom depths. Of course, top and bottom depths can be calculated from midpoint depths and thicknesses. For many microfossil core samples, only the midpoint depths are known or published; the diameter or width of the sampling device is often not given."
                },
                {
                    "name": "thickness",
                    "type": "double precision",
                    "nullable": true,
                    "comment": "Optional thickness of the Analysis Unit in cm. For many microfossil core samples, the depths are treated as points, and the thicknesses are not given in the publications, although 0.5 to 1.0 cm would be typical."
                },
                {
                    "name": "faciesid",
                    "type": "integer",
                    "nullable": true,
                    "comment": "Sedimentary facies of the Analysis Unit. Field links to the FaciesTypes table."
                },
                {
                    "name": "mixed",
                    "type": "boolean",
                    "nullable": false,
                    "comment": "Indicates whether specimens in the Analysis Unit are of mixed ages, for example Pleistocene fossils occurring with late Holocene fossils. Although Analysis Units may be mixed, samples from the Analysis Unit may not be, for example individually radiocarbon dated specimens."
                },
                {
                    "name": "igsn",
                    "type": "varchar(40)",
                    "nullable": true,
                    "comment": "International Geo Sample Number. The IGSN is a unique identifier for a Geoscience sample. They are assigned by the SESAR, the System for Earth Sample Registration (www.geosamples.org), which is a registry that provides and administers the unique identifiers. IGSN’s may be assigned to all types of geoscience samples, including cores, rocks, minerals, and even fluids. Their purpose is to facilitate sharing and correlation of samples and sample-based data. For data in Neotoma, their primary value would be for correlation various samples from the same Analysis Units, for example pollen, charcoal, diatoms, and geochemical analyses. Conceivably, the AnalysisUnitID could be used for this purpose; however, IGSN’s could be assigned by projects before their data are submitted to the database. Moreover, AnalysisUnitID’s are intended to be internal to the database. Although IGSN’s could be assigned to Neotoma Collection Units and Samples, their primary value lies in their assignment to Analysis Units. IGSN’s are not yet assigned to Neotoma Analysis Units; however, that may change after consultation with SESAR."
                },
                {
                    "name": "notes",
                    "type": "text",
                    "nullable": true,
                    "comment": "Free form notes or comments about the Analysis Unit."
                },
                {
                    "name": "recdatecreated",
                    "type": "timestamp(0) without time zone",
                    "nullable": false,
                    "default": "timezone('UTC'::text, now())"
                },
                {
                    "name": "recdatemodified",
                    "type": "timestamp(0) without time zone",
                    "nullable": false
                }
            ],
            "indexes": [
                {
                    "name": "analysisunits_pkey",
                    "def": "CREATE UNIQUE INDEX analysisunits_pkey ON ndb.analysisunits USING btree (analysisunitid)",
                    "table": "ndb.analysisunits",
                    "columns": [
                        "analysisunitid"
                    ]
                },
                {
                    "name": "analysisunits_collunit_idx",
                    "def": "CREATE INDEX analysisunits_collunit_idx ON ndb.analysisunits USING btree (collectionunitid)",
                    "table": "ndb.analysisunits",
                    "columns": [
                        "collectionunitid"
                    ]
                },
                {
                    "name": "analysisunits_facies_idx",
                    "def": "CREATE INDEX analysisunits_facies_idx ON ndb.analysisunits USING btree (faciesid)",
                    "table": "ndb.analysisunits",
                    "columns": [
                        "faciesid"
                    ]
                }
            ],
            "constraints": [
                {
                    "name": "analysisunits_pkey",
                    "type": "PRIMARY KEY",
                    "def": "PRIMARY KEY (analysisunitid)",
                    "table": "ndb.analysisunits",
                    "referenced_table": "",
                    "columns": [
                        "analysisunitid"
                    ]
                },
                {
                    "name": "fk_analysisunits_collectionunits",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (collectionunitid) REFERENCES ndb.collectionunits(collectionunitid) ON UPDATE CASCADE ON DELETE CASCADE",
                    "table": "ndb.analysisunits",
                    "referenced_table": "collectionunits",
                    "columns": [
                        "collectionunitid"
                    ],
                    "referenced_columns": [
                        "collectionunitid"
                    ]
                },
                {
                    "name": "fk_analysisunits_faciestypes",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (faciesid) REFERENCES ndb.faciestypes(faciesid) ON UPDATE CASCADE ON DELETE CASCADE",
                    "table": "ndb.analysisunits",
                    "referenced_table": "faciestypes",
                    "columns": [
                        "faciesid"
                    ],
                    "referenced_columns": [
                        "faciesid"
                    ]
                }
            ],
            "triggers": [
                {
                    "name": "tr_sites_modifydate",
                    "def": "CREATE TRIGGER tr_sites_modifydate BEFORE INSERT OR UPDATE ON ndb.analysisunits FOR EACH ROW EXECUTE FUNCTION ndb.update_recdatemodified()"
                }
            ]
        },
        {
            "name": "ndb.calibrationcurves",
            "type": "BASE TABLE",
            "columns": [
                {
                    "name": "calibrationcurveid",
                    "type": "integer",
                    "nullable": false,
                    "default": "nextval('ndb.seq_calibrationcurves_calibrationcurveid'::regclass)"
                },
                {
                    "name": "calibrationcurve",
                    "type": "varchar(24)",
                    "nullable": false
                },
                {
                    "name": "publicationid",
                    "type": "integer",
                    "nullable": false
                },
                {
                    "name": "recdatecreated",
                    "type": "timestamp(0) without time zone",
                    "nullable": false,
                    "default": "timezone('UTC'::text, now())"
                },
                {
                    "name": "recdatemodified",
                    "type": "timestamp(0) without time zone",
                    "nullable": false
                }
            ],
            "indexes": [
                {
                    "name": "calibrationcurves_pkey",
                    "def": "CREATE UNIQUE INDEX calibrationcurves_pkey ON ndb.calibrationcurves USING btree (calibrationcurveid)",
                    "table": "ndb.calibrationcurves",
                    "columns": [
                        "calibrationcurveid"
                    ]
                }
            ],
            "constraints": [
                {
                    "name": "calibrationcurves_pkey",
                    "type": "PRIMARY KEY",
                    "def": "PRIMARY KEY (calibrationcurveid)",
                    "table": "ndb.calibrationcurves",
                    "referenced_table": "",
                    "columns": [
                        "calibrationcurveid"
                    ]
                },
                {
                    "name": "fk_calibrationcurves_publications",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (publicationid) REFERENCES ndb.publications(publicationid) ON UPDATE CASCADE ON DELETE CASCADE",
                    "table": "ndb.calibrationcurves",
                    "referenced_table": "publications",
                    "columns": [
                        "publicationid"
                    ],
                    "referenced_columns": [
                        "publicationid"
                    ]
                }
            ],
            "triggers": [
                {
                    "name": "tr_sites_modifydate",
                    "def": "CREATE TRIGGER tr_sites_modifydate BEFORE INSERT OR UPDATE ON ndb.calibrationcurves FOR EACH ROW EXECUTE FUNCTION ndb.update_recdatemodified()"
                }
            ]
        },
        {
            "name": "ndb.calibrationprograms",
            "type": "BASE TABLE",
            "columns": [
                {
                    "name": "calibrationprogramid",
                    "type": "integer",
                    "nullable": false,
                    "default": "nextval('ndb.seq_calibrationprograms_calibrationprogramid'::regclass)"
                },
                {
                    "name": "calibrationprogram",
                    "type": "varchar(24)",
                    "nullable": false
                },
                {
                    "name": "version",
                    "type": "varchar(24)",
                    "nullable": true
                },
                {
                    "name": "recdatecreated",
                    "type": "timestamp(0) without time zone",
                    "nullable": false,
                    "default": "timezone('UTC'::text, now())"
                },
                {
                    "name": "recdatemodified",
                    "type": "timestamp(0) without time zone",
                    "nullable": false
                }
            ],
            "indexes": [
                {
                    "name": "calibrationprograms_pkey",
                    "def": "CREATE UNIQUE INDEX calibrationprograms_pkey ON ndb.calibrationprograms USING btree (calibrationprogramid)",
                    "table": "ndb.calibrationprograms",
                    "columns": [
                        "calibrationprogramid"
                    ]
                }
            ],
            "constraints": [
                {
                    "name": "calibrationprograms_pkey",
                    "type": "PRIMARY KEY",
                    "def": "PRIMARY KEY (calibrationprogramid)",
                    "table": "ndb.calibrationprograms",
                    "referenced_table": "",
                    "columns": [
                        "calibrationprogramid"
                    ]
                }
            ],
            "triggers": [
                {
                    "name": "tr_sites_modifydate",
                    "def": "CREATE TRIGGER tr_sites_modifydate BEFORE INSERT OR UPDATE ON ndb.calibrationprograms FOR EACH ROW EXECUTE FUNCTION ndb.update_recdatemodified()"
                }
            ]
        },
        {
            "name": "ndb.chroncontrolaccuracydirections",
            "type": "BASE TABLE",
            "columns": [
                {
                    "name": "accuracydirectionid",
                    "type": "integer",
                    "nullable": false,
                    "default": "nextval('ndb.seq_chroncontrolaccuracydirections_accuracydirectionid'::regclass)"
                },
                {
                    "name": "accuracydirection",
                    "type": "varchar(80)",
                    "nullable": false
                },
                {
                    "name": "recdatecreated",
                    "type": "timestamp(0) without time zone",
                    "nullable": false,
                    "default": "timezone('UTC'::text, now())"
                },
                {
                    "name": "recdatemodified",
                    "type": "timestamp(0) without time zone",
                    "nullable": false
                }
            ],
            "indexes": [
                {
                    "name": "chroncontrolaccuracydirections_pkey",
                    "def": "CREATE UNIQUE INDEX chroncontrolaccuracydirections_pkey ON ndb.chroncontrolaccuracydirections USING btree (accuracydirectionid)",
                    "table": "ndb.chroncontrolaccuracydirections",
                    "columns": [
                        "accuracydirectionid"
                    ]
                }
            ],
            "constraints": [
                {
                    "name": "chroncontrolaccuracydirections_pkey",
                    "type": "PRIMARY KEY",
                    "def": "PRIMARY KEY (accuracydirectionid)",
                    "table": "ndb.chroncontrolaccuracydirections",
                    "referenced_table": "",
                    "columns": [
                        "accuracydirectionid"
                    ]
                }
            ],
            "triggers": [
                {
                    "name": "tr_sites_modifydate",
                    "def": "CREATE TRIGGER tr_sites_modifydate BEFORE INSERT OR UPDATE ON ndb.chroncontrolaccuracydirections FOR EACH ROW EXECUTE FUNCTION ndb.update_recdatemodified()"
                }
            ]
        },
        {
            "name": "ndb.chroncontrolaccuracydistributions",
            "type": "BASE TABLE",
            "columns": [
                {
                    "name": "accuracydistributionid",
                    "type": "integer",
                    "nullable": false,
                    "default": "nextval('ndb.seq_chroncontrolaccuracydistributions_accuracydistributionid'::regclass)"
                },
                {
                    "name": "accuracydistribution",
                    "type": "varchar(40)",
                    "nullable": false
                },
                {
                    "name": "recdatecreated",
                    "type": "timestamp(0) without time zone",
                    "nullable": false,
                    "default": "timezone('UTC'::text, now())"
                },
                {
                    "name": "recdatemodified",
                    "type": "timestamp(0) without time zone",
                    "nullable": false
                }
            ],
            "indexes": [
                {
                    "name": "chroncontrolaccuracydistributions_pkey",
                    "def": "CREATE UNIQUE INDEX chroncontrolaccuracydistributions_pkey ON ndb.chroncontrolaccuracydistributions USING btree (accuracydistributionid)",
                    "table": "ndb.chroncontrolaccuracydistributions",
                    "columns": [
                        "accuracydistributionid"
                    ]
                }
            ],
            "constraints": [
                {
                    "name": "chroncontrolaccuracydistributions_pkey",
                    "type": "PRIMARY KEY",
                    "def": "PRIMARY KEY (accuracydistributionid)",
                    "table": "ndb.chroncontrolaccuracydistributions",
                    "referenced_table": "",
                    "columns": [
                        "accuracydistributionid"
                    ]
                }
            ],
            "triggers": [
                {
                    "name": "tr_sites_modifydate",
                    "def": "CREATE TRIGGER tr_sites_modifydate BEFORE INSERT OR UPDATE ON ndb.chroncontrolaccuracydistributions FOR EACH ROW EXECUTE FUNCTION ndb.update_recdatemodified()"
                }
            ]
        },
        {
            "name": "ndb.chroncontrolaccuracyranks",
            "type": "BASE TABLE",
            "columns": [
                {
                    "name": "accuracyrankid",
                    "type": "integer",
                    "nullable": false,
                    "default": "nextval('ndb.seq_chroncontrolaccuracyranks_accuracyrankid'::regclass)"
                },
                {
                    "name": "accuracyrank",
                    "type": "varchar(255)",
                    "nullable": false
                },
                {
                    "name": "recdatecreated",
                    "type": "timestamp(0) without time zone",
                    "nullable": false,
                    "default": "timezone('UTC'::text, now())"
                },
                {
                    "name": "recdatemodified",
                    "type": "timestamp(0) without time zone",
                    "nullable": false
                }
            ],
            "indexes": [
                {
                    "name": "chroncontrolaccuracyranks_pkey",
                    "def": "CREATE UNIQUE INDEX chroncontrolaccuracyranks_pkey ON ndb.chroncontrolaccuracyranks USING btree (accuracyrankid)",
                    "table": "ndb.chroncontrolaccuracyranks",
                    "columns": [
                        "accuracyrankid"
                    ]
                }
            ],
            "constraints": [
                {
                    "name": "chroncontrolaccuracyranks_pkey",
                    "type": "PRIMARY KEY",
                    "def": "PRIMARY KEY (accuracyrankid)",
                    "table": "ndb.chroncontrolaccuracyranks",
                    "referenced_table": "",
                    "columns": [
                        "accuracyrankid"
                    ]
                }
            ],
            "triggers": [
                {
                    "name": "tr_sites_modifydate",
                    "def": "CREATE TRIGGER tr_sites_modifydate BEFORE INSERT OR UPDATE ON ndb.chroncontrolaccuracyranks FOR EACH ROW EXECUTE FUNCTION ndb.update_recdatemodified()"
                }
            ]
        },
        {
            "name": "ndb.chroncontrolprecisionranks",
            "type": "BASE TABLE",
            "columns": [
                {
                    "name": "precisionrankid",
                    "type": "integer",
                    "nullable": false,
                    "default": "nextval('ndb.seq_chroncontrolprecisionranks_precisionrankid'::regclass)"
                },
                {
                    "name": "precisionrank",
                    "type": "varchar(255)",
                    "nullable": false
                },
                {
                    "name": "recdatecreated",
                    "type": "timestamp(0) without time zone",
                    "nullable": false,
                    "default": "timezone('UTC'::text, now())"
                },
                {
                    "name": "recdatemodified",
                    "type": "timestamp(0) without time zone",
                    "nullable": false
                }
            ],
            "indexes": [
                {
                    "name": "chroncontrolprecisionranks_pkey",
                    "def": "CREATE UNIQUE INDEX chroncontrolprecisionranks_pkey ON ndb.chroncontrolprecisionranks USING btree (precisionrankid)",
                    "table": "ndb.chroncontrolprecisionranks",
                    "columns": [
                        "precisionrankid"
                    ]
                }
            ],
            "constraints": [
                {
                    "name": "chroncontrolprecisionranks_pkey",
                    "type": "PRIMARY KEY",
                    "def": "PRIMARY KEY (precisionrankid)",
                    "table": "ndb.chroncontrolprecisionranks",
                    "referenced_table": "",
                    "columns": [
                        "precisionrankid"
                    ]
                }
            ],
            "triggers": [
                {
                    "name": "tr_sites_modifydate",
                    "def": "CREATE TRIGGER tr_sites_modifydate BEFORE INSERT OR UPDATE ON ndb.chroncontrolprecisionranks FOR EACH ROW EXECUTE FUNCTION ndb.update_recdatemodified()"
                }
            ]
        },
        {
            "name": "ndb.chroncontrolranks",
            "type": "BASE TABLE",
            "columns": [
                {
                    "name": "chroncontrolrankid",
                    "type": "integer",
                    "nullable": false,
                    "default": "nextval('ndb.seq_chroncontrolranks_chroncontrolrankid'::regclass)"
                },
                {
                    "name": "chroncontrolid",
                    "type": "integer",
                    "nullable": true
                },
                {
                    "name": "accuracyrankid",
                    "type": "integer",
                    "nullable": true
                },
                {
                    "name": "accuracydirectionid",
                    "type": "integer",
                    "nullable": true
                },
                {
                    "name": "accuracydistributionid",
                    "type": "integer",
                    "nullable": true
                },
                {
                    "name": "precisionrankid",
                    "type": "integer",
                    "nullable": true
                },
                {
                    "name": "outlier",
                    "type": "boolean",
                    "nullable": true
                },
                {
                    "name": "recdatecreated",
                    "type": "timestamp(0) without time zone",
                    "nullable": false,
                    "default": "timezone('UTC'::text, now())"
                },
                {
                    "name": "recdatemodified",
                    "type": "timestamp(0) without time zone",
                    "nullable": false
                }
            ],
            "indexes": [
                {
                    "name": "chroncontrolranks_pkey",
                    "def": "CREATE UNIQUE INDEX chroncontrolranks_pkey ON ndb.chroncontrolranks USING btree (chroncontrolrankid)",
                    "table": "ndb.chroncontrolranks",
                    "columns": [
                        "chroncontrolrankid"
                    ]
                }
            ],
            "constraints": [
                {
                    "name": "fk_chroncontrolranks_chroncontrolaccuracydirections",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (accuracydirectionid) REFERENCES ndb.chroncontrolaccuracydirections(accuracydirectionid) ON UPDATE CASCADE ON DELETE CASCADE",
                    "table": "ndb.chroncontrolranks",
                    "referenced_table": "chroncontrolaccuracydirections",
                    "columns": [
                        "accuracydirectionid"
                    ],
                    "referenced_columns": [
                        "accuracydirectionid"
                    ]
                },
                {
                    "name": "fk_chroncontrolranks_chroncontrolaccuracydistributions",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (accuracydistributionid) REFERENCES ndb.chroncontrolaccuracydistributions(accuracydistributionid) ON UPDATE CASCADE ON DELETE CASCADE",
                    "table": "ndb.chroncontrolranks",
                    "referenced_table": "chroncontrolaccuracydistributions",
                    "columns": [
                        "accuracydistributionid"
                    ],
                    "referenced_columns": [
                        "accuracydistributionid"
                    ]
                },
                {
                    "name": "fk_chroncontrolranks_chroncontrolaccuracyranks",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (accuracyrankid) REFERENCES ndb.chroncontrolaccuracyranks(accuracyrankid) ON UPDATE CASCADE ON DELETE CASCADE",
                    "table": "ndb.chroncontrolranks",
                    "referenced_table": "chroncontrolaccuracyranks",
                    "columns": [
                        "accuracyrankid"
                    ],
                    "referenced_columns": [
                        "accuracyrankid"
                    ]
                },
                {
                    "name": "fk_chroncontrolranks_chroncontrolprecisionranks",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (precisionrankid) REFERENCES ndb.chroncontrolprecisionranks(precisionrankid) ON UPDATE CASCADE ON DELETE CASCADE",
                    "table": "ndb.chroncontrolranks",
                    "referenced_table": "chroncontrolprecisionranks",
                    "columns": [
                        "precisionrankid"
                    ],
                    "referenced_columns": [
                        "precisionrankid"
                    ]
                },
                {
                    "name": "chroncontrolranks_pkey",
                    "type": "PRIMARY KEY",
                    "def": "PRIMARY KEY (chroncontrolrankid)",
                    "table": "ndb.chroncontrolranks",
                    "referenced_table": "",
                    "columns": [
                        "chroncontrolrankid"
                    ]
                },
                {
                    "name": "fk_chroncontrolranks_chroncontrols",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (chroncontrolid) REFERENCES ndb.chroncontrols(chroncontrolid) ON UPDATE CASCADE ON DELETE CASCADE",
                    "table": "ndb.chroncontrolranks",
                    "referenced_table": "chroncontrols",
                    "columns": [
                        "chroncontrolid"
                    ],
                    "referenced_columns": [
                        "chroncontrolid"
                    ]
                }
            ],
            "triggers": [
                {
                    "name": "tr_sites_modifydate",
                    "def": "CREATE TRIGGER tr_sites_modifydate BEFORE INSERT OR UPDATE ON ndb.chroncontrolranks FOR EACH ROW EXECUTE FUNCTION ndb.update_recdatemodified()"
                }
            ]
        },
        {
            "name": "ndb.chroncontrols",
            "type": "BASE TABLE",
            "comment": "This table stores data for Chronology Controls, which are the age-depth control points used for age models. These controls may be geophysical controls, such as radiocarbon dates, but include many other kinds of age controls, such as biostratigraphic controls, archaeological cultural associations, and volcanic tephras. In the case of radiocarbon dates, a Chronology Control may not simply be the raw radiocarbon date reported by the laboratory, but perhaps a radiocarbon date corrected for an old carbon reservoir, a calibrated radiocarbon date, or an average of several radiocarbon dates from the same level. A common control for lake-sediment cores is the age of the top of the core, which may be the year the core was taken or perhaps an estimate of 0 BP if a few cm of surficial sediment were lost.",
            "columns": [
                {
                    "name": "chroncontrolid",
                    "type": "integer",
                    "nullable": false,
                    "default": "nextval('ndb.seq_chroncontrols_chroncontrolid'::regclass)",
                    "comment": "An arbitrary Chronology Control identification number."
                },
                {
                    "name": "chronologyid",
                    "type": "integer",
                    "nullable": false,
                    "comment": "Chronology to which the ChronControl belongs. Field links to the Chronolgies table."
                },
                {
                    "name": "chroncontroltypeid",
                    "type": "integer",
                    "nullable": true,
                    "comment": "The type of Chronology Control. Field links to the ChronControlTypes table."
                },
                {
                    "name": "depth",
                    "type": "double precision",
                    "nullable": true,
                    "comment": "Depth of the Chronology Control in cm."
                },
                {
                    "name": "thickness",
                    "type": "double precision",
                    "nullable": true,
                    "comment": "Thickness of the Chronology Control in cm."
                },
                {
                    "name": "age",
                    "type": "double precision",
                    "nullable": true,
                    "comment": "Age of the Chronology Control."
                },
                {
                    "name": "agelimityounger",
                    "type": "double precision",
                    "nullable": true,
                    "comment": "The younger age limit of a Chronology Control. This limit may be explicitly defined, for example the younger of the 2-sigma range limits of a calibrated radiocarbon date, or it may be more loosely defined, for example the younger limit on the range of dates for a biostratigraphic horizon."
                },
                {
                    "name": "agelimitolder",
                    "type": "double precision",
                    "nullable": true,
                    "comment": "The older age limit of a Chronology Control."
                },
                {
                    "name": "notes",
                    "type": "text",
                    "nullable": true,
                    "comment": "Free form notes or comments about the Chronology Control."
                },
                {
                    "name": "recdatecreated",
                    "type": "timestamp(0) without time zone",
                    "nullable": false,
                    "default": "timezone('UTC'::text, now())"
                },
                {
                    "name": "recdatemodified",
                    "type": "timestamp(0) without time zone",
                    "nullable": false
                },
                {
                    "name": "analysisunitid",
                    "type": "integer",
                    "nullable": true
                },
                {
                    "name": "agetypeid",
                    "type": "integer",
                    "nullable": true
                }
            ],
            "indexes": [
                {
                    "name": "chroncontrols_pkey",
                    "def": "CREATE UNIQUE INDEX chroncontrols_pkey ON ndb.chroncontrols USING btree (chroncontrolid)",
                    "table": "ndb.chroncontrols",
                    "columns": [
                        "chroncontrolid"
                    ]
                },
                {
                    "name": "ccrchronage_idx",
                    "def": "CREATE INDEX ccrchronage_idx ON ndb.chroncontrols USING btree (age)",
                    "table": "ndb.chroncontrols",
                    "columns": [
                        "age"
                    ]
                },
                {
                    "name": "ccroldage_idx",
                    "def": "CREATE INDEX ccroldage_idx ON ndb.chroncontrols USING btree (agelimitolder)",
                    "table": "ndb.chroncontrols",
                    "columns": [
                        "agelimitolder"
                    ]
                },
                {
                    "name": "ccryoungage_idx",
                    "def": "CREATE INDEX ccryoungage_idx ON ndb.chroncontrols USING btree (agelimityounger)",
                    "table": "ndb.chroncontrols",
                    "columns": [
                        "agelimityounger"
                    ]
                },
                {
                    "name": "chroncontrols_chronologyid_idx",
                    "def": "CREATE INDEX chroncontrols_chronologyid_idx ON ndb.chroncontrols USING btree (chronologyid)",
                    "table": "ndb.chroncontrols",
                    "columns": [
                        "chronologyid"
                    ]
                }
            ],
            "constraints": [
                {
                    "name": "fk_chroncontrols_agetypes",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (agetypeid) REFERENCES ndb.agetypes(agetypeid)",
                    "table": "ndb.chroncontrols",
                    "referenced_table": "agetypes",
                    "columns": [
                        "agetypeid"
                    ],
                    "referenced_columns": [
                        "agetypeid"
                    ]
                },
                {
                    "name": "fk_chroncontrols_analysisunits",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (analysisunitid) REFERENCES ndb.analysisunits(analysisunitid) ON UPDATE CASCADE ON DELETE CASCADE",
                    "table": "ndb.chroncontrols",
                    "referenced_table": "analysisunits",
                    "columns": [
                        "analysisunitid"
                    ],
                    "referenced_columns": [
                        "analysisunitid"
                    ]
                },
                {
                    "name": "chroncontrols_pkey",
                    "type": "PRIMARY KEY",
                    "def": "PRIMARY KEY (chroncontrolid)",
                    "table": "ndb.chroncontrols",
                    "referenced_table": "",
                    "columns": [
                        "chroncontrolid"
                    ]
                },
                {
                    "name": "fk_chroncontrols_chroncontroltypes",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (chroncontroltypeid) REFERENCES ndb.chroncontroltypes(chroncontroltypeid) ON UPDATE CASCADE ON DELETE CASCADE",
                    "table": "ndb.chroncontrols",
                    "referenced_table": "chroncontroltypes",
                    "columns": [
                        "chroncontroltypeid"
                    ],
                    "referenced_columns": [
                        "chroncontroltypeid"
                    ]
                },
                {
                    "name": "fk_chroncontrols_chronologies",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (chronologyid) REFERENCES ndb.chronologies(chronologyid) ON UPDATE CASCADE ON DELETE CASCADE",
                    "table": "ndb.chroncontrols",
                    "referenced_table": "chronologies",
                    "columns": [
                        "chronologyid"
                    ],
                    "referenced_columns": [
                        "chronologyid"
                    ]
                }
            ],
            "triggers": [
                {
                    "name": "tr_sites_modifydate",
                    "def": "CREATE TRIGGER tr_sites_modifydate BEFORE INSERT OR UPDATE ON ndb.chroncontrols FOR EACH ROW EXECUTE FUNCTION ndb.update_recdatemodified()"
                }
            ]
        },
        {
            "name": "ndb.chroncontrolscal14c",
            "type": "BASE TABLE",
            "columns": [
                {
                    "name": "chroncontrolid",
                    "type": "integer",
                    "nullable": false
                },
                {
                    "name": "calibrationcurveid",
                    "type": "integer",
                    "nullable": false
                },
                {
                    "name": "calibrationprogramid",
                    "type": "integer",
                    "nullable": false
                },
                {
                    "name": "recdatecreated",
                    "type": "timestamp(0) without time zone",
                    "nullable": false,
                    "default": "timezone('UTC'::text, now())"
                },
                {
                    "name": "recdatemodified",
                    "type": "timestamp(0) without time zone",
                    "nullable": false
                }
            ],
            "indexes": [
                {
                    "name": "chroncontrolscal14c_pkey",
                    "def": "CREATE UNIQUE INDEX chroncontrolscal14c_pkey ON ndb.chroncontrolscal14c USING btree (chroncontrolid)",
                    "table": "ndb.chroncontrolscal14c",
                    "columns": [
                        "chroncontrolid"
                    ]
                }
            ],
            "constraints": [
                {
                    "name": "fk_chroncontrolscal14c_calibrationcurves",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (calibrationcurveid) REFERENCES ndb.calibrationcurves(calibrationcurveid) ON UPDATE CASCADE ON DELETE CASCADE",
                    "table": "ndb.chroncontrolscal14c",
                    "referenced_table": "calibrationcurves",
                    "columns": [
                        "calibrationcurveid"
                    ],
                    "referenced_columns": [
                        "calibrationcurveid"
                    ]
                },
                {
                    "name": "fk_chroncontrolscal14c_calibrationprograms",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (calibrationprogramid) REFERENCES ndb.calibrationprograms(calibrationprogramid) ON UPDATE CASCADE ON DELETE CASCADE",
                    "table": "ndb.chroncontrolscal14c",
                    "referenced_table": "calibrationprograms",
                    "columns": [
                        "calibrationprogramid"
                    ],
                    "referenced_columns": [
                        "calibrationprogramid"
                    ]
                },
                {
                    "name": "fk_chroncontrolscal14c_chroncontrols",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (chroncontrolid) REFERENCES ndb.chroncontrols(chroncontrolid) ON UPDATE CASCADE ON DELETE CASCADE",
                    "table": "ndb.chroncontrolscal14c",
                    "referenced_table": "chroncontrols",
                    "columns": [
                        "chroncontrolid"
                    ],
                    "referenced_columns": [
                        "chroncontrolid"
                    ]
                },
                {
                    "name": "chroncontrolscal14c_pkey",
                    "type": "PRIMARY KEY",
                    "def": "PRIMARY KEY (chroncontrolid)",
                    "table": "ndb.chroncontrolscal14c",
                    "referenced_table": "",
                    "columns": [
                        "chroncontrolid"
                    ]
                }
            ],
            "triggers": [
                {
                    "name": "tr_sites_modifydate",
                    "def": "CREATE TRIGGER tr_sites_modifydate BEFORE INSERT OR UPDATE ON ndb.chroncontrolscal14c FOR EACH ROW EXECUTE FUNCTION ndb.update_recdatemodified()"
                }
            ]
        },
        {
            "name": "ndb.chroncontroltypes",
            "type": "BASE TABLE",
            "comment": "Lookup table of Chronology Control Types. This table is referenced by the ChronControls table.",
            "columns": [
                {
                    "name": "chroncontroltypeid",
                    "type": "integer",
                    "nullable": false,
                    "default": "nextval('ndb.seq_chroncontroltypes_chroncontroltypeid'::regclass)",
                    "comment": "An arbitrary Chronology Control Type identification number."
                },
                {
                    "name": "chroncontroltype",
                    "type": "varchar(64)",
                    "nullable": true,
                    "comment": "The Chronology Control Type. Chronology Controls include such geophysical controls as radiocarbon dates, calibrated radiocarbon dates, averages of several radiocarbon dates, potassium-argon dates, and thermoluminescence dates, as well as biostratigraphic controls, sediment stratigraphic controls, volcanic tephras, archaeological cultural associations, and any other types of age controls."
                },
                {
                    "name": "higherchroncontroltypeid",
                    "type": "integer",
                    "nullable": true
                },
                {
                    "name": "recdatecreated",
                    "type": "timestamp(0) without time zone",
                    "nullable": false,
                    "default": "timezone('UTC'::text, now())"
                },
                {
                    "name": "recdatemodified",
                    "type": "timestamp(0) without time zone",
                    "nullable": false
                }
            ],
            "indexes": [
                {
                    "name": "chroncontroltypes_pkey",
                    "def": "CREATE UNIQUE INDEX chroncontroltypes_pkey ON ndb.chroncontroltypes USING btree (chroncontroltypeid)",
                    "table": "ndb.chroncontroltypes",
                    "columns": [
                        "chroncontroltypeid"
                    ]
                }
            ],
            "constraints": [
                {
                    "name": "chroncontroltypes_pkey",
                    "type": "PRIMARY KEY",
                    "def": "PRIMARY KEY (chroncontroltypeid)",
                    "table": "ndb.chroncontroltypes",
                    "referenced_table": "",
                    "columns": [
                        "chroncontroltypeid"
                    ]
                },
                {
                    "name": "fk_higherchroncontroltypeid",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (higherchroncontroltypeid) REFERENCES ndb.chroncontroltypes(chroncontroltypeid)",
                    "table": "ndb.chroncontroltypes",
                    "referenced_table": "chroncontroltypes",
                    "columns": [
                        "higherchroncontroltypeid"
                    ],
                    "referenced_columns": [
                        "chroncontroltypeid"
                    ]
                }
            ],
            "triggers": [
                {
                    "name": "tr_sites_modifydate",
                    "def": "CREATE TRIGGER tr_sites_modifydate BEFORE INSERT OR UPDATE ON ndb.chroncontroltypes FOR EACH ROW EXECUTE FUNCTION ndb.update_recdatemodified()"
                }
            ]
        },
        {
            "name": "ndb.collectors",
            "type": "BASE TABLE",
            "comment": "The Collectors table lists the people who collected Collection Units.",
            "columns": [
                {
                    "name": "collectorid",
                    "type": "integer",
                    "nullable": false,
                    "default": "nextval('ndb.seq_collectors_collectorid'::regclass)",
                    "comment": "An arbitrary Collector identification number."
                },
                {
                    "name": "collectionunitid",
                    "type": "integer",
                    "nullable": false,
                    "comment": "CollectionUnit collected. Field links to CollectionUnits table."
                },
                {
                    "name": "contactid",
                    "type": "integer",
                    "nullable": false,
                    "comment": "Person who collected the CollectionUnit. Multiple individuals are listed in separate records. Field links to the Contacts table."
                },
                {
                    "name": "collectororder",
                    "type": "integer",
                    "nullable": true,
                    "comment": "Order in which Collectors should be listed."
                },
                {
                    "name": "recdatecreated",
                    "type": "timestamp(0) without time zone",
                    "nullable": false,
                    "default": "timezone('UTC'::text, now())"
                },
                {
                    "name": "recdatemodified",
                    "type": "timestamp(0) without time zone",
                    "nullable": false
                }
            ],
            "indexes": [
                {
                    "name": "collectors_pkey",
                    "def": "CREATE UNIQUE INDEX collectors_pkey ON ndb.collectors USING btree (collectorid)",
                    "table": "ndb.collectors",
                    "columns": [
                        "collectorid"
                    ]
                }
            ],
            "constraints": [
                {
                    "name": "fk_collectors_collectionunits",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (collectionunitid) REFERENCES ndb.collectionunits(collectionunitid) ON UPDATE CASCADE ON DELETE CASCADE",
                    "table": "ndb.collectors",
                    "referenced_table": "collectionunits",
                    "columns": [
                        "collectionunitid"
                    ],
                    "referenced_columns": [
                        "collectionunitid"
                    ]
                },
                {
                    "name": "collectors_pkey",
                    "type": "PRIMARY KEY",
                    "def": "PRIMARY KEY (collectorid)",
                    "table": "ndb.collectors",
                    "referenced_table": "",
                    "columns": [
                        "collectorid"
                    ]
                },
                {
                    "name": "fk_collectors_contacts",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (contactid) REFERENCES ndb.contacts(contactid) ON UPDATE CASCADE",
                    "table": "ndb.collectors",
                    "referenced_table": "contacts",
                    "columns": [
                        "contactid"
                    ],
                    "referenced_columns": [
                        "contactid"
                    ]
                }
            ],
            "triggers": [
                {
                    "name": "tr_sites_modifydate",
                    "def": "CREATE TRIGGER tr_sites_modifydate BEFORE INSERT OR UPDATE ON ndb.collectors FOR EACH ROW EXECUTE FUNCTION ndb.update_recdatemodified()"
                }
            ]
        },
        {
            "name": "ndb.contactreferences",
            "type": "BASE TABLE",
            "columns": [
                {
                    "name": "contactid",
                    "type": "integer",
                    "nullable": true
                },
                {
                    "name": "exdatabaseid",
                    "type": "integer",
                    "nullable": true
                },
                {
                    "name": "identifier",
                    "type": "text",
                    "nullable": true
                }
            ],
            "constraints": [
                {
                    "name": "contactreferences_contactid_fkey",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (contactid) REFERENCES ndb.contacts(contactid)",
                    "table": "ndb.contactreferences",
                    "referenced_table": "contacts",
                    "columns": [
                        "contactid"
                    ],
                    "referenced_columns": [
                        "contactid"
                    ]
                },
                {
                    "name": "contactreferences_exdatabaseid_fkey",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (exdatabaseid) REFERENCES ndb.externaldatabases(extdatabaseid)",
                    "table": "ndb.contactreferences",
                    "referenced_table": "externaldatabases",
                    "columns": [
                        "exdatabaseid"
                    ],
                    "referenced_columns": [
                        "extdatabaseid"
                    ]
                }
            ]
        },
        {
            "name": "ndb.contextsdatasettypes",
            "type": "BASE TABLE",
            "columns": [
                {
                    "name": "datasettypeid",
                    "type": "integer",
                    "nullable": false
                },
                {
                    "name": "variablecontextid",
                    "type": "integer",
                    "nullable": false
                },
                {
                    "name": "recdatecreated",
                    "type": "timestamp(0) without time zone",
                    "nullable": false,
                    "default": "timezone('UTC'::text, now())"
                },
                {
                    "name": "recdatemodified",
                    "type": "timestamp(0) without time zone",
                    "nullable": false
                }
            ],
            "indexes": [
                {
                    "name": "contextsdatasettypes_pkey",
                    "def": "CREATE UNIQUE INDEX contextsdatasettypes_pkey ON ndb.contextsdatasettypes USING btree (datasettypeid, variablecontextid)",
                    "table": "ndb.contextsdatasettypes",
                    "columns": [
                        "datasettypeid",
                        "variablecontextid"
                    ]
                }
            ],
            "constraints": [
                {
                    "name": "contextsdatasettypes_pkey",
                    "type": "PRIMARY KEY",
                    "def": "PRIMARY KEY (datasettypeid, variablecontextid)",
                    "table": "ndb.contextsdatasettypes",
                    "referenced_table": "",
                    "columns": [
                        "datasettypeid",
                        "variablecontextid"
                    ]
                },
                {
                    "name": "fk_contextsdatasettypes_datasettypes",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (datasettypeid) REFERENCES ndb.datasettypes(datasettypeid) ON UPDATE CASCADE ON DELETE CASCADE",
                    "table": "ndb.contextsdatasettypes",
                    "referenced_table": "datasettypes",
                    "columns": [
                        "datasettypeid"
                    ],
                    "referenced_columns": [
                        "datasettypeid"
                    ]
                },
                {
                    "name": "fk_contextsdatasettypes_variablecontexts",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (variablecontextid) REFERENCES ndb.variablecontexts(variablecontextid) ON UPDATE CASCADE ON DELETE CASCADE",
                    "table": "ndb.contextsdatasettypes",
                    "referenced_table": "variablecontexts",
                    "columns": [
                        "variablecontextid"
                    ],
                    "referenced_columns": [
                        "variablecontextid"
                    ]
                }
            ],
            "triggers": [
                {
                    "name": "tr_sites_modifydate",
                    "def": "CREATE TRIGGER tr_sites_modifydate BEFORE INSERT OR UPDATE ON ndb.contextsdatasettypes FOR EACH ROW EXECUTE FUNCTION ndb.update_recdatemodified()"
                }
            ]
        },
        {
            "name": "ndb.dataprocessors",
            "type": "BASE TABLE",
            "columns": [
                {
                    "name": "datasetid",
                    "type": "integer",
                    "nullable": false
                },
                {
                    "name": "contactid",
                    "type": "integer",
                    "nullable": false
                },
                {
                    "name": "recdatecreated",
                    "type": "timestamp(0) without time zone",
                    "nullable": false,
                    "default": "timezone('UTC'::text, now())"
                },
                {
                    "name": "recdatemodified",
                    "type": "timestamp(0) without time zone",
                    "nullable": false
                }
            ],
            "indexes": [
                {
                    "name": "dataprocessors_pkey",
                    "def": "CREATE UNIQUE INDEX dataprocessors_pkey ON ndb.dataprocessors USING btree (datasetid, contactid)",
                    "table": "ndb.dataprocessors",
                    "columns": [
                        "datasetid",
                        "contactid"
                    ]
                }
            ],
            "constraints": [
                {
                    "name": "fk_dataprocessors_contacts",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (contactid) REFERENCES ndb.contacts(contactid) ON UPDATE CASCADE",
                    "table": "ndb.dataprocessors",
                    "referenced_table": "contacts",
                    "columns": [
                        "contactid"
                    ],
                    "referenced_columns": [
                        "contactid"
                    ]
                },
                {
                    "name": "dataprocessors_pkey",
                    "type": "PRIMARY KEY",
                    "def": "PRIMARY KEY (datasetid, contactid)",
                    "table": "ndb.dataprocessors",
                    "referenced_table": "",
                    "columns": [
                        "datasetid",
                        "contactid"
                    ]
                },
                {
                    "name": "fk_dataprocessors_datasets",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (datasetid) REFERENCES ndb.datasets(datasetid) ON UPDATE CASCADE ON DELETE CASCADE",
                    "table": "ndb.dataprocessors",
                    "referenced_table": "datasets",
                    "columns": [
                        "datasetid"
                    ],
                    "referenced_columns": [
                        "datasetid"
                    ]
                }
            ],
            "triggers": [
                {
                    "name": "tr_sites_modifydate",
                    "def": "CREATE TRIGGER tr_sites_modifydate BEFORE INSERT OR UPDATE ON ndb.dataprocessors FOR EACH ROW EXECUTE FUNCTION ndb.update_recdatemodified()"
                }
            ]
        },
        {
            "name": "ndb.datasetsubmissions",
            "type": "BASE TABLE",
            "comment": "Submissions to the database are of Datasets. Submissions may be original submissions, resubmissions, compilations from other databases, or recompilations. See the description of the DatasetSubmissionTypes table.",
            "columns": [
                {
                    "name": "submissionid",
                    "type": "integer",
                    "nullable": false,
                    "default": "nextval('ndb.seq_datasetsubmissions_submissionid'::regclass)",
                    "comment": "An arbitrary submission identification number."
                },
                {
                    "name": "datasetid",
                    "type": "integer",
                    "nullable": false,
                    "comment": "Dataset identification number. Field links to the Datasets table. Datasets may occur multiple times in this table (e.g. once for the original compilation into a different database and a second time for the recompilation into Neotoma)."
                },
                {
                    "name": "databaseid",
                    "type": "integer",
                    "nullable": true
                },
                {
                    "name": "contactid",
                    "type": "integer",
                    "nullable": true,
                    "comment": "Contact identification number. Field links to the Contacts table. The Contact is the person who submitted, resubmitted, compiled, or recompiled the data. This person is not necessarily the Dataset PI; it is the person who submitted the data or compiled the data from the literature."
                },
                {
                    "name": "submissiontypeid",
                    "type": "integer",
                    "nullable": true,
                    "comment": "Submission Type identification number. Field links to the DatasetSubmissionsType table."
                },
                {
                    "name": "submissiondate",
                    "type": "date",
                    "nullable": true,
                    "comment": "Date of the submission, resubmission, compilation, or recompilation."
                },
                {
                    "name": "notes",
                    "type": "text",
                    "nullable": true,
                    "comment": "Free form notes or comments about the submission."
                },
                {
                    "name": "recdatecreated",
                    "type": "timestamp(0) without time zone",
                    "nullable": false,
                    "default": "timezone('UTC'::text, now())"
                },
                {
                    "name": "recdatemodified",
                    "type": "timestamp(0) without time zone",
                    "nullable": false
                }
            ],
            "indexes": [
                {
                    "name": "datasetsubmissions_pkey",
                    "def": "CREATE UNIQUE INDEX datasetsubmissions_pkey ON ndb.datasetsubmissions USING btree (submissionid)",
                    "table": "ndb.datasetsubmissions",
                    "columns": [
                        "submissionid"
                    ]
                },
                {
                    "name": "ix_datasetid_datasetsubmissions",
                    "def": "CREATE INDEX ix_datasetid_datasetsubmissions ON ndb.datasetsubmissions USING btree (datasetid) WITH (fillfactor='10')",
                    "table": "ndb.datasetsubmissions",
                    "columns": [
                        "datasetid"
                    ]
                },
                {
                    "name": "ix_projectid_datasetsubmissions",
                    "def": "CREATE INDEX ix_projectid_datasetsubmissions ON ndb.datasetsubmissions USING btree (databaseid) WITH (fillfactor='10')",
                    "table": "ndb.datasetsubmissions",
                    "columns": [
                        "databaseid"
                    ]
                }
            ],
            "constraints": [
                {
                    "name": "fk_datasetsubmissions_constituentdatabases",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (databaseid) REFERENCES ndb.constituentdatabases(databaseid) ON UPDATE CASCADE ON DELETE CASCADE",
                    "table": "ndb.datasetsubmissions",
                    "referenced_table": "constituentdatabases",
                    "columns": [
                        "databaseid"
                    ],
                    "referenced_columns": [
                        "databaseid"
                    ]
                },
                {
                    "name": "fk_datasetsubmissions_contacts",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (contactid) REFERENCES ndb.contacts(contactid) ON UPDATE CASCADE",
                    "table": "ndb.datasetsubmissions",
                    "referenced_table": "contacts",
                    "columns": [
                        "contactid"
                    ],
                    "referenced_columns": [
                        "contactid"
                    ]
                },
                {
                    "name": "fk_datasetsubmissions_datasets",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (datasetid) REFERENCES ndb.datasets(datasetid) ON UPDATE CASCADE ON DELETE CASCADE",
                    "table": "ndb.datasetsubmissions",
                    "referenced_table": "datasets",
                    "columns": [
                        "datasetid"
                    ],
                    "referenced_columns": [
                        "datasetid"
                    ]
                },
                {
                    "name": "datasetsubmissions_pkey",
                    "type": "PRIMARY KEY",
                    "def": "PRIMARY KEY (submissionid)",
                    "table": "ndb.datasetsubmissions",
                    "referenced_table": "",
                    "columns": [
                        "submissionid"
                    ]
                },
                {
                    "name": "fk_datasetsubmissions_datasetsubmissiontypes",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (submissiontypeid) REFERENCES ndb.datasetsubmissiontypes(submissiontypeid) ON UPDATE CASCADE ON DELETE CASCADE",
                    "table": "ndb.datasetsubmissions",
                    "referenced_table": "datasetsubmissiontypes",
                    "columns": [
                        "submissiontypeid"
                    ],
                    "referenced_columns": [
                        "submissiontypeid"
                    ]
                }
            ],
            "triggers": [
                {
                    "name": "tr_sites_modifydate",
                    "def": "CREATE TRIGGER tr_sites_modifydate BEFORE INSERT OR UPDATE ON ndb.datasetsubmissions FOR EACH ROW EXECUTE FUNCTION ndb.update_recdatemodified()"
                }
            ]
        },
        {
            "name": "ndb.datasetsubmissiontypes",
            "type": "BASE TABLE",
            "comment": "Lookup table of Dataset Submission Types. Table is referenced by the DatasetSubmissions table.",
            "columns": [
                {
                    "name": "submissiontypeid",
                    "type": "integer",
                    "nullable": false,
                    "default": "nextval('ndb.seq_datasetsubmissiontypes_submissiontypeid'::regclass)",
                    "comment": "An arbitrary Submission Type identification number."
                },
                {
                    "name": "submissiontype",
                    "type": "varchar(80)",
                    "nullable": false,
                    "comment": "Type of submission. The database has the following types:\nOriginal submission from data contributor\nResubmission or revision from data contributor\nCompilation into a flat file database\nCompilation into a another relational database\nRecompilation or revisions to a another relational database\nCompilation into Neotoma from another database\nRecompilation into Neotoma from another database\nCompilation into Neotoma from primary source\nRecompilation into or revisions to Neotoma"
                },
                {
                    "name": "recdatecreated",
                    "type": "timestamp(0) without time zone",
                    "nullable": false,
                    "default": "timezone('UTC'::text, now())"
                },
                {
                    "name": "recdatemodified",
                    "type": "timestamp(0) without time zone",
                    "nullable": false
                }
            ],
            "indexes": [
                {
                    "name": "datasetsubmissiontypes_pkey",
                    "def": "CREATE UNIQUE INDEX datasetsubmissiontypes_pkey ON ndb.datasetsubmissiontypes USING btree (submissiontypeid)",
                    "table": "ndb.datasetsubmissiontypes",
                    "columns": [
                        "submissiontypeid"
                    ]
                }
            ],
            "constraints": [
                {
                    "name": "datasetsubmissiontypes_pkey",
                    "type": "PRIMARY KEY",
                    "def": "PRIMARY KEY (submissiontypeid)",
                    "table": "ndb.datasetsubmissiontypes",
                    "referenced_table": "",
                    "columns": [
                        "submissiontypeid"
                    ]
                }
            ],
            "triggers": [
                {
                    "name": "tr_sites_modifydate",
                    "def": "CREATE TRIGGER tr_sites_modifydate BEFORE INSERT OR UPDATE ON ndb.datasetsubmissiontypes FOR EACH ROW EXECUTE FUNCTION ndb.update_recdatemodified()"
                }
            ]
        },
        {
            "name": "ndb.datasettaxonnotes",
            "type": "BASE TABLE",
            "columns": [
                {
                    "name": "datasetid",
                    "type": "integer",
                    "nullable": false
                },
                {
                    "name": "taxonid",
                    "type": "integer",
                    "nullable": false
                },
                {
                    "name": "contactid",
                    "type": "integer",
                    "nullable": false
                },
                {
                    "name": "date",
                    "type": "date",
                    "nullable": false
                },
                {
                    "name": "notes",
                    "type": "text",
                    "nullable": false
                },
                {
                    "name": "recdatecreated",
                    "type": "timestamp(0) without time zone",
                    "nullable": false,
                    "default": "timezone('UTC'::text, now())"
                },
                {
                    "name": "recdatemodified",
                    "type": "timestamp(0) without time zone",
                    "nullable": false
                }
            ],
            "indexes": [
                {
                    "name": "datasettaxonnotes_pkey",
                    "def": "CREATE UNIQUE INDEX datasettaxonnotes_pkey ON ndb.datasettaxonnotes USING btree (datasetid, taxonid)",
                    "table": "ndb.datasettaxonnotes",
                    "columns": [
                        "datasetid",
                        "taxonid"
                    ]
                }
            ],
            "constraints": [
                {
                    "name": "fk_datasettaxonnotes_contacts",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (contactid) REFERENCES ndb.contacts(contactid)",
                    "table": "ndb.datasettaxonnotes",
                    "referenced_table": "contacts",
                    "columns": [
                        "contactid"
                    ],
                    "referenced_columns": [
                        "contactid"
                    ]
                },
                {
                    "name": "fk_datasettaxonnotes_datasets",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (datasetid) REFERENCES ndb.datasets(datasetid) ON UPDATE CASCADE ON DELETE CASCADE",
                    "table": "ndb.datasettaxonnotes",
                    "referenced_table": "datasets",
                    "columns": [
                        "datasetid"
                    ],
                    "referenced_columns": [
                        "datasetid"
                    ]
                },
                {
                    "name": "datasettaxonnotes_pkey",
                    "type": "PRIMARY KEY",
                    "def": "PRIMARY KEY (datasetid, taxonid)",
                    "table": "ndb.datasettaxonnotes",
                    "referenced_table": "",
                    "columns": [
                        "datasetid",
                        "taxonid"
                    ]
                },
                {
                    "name": "fk_datasettaxonnotes_taxa",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (taxonid) REFERENCES ndb.taxa(taxonid) ON UPDATE CASCADE ON DELETE CASCADE",
                    "table": "ndb.datasettaxonnotes",
                    "referenced_table": "taxa",
                    "columns": [
                        "taxonid"
                    ],
                    "referenced_columns": [
                        "taxonid"
                    ]
                }
            ],
            "triggers": [
                {
                    "name": "tr_sites_modifydate",
                    "def": "CREATE TRIGGER tr_sites_modifydate BEFORE INSERT OR UPDATE ON ndb.datasettaxonnotes FOR EACH ROW EXECUTE FUNCTION ndb.update_recdatemodified()"
                }
            ]
        },
        {
            "name": "ndb.datasetvariables",
            "type": "BASE TABLE",
            "columns": [
                {
                    "name": "datasetvariableid",
                    "type": "integer",
                    "nullable": false,
                    "default": "nextval('ndb.seq_datasetvariables_datasetvariableid'::regclass)"
                },
                {
                    "name": "datasetid",
                    "type": "integer",
                    "nullable": false
                },
                {
                    "name": "variableid",
                    "type": "integer",
                    "nullable": false
                },
                {
                    "name": "recdatecreated",
                    "type": "timestamp(0) without time zone",
                    "nullable": false,
                    "default": "timezone('UTC'::text, now())"
                },
                {
                    "name": "recdatemodified",
                    "type": "timestamp(0) without time zone",
                    "nullable": false
                }
            ],
            "indexes": [
                {
                    "name": "datasetvariables_pkey",
                    "def": "CREATE UNIQUE INDEX datasetvariables_pkey ON ndb.datasetvariables USING btree (datasetvariableid)",
                    "table": "ndb.datasetvariables",
                    "columns": [
                        "datasetvariableid"
                    ]
                }
            ],
            "constraints": [
                {
                    "name": "fk_datasetvariables_datasets",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (datasetid) REFERENCES ndb.datasets(datasetid) ON UPDATE CASCADE ON DELETE CASCADE",
                    "table": "ndb.datasetvariables",
                    "referenced_table": "datasets",
                    "columns": [
                        "datasetid"
                    ],
                    "referenced_columns": [
                        "datasetid"
                    ]
                },
                {
                    "name": "datasetvariables_pkey",
                    "type": "PRIMARY KEY",
                    "def": "PRIMARY KEY (datasetvariableid)",
                    "table": "ndb.datasetvariables",
                    "referenced_table": "",
                    "columns": [
                        "datasetvariableid"
                    ]
                },
                {
                    "name": "fk_datasetvariables_variables",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (variableid) REFERENCES ndb.variables(variableid) ON UPDATE CASCADE ON DELETE CASCADE",
                    "table": "ndb.datasetvariables",
                    "referenced_table": "variables",
                    "columns": [
                        "variableid"
                    ],
                    "referenced_columns": [
                        "variableid"
                    ]
                }
            ],
            "triggers": [
                {
                    "name": "tr_sites_modifydate",
                    "def": "CREATE TRIGGER tr_sites_modifydate BEFORE INSERT OR UPDATE ON ndb.datasetvariables FOR EACH ROW EXECUTE FUNCTION ndb.update_recdatemodified()"
                }
            ]
        },
        {
            "name": "ndb.datataxonnotes",
            "type": "BASE TABLE",
            "columns": [
                {
                    "name": "datataxonnotesid",
                    "type": "integer",
                    "nullable": false,
                    "default": "nextval('ndb.seq_datataxonnotes_datataxonnotesid'::regclass)"
                },
                {
                    "name": "dataid",
                    "type": "integer",
                    "nullable": false
                },
                {
                    "name": "contactid",
                    "type": "integer",
                    "nullable": false
                },
                {
                    "name": "date",
                    "type": "date",
                    "nullable": false
                },
                {
                    "name": "notes",
                    "type": "text",
                    "nullable": false
                },
                {
                    "name": "recdatecreated",
                    "type": "timestamp(0) without time zone",
                    "nullable": false,
                    "default": "timezone('UTC'::text, now())"
                },
                {
                    "name": "recdatemodified",
                    "type": "timestamp(0) without time zone",
                    "nullable": false
                }
            ],
            "indexes": [
                {
                    "name": "datataxonnotes_pkey",
                    "def": "CREATE UNIQUE INDEX datataxonnotes_pkey ON ndb.datataxonnotes USING btree (datataxonnotesid)",
                    "table": "ndb.datataxonnotes",
                    "columns": [
                        "datataxonnotesid"
                    ]
                }
            ],
            "constraints": [
                {
                    "name": "fk_datataxonnotes_contacts",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (contactid) REFERENCES ndb.contacts(contactid)",
                    "table": "ndb.datataxonnotes",
                    "referenced_table": "contacts",
                    "columns": [
                        "contactid"
                    ],
                    "referenced_columns": [
                        "contactid"
                    ]
                },
                {
                    "name": "fk_datataxonnotes_data",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (dataid) REFERENCES ndb.data(dataid) ON UPDATE CASCADE ON DELETE CASCADE",
                    "table": "ndb.datataxonnotes",
                    "referenced_table": "data",
                    "columns": [
                        "dataid"
                    ],
                    "referenced_columns": [
                        "dataid"
                    ]
                },
                {
                    "name": "datataxonnotes_pkey",
                    "type": "PRIMARY KEY",
                    "def": "PRIMARY KEY (datataxonnotesid)",
                    "table": "ndb.datataxonnotes",
                    "referenced_table": "",
                    "columns": [
                        "datataxonnotesid"
                    ]
                }
            ],
            "triggers": [
                {
                    "name": "tr_sites_modifydate",
                    "def": "CREATE TRIGGER tr_sites_modifydate BEFORE INSERT OR UPDATE ON ndb.datataxonnotes FOR EACH ROW EXECUTE FUNCTION ndb.update_recdatemodified()"
                }
            ]
        },
        {
            "name": "ndb.depagents",
            "type": "BASE TABLE",
            "comment": "Deposition Agents for Analysis Units. Individual Analysis Units may be listed multiple times with different Deposition Agents.",
            "columns": [
                {
                    "name": "analysisunitid",
                    "type": "integer",
                    "nullable": false,
                    "comment": "Analysis Unit identification number. Field links to AnalysisUnits table."
                },
                {
                    "name": "depagentid",
                    "type": "integer",
                    "nullable": false,
                    "comment": "Deposition Agent identification number. Field links to DepAgentTypes table."
                },
                {
                    "name": "recdatecreated",
                    "type": "timestamp(0) without time zone",
                    "nullable": false,
                    "default": "timezone('UTC'::text, now())"
                },
                {
                    "name": "recdatemodified",
                    "type": "timestamp(0) without time zone",
                    "nullable": false
                }
            ],
            "indexes": [
                {
                    "name": "depagents_pkey",
                    "def": "CREATE UNIQUE INDEX depagents_pkey ON ndb.depagents USING btree (analysisunitid, depagentid)",
                    "table": "ndb.depagents",
                    "columns": [
                        "analysisunitid",
                        "depagentid"
                    ]
                },
                {
                    "name": "ix_analysisunitid_depagents",
                    "def": "CREATE INDEX ix_analysisunitid_depagents ON ndb.depagents USING btree (analysisunitid) WITH (fillfactor='10')",
                    "table": "ndb.depagents",
                    "columns": [
                        "analysisunitid"
                    ]
                },
                {
                    "name": "ix_depagentid_depagents",
                    "def": "CREATE INDEX ix_depagentid_depagents ON ndb.depagents USING btree (depagentid) WITH (fillfactor='10')",
                    "table": "ndb.depagents",
                    "columns": [
                        "depagentid"
                    ]
                }
            ],
            "constraints": [
                {
                    "name": "fk_depagents_analysisunits",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (analysisunitid) REFERENCES ndb.analysisunits(analysisunitid) ON UPDATE CASCADE ON DELETE CASCADE",
                    "table": "ndb.depagents",
                    "referenced_table": "analysisunits",
                    "columns": [
                        "analysisunitid"
                    ],
                    "referenced_columns": [
                        "analysisunitid"
                    ]
                },
                {
                    "name": "depagents_pkey",
                    "type": "PRIMARY KEY",
                    "def": "PRIMARY KEY (analysisunitid, depagentid)",
                    "table": "ndb.depagents",
                    "referenced_table": "",
                    "columns": [
                        "analysisunitid",
                        "depagentid"
                    ]
                },
                {
                    "name": "fk_depagents_depagenttypes",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (depagentid) REFERENCES ndb.depagenttypes(depagentid) ON UPDATE CASCADE ON DELETE CASCADE",
                    "table": "ndb.depagents",
                    "referenced_table": "depagenttypes",
                    "columns": [
                        "depagentid"
                    ],
                    "referenced_columns": [
                        "depagentid"
                    ]
                }
            ],
            "triggers": [
                {
                    "name": "tr_sites_modifydate",
                    "def": "CREATE TRIGGER tr_sites_modifydate BEFORE INSERT OR UPDATE ON ndb.depagents FOR EACH ROW EXECUTE FUNCTION ndb.update_recdatemodified()"
                }
            ]
        },
        {
            "name": "ndb.depagenttypes",
            "type": "BASE TABLE",
            "comment": "Lookup table of Depositional Agents. Table is referenced by the DepAgents table.",
            "columns": [
                {
                    "name": "depagentid",
                    "type": "integer",
                    "nullable": false,
                    "default": "nextval('ndb.seq_depagenttypes_depagentid'::regclass)",
                    "comment": "An arbitrary Depositional Agent identification number."
                },
                {
                    "name": "depagent",
                    "type": "varchar(64)",
                    "nullable": true,
                    "comment": "Depositional Agent."
                },
                {
                    "name": "recdatecreated",
                    "type": "timestamp(0) without time zone",
                    "nullable": false,
                    "default": "timezone('UTC'::text, now())"
                },
                {
                    "name": "recdatemodified",
                    "type": "timestamp(0) without time zone",
                    "nullable": false
                }
            ],
            "indexes": [
                {
                    "name": "depagenttypes_pkey",
                    "def": "CREATE UNIQUE INDEX depagenttypes_pkey ON ndb.depagenttypes USING btree (depagentid)",
                    "table": "ndb.depagenttypes",
                    "columns": [
                        "depagentid"
                    ]
                }
            ],
            "constraints": [
                {
                    "name": "depagenttypes_pkey",
                    "type": "PRIMARY KEY",
                    "def": "PRIMARY KEY (depagentid)",
                    "table": "ndb.depagenttypes",
                    "referenced_table": "",
                    "columns": [
                        "depagentid"
                    ]
                }
            ],
            "triggers": [
                {
                    "name": "tr_sites_modifydate",
                    "def": "CREATE TRIGGER tr_sites_modifydate BEFORE INSERT OR UPDATE ON ndb.depagenttypes FOR EACH ROW EXECUTE FUNCTION ndb.update_recdatemodified()"
                }
            ]
        },
        {
            "name": "ndb.depenvttypes",
            "type": "BASE TABLE",
            "comment": "Lookup table of Depositional Environment Types. Table is referenced by the CollectionUnits table.",
            "columns": [
                {
                    "name": "depenvtid",
                    "type": "integer",
                    "nullable": false,
                    "default": "nextval('ndb.seq_depenvttypes_depenvtid'::regclass)",
                    "comment": "An arbitrary Depositional Environment Type identification number."
                },
                {
                    "name": "depenvt",
                    "type": "varchar(255)",
                    "nullable": false,
                    "comment": "Depositional Environment."
                },
                {
                    "name": "depenvthigherid",
                    "type": "integer",
                    "nullable": false,
                    "comment": "The Depositional Environment Types are hierarchical. DepEnvtHigherID is the DepEnvtID of the higher ranked Depositional Environment. The following table gives some examples."
                },
                {
                    "name": "recdatecreated",
                    "type": "timestamp(0) without time zone",
                    "nullable": false,
                    "default": "timezone('UTC'::text, now())"
                },
                {
                    "name": "recdatemodified",
                    "type": "timestamp(0) without time zone",
                    "nullable": false
                }
            ],
            "indexes": [
                {
                    "name": "depenvttypes_pkey",
                    "def": "CREATE UNIQUE INDEX depenvttypes_pkey ON ndb.depenvttypes USING btree (depenvtid)",
                    "table": "ndb.depenvttypes",
                    "columns": [
                        "depenvtid"
                    ]
                }
            ],
            "constraints": [
                {
                    "name": "depenvttypes_pkey",
                    "type": "PRIMARY KEY",
                    "def": "PRIMARY KEY (depenvtid)",
                    "table": "ndb.depenvttypes",
                    "referenced_table": "",
                    "columns": [
                        "depenvtid"
                    ]
                },
                {
                    "name": "fk_depenvthigherid",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (depenvthigherid) REFERENCES ndb.depenvttypes(depenvtid)",
                    "table": "ndb.depenvttypes",
                    "referenced_table": "depenvttypes",
                    "columns": [
                        "depenvthigherid"
                    ],
                    "referenced_columns": [
                        "depenvtid"
                    ]
                }
            ],
            "triggers": [
                {
                    "name": "tr_sites_modifydate",
                    "def": "CREATE TRIGGER tr_sites_modifydate BEFORE INSERT OR UPDATE ON ndb.depenvttypes FOR EACH ROW EXECUTE FUNCTION ndb.update_recdatemodified()"
                }
            ]
        },
        {
            "name": "ndb.dsageranges",
            "type": "VIEW",
            "columns": [
                {
                    "name": "datasetid",
                    "type": "integer",
                    "nullable": true
                },
                {
                    "name": "younger",
                    "type": "double precision",
                    "nullable": true
                },
                {
                    "name": "older",
                    "type": "double precision",
                    "nullable": true
                },
                {
                    "name": "agetypeid",
                    "type": "integer",
                    "nullable": true
                }
            ],
            "def": "CREATE VIEW dsageranges AS (\n SELECT ageranges.datasetid,\n    min(ageranges.younger) AS younger,\n    max(ageranges.older) AS older,\n    ageranges.agetypeid\n   FROM ( SELECT ds.datasetid,\n                CASE\n                    WHEN (ages.ageyounger IS NULL) THEN ages.age\n                    ELSE ages.ageyounger\n                END AS younger,\n                CASE\n                    WHEN (ages.ageolder IS NULL) THEN ages.age\n                    ELSE ages.ageolder\n                END AS older,\n            chrons.agetypeid\n           FROM (((ndb.samples samples\n             LEFT JOIN ndb.datasets ds ON ((samples.datasetid = ds.datasetid)))\n             LEFT JOIN ndb.sampleages ages ON ((ages.sampleid = samples.sampleid)))\n             LEFT JOIN ndb.chronologies chrons ON ((ages.chronologyid = chrons.chronologyid)))\n          WHERE (chrons.isdefault = (1)::boolean)) ageranges\n  GROUP BY ageranges.datasetid, ageranges.agetypeid\n)",
            "referenced_tables": [
                "ndb.samples",
                "ndb.datasets",
                "ndb.sampleages",
                "ndb.chronologies"
            ]
        },
        {
            "name": "ndb.dsdatasample",
            "type": "VIEW",
            "columns": [
                {
                    "name": "datasetid",
                    "type": "integer",
                    "nullable": true
                },
                {
                    "name": "sampleid",
                    "type": "integer",
                    "nullable": true
                },
                {
                    "name": "dataid",
                    "type": "integer",
                    "nullable": true
                },
                {
                    "name": "variableid",
                    "type": "integer",
                    "nullable": true
                }
            ],
            "def": "CREATE VIEW dsdatasample AS (\n SELECT ds.datasetid,\n    sm.sampleid,\n    dt.dataid,\n    vr.variableid\n   FROM (((ndb.datasets ds\n     JOIN ndb.samples sm ON ((ds.datasetid = sm.datasetid)))\n     JOIN ndb.data dt ON ((sm.sampleid = dt.sampleid)))\n     JOIN ndb.variables vr ON ((dt.variableid = vr.variableid)))\n)",
            "referenced_tables": [
                "ndb.datasets",
                "ndb.samples",
                "ndb.data",
                "ndb.variables"
            ]
        },
        {
            "name": "ndb.dslinks",
            "type": "VIEW",
            "columns": [
                {
                    "name": "datasetid",
                    "type": "integer",
                    "nullable": true
                },
                {
                    "name": "collectionunitid",
                    "type": "integer",
                    "nullable": true
                },
                {
                    "name": "siteid",
                    "type": "integer",
                    "nullable": true
                }
            ],
            "def": "CREATE VIEW dslinks AS (\n SELECT ds.datasetid,\n    ds.collectionunitid,\n    sts.siteid\n   FROM ((ndb.datasets ds\n     LEFT JOIN ndb.collectionunits cu ON ((ds.collectionunitid = cu.collectionunitid)))\n     LEFT JOIN ndb.sites sts ON ((cu.siteid = sts.siteid)))\n)",
            "referenced_tables": [
                "ndb.datasets",
                "ndb.collectionunits",
                "ndb.sites"
            ]
        },
        {
            "name": "ndb.dssampdata",
            "type": "VIEW",
            "columns": [
                {
                    "name": "datasetid",
                    "type": "integer",
                    "nullable": true
                },
                {
                    "name": "samples",
                    "type": "bigint",
                    "nullable": true
                },
                {
                    "name": "observations",
                    "type": "bigint",
                    "nullable": true
                }
            ],
            "def": "CREATE VIEW dssampdata AS (\n SELECT ds.datasetid,\n    count(DISTINCT smp.sampleid) AS samples,\n    count(DISTINCT dt.dataid) AS observations\n   FROM ((ndb.datasets ds\n     LEFT JOIN ndb.samples smp ON ((smp.datasetid = ds.datasetid)))\n     LEFT JOIN ndb.data dt ON ((dt.sampleid = smp.sampleid)))\n  GROUP BY ds.datasetid\n)",
            "referenced_tables": [
                "ndb.datasets",
                "ndb.samples",
                "ndb.data"
            ]
        },
        {
            "name": "ndb.ecolgroups",
            "type": "BASE TABLE",
            "comment": "Taxa are assigned to Sets of Ecological Groups. A taxon may be assigned to more than one Set of Ecological Groups, representing different schemes for organizing taxa.",
            "columns": [
                {
                    "name": "taxonid",
                    "type": "integer",
                    "nullable": false,
                    "comment": "Taxon identification number. Field links to the Taxa table."
                },
                {
                    "name": "ecolsetid",
                    "type": "integer",
                    "nullable": false,
                    "comment": "Ecological Set identification number. Field links to the EcolSetTypes table."
                },
                {
                    "name": "ecolgroupid",
                    "type": "varchar(4)",
                    "nullable": false,
                    "comment": "A four-letter Ecological Group identification code. Field links to the EcolGroupTypes table."
                },
                {
                    "name": "recdatecreated",
                    "type": "timestamp(0) without time zone",
                    "nullable": false,
                    "default": "timezone('UTC'::text, now())"
                },
                {
                    "name": "recdatemodified",
                    "type": "timestamp(0) without time zone",
                    "nullable": false
                }
            ],
            "indexes": [
                {
                    "name": "ecolgroups_pkey",
                    "def": "CREATE UNIQUE INDEX ecolgroups_pkey ON ndb.ecolgroups USING btree (taxonid, ecolsetid)",
                    "table": "ndb.ecolgroups",
                    "columns": [
                        "taxonid",
                        "ecolsetid"
                    ]
                },
                {
                    "name": "ix_ecolgroupid_ecolgroups",
                    "def": "CREATE INDEX ix_ecolgroupid_ecolgroups ON ndb.ecolgroups USING btree (ecolgroupid) WITH (fillfactor='10')",
                    "table": "ndb.ecolgroups",
                    "columns": [
                        "ecolgroupid"
                    ]
                },
                {
                    "name": "ix_ecolsetid_ecolgroups",
                    "def": "CREATE INDEX ix_ecolsetid_ecolgroups ON ndb.ecolgroups USING btree (ecolsetid) WITH (fillfactor='10')",
                    "table": "ndb.ecolgroups",
                    "columns": [
                        "ecolsetid"
                    ]
                },
                {
                    "name": "ix_taxonid_ecolgroups",
                    "def": "CREATE INDEX ix_taxonid_ecolgroups ON ndb.ecolgroups USING btree (taxonid) WITH (fillfactor='10')",
                    "table": "ndb.ecolgroups",
                    "columns": [
                        "taxonid"
                    ]
                },
                {
                    "name": "ecolgroups_unique",
                    "def": "CREATE UNIQUE INDEX ecolgroups_unique ON ndb.ecolgroups USING btree (taxonid, ecolsetid, ecolgroupid)",
                    "table": "ndb.ecolgroups",
                    "columns": [
                        "taxonid",
                        "ecolsetid",
                        "ecolgroupid"
                    ]
                }
            ],
            "constraints": [
                {
                    "name": "ecolgroups_pkey",
                    "type": "PRIMARY KEY",
                    "def": "PRIMARY KEY (taxonid, ecolsetid)",
                    "table": "ndb.ecolgroups",
                    "referenced_table": "",
                    "columns": [
                        "taxonid",
                        "ecolsetid"
                    ]
                },
                {
                    "name": "fk_ecolgroups_ecolgrouptypes",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (ecolgroupid) REFERENCES ndb.ecolgrouptypes(ecolgroupid) ON UPDATE CASCADE ON DELETE CASCADE",
                    "table": "ndb.ecolgroups",
                    "referenced_table": "ecolgrouptypes",
                    "columns": [
                        "ecolgroupid"
                    ],
                    "referenced_columns": [
                        "ecolgroupid"
                    ]
                },
                {
                    "name": "fk_ecolgroups_ecolsettypes",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (ecolsetid) REFERENCES ndb.ecolsettypes(ecolsetid) ON UPDATE CASCADE ON DELETE CASCADE",
                    "table": "ndb.ecolgroups",
                    "referenced_table": "ecolsettypes",
                    "columns": [
                        "ecolsetid"
                    ],
                    "referenced_columns": [
                        "ecolsetid"
                    ]
                },
                {
                    "name": "fk_ecolgroups_taxa",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (taxonid) REFERENCES ndb.taxa(taxonid) ON UPDATE CASCADE ON DELETE CASCADE",
                    "table": "ndb.ecolgroups",
                    "referenced_table": "taxa",
                    "columns": [
                        "taxonid"
                    ],
                    "referenced_columns": [
                        "taxonid"
                    ]
                },
                {
                    "name": "ecolgroups_unique",
                    "type": "UNIQUE",
                    "def": "UNIQUE (taxonid, ecolsetid, ecolgroupid)",
                    "table": "ndb.ecolgroups",
                    "referenced_table": "",
                    "columns": [
                        "taxonid",
                        "ecolsetid",
                        "ecolgroupid"
                    ]
                }
            ],
            "triggers": [
                {
                    "name": "tr_sites_modifydate",
                    "def": "CREATE TRIGGER tr_sites_modifydate BEFORE INSERT OR UPDATE ON ndb.ecolgroups FOR EACH ROW EXECUTE FUNCTION ndb.update_recdatemodified()"
                }
            ]
        },
        {
            "name": "ndb.ecolgrouptypes",
            "type": "BASE TABLE",
            "comment": "Lookup table of Ecological Group Types. Table is referenced by the EcolGroups table.",
            "columns": [
                {
                    "name": "ecolgroupid",
                    "type": "varchar(4)",
                    "nullable": false,
                    "comment": "An arbitrary Ecological Group identification number."
                },
                {
                    "name": "ecolgroup",
                    "type": "varchar(64)",
                    "nullable": true,
                    "comment": "Ecological Group."
                },
                {
                    "name": "recdatecreated",
                    "type": "timestamp(0) without time zone",
                    "nullable": false,
                    "default": "timezone('UTC'::text, now())"
                },
                {
                    "name": "recdatemodified",
                    "type": "timestamp(0) without time zone",
                    "nullable": false
                }
            ],
            "indexes": [
                {
                    "name": "ecolgrouptypes_pkey",
                    "def": "CREATE UNIQUE INDEX ecolgrouptypes_pkey ON ndb.ecolgrouptypes USING btree (ecolgroupid)",
                    "table": "ndb.ecolgrouptypes",
                    "columns": [
                        "ecolgroupid"
                    ]
                }
            ],
            "constraints": [
                {
                    "name": "ecolgrouptypes_pkey",
                    "type": "PRIMARY KEY",
                    "def": "PRIMARY KEY (ecolgroupid)",
                    "table": "ndb.ecolgrouptypes",
                    "referenced_table": "",
                    "columns": [
                        "ecolgroupid"
                    ]
                }
            ],
            "triggers": [
                {
                    "name": "tr_sites_modifydate",
                    "def": "CREATE TRIGGER tr_sites_modifydate BEFORE INSERT OR UPDATE ON ndb.ecolgrouptypes FOR EACH ROW EXECUTE FUNCTION ndb.update_recdatemodified()"
                }
            ]
        },
        {
            "name": "ndb.ecolsettypes",
            "type": "BASE TABLE",
            "comment": "Lookup table of Ecological Set Types. Table is referenced by the EcolGroups table.",
            "columns": [
                {
                    "name": "ecolsetid",
                    "type": "integer",
                    "nullable": false,
                    "default": "nextval('ndb.seq_ecolsettypes_ecolsetid'::regclass)",
                    "comment": "An arbitrary Ecological Set identification number."
                },
                {
                    "name": "ecolsetname",
                    "type": "varchar(64)",
                    "nullable": false,
                    "comment": "Ecological Set name."
                },
                {
                    "name": "recdatecreated",
                    "type": "timestamp(0) without time zone",
                    "nullable": false,
                    "default": "timezone('UTC'::text, now())"
                },
                {
                    "name": "recdatemodified",
                    "type": "timestamp(0) without time zone",
                    "nullable": false
                }
            ],
            "indexes": [
                {
                    "name": "ecolsettypes_pkey",
                    "def": "CREATE UNIQUE INDEX ecolsettypes_pkey ON ndb.ecolsettypes USING btree (ecolsetid)",
                    "table": "ndb.ecolsettypes",
                    "columns": [
                        "ecolsetid"
                    ]
                }
            ],
            "constraints": [
                {
                    "name": "ecolsettypes_pkey",
                    "type": "PRIMARY KEY",
                    "def": "PRIMARY KEY (ecolsetid)",
                    "table": "ndb.ecolsettypes",
                    "referenced_table": "",
                    "columns": [
                        "ecolsetid"
                    ]
                }
            ],
            "triggers": [
                {
                    "name": "tr_sites_modifydate",
                    "def": "CREATE TRIGGER tr_sites_modifydate BEFORE INSERT OR UPDATE ON ndb.ecolsettypes FOR EACH ROW EXECUTE FUNCTION ndb.update_recdatemodified()"
                }
            ]
        },
        {
            "name": "ndb.elementdatasettaxagroups",
            "type": "BASE TABLE",
            "columns": [
                {
                    "name": "datasettypeid",
                    "type": "integer",
                    "nullable": false
                },
                {
                    "name": "taxagroupid",
                    "type": "varchar(3)",
                    "nullable": false
                },
                {
                    "name": "elementtypeid",
                    "type": "integer",
                    "nullable": false
                },
                {
                    "name": "recdatecreated",
                    "type": "timestamp(0) without time zone",
                    "nullable": false,
                    "default": "timezone('UTC'::text, now())"
                },
                {
                    "name": "recdatemodified",
                    "type": "timestamp(0) without time zone",
                    "nullable": false
                }
            ],
            "indexes": [
                {
                    "name": "elementdatasettaxagroups_pkey",
                    "def": "CREATE UNIQUE INDEX elementdatasettaxagroups_pkey ON ndb.elementdatasettaxagroups USING btree (datasettypeid, taxagroupid, elementtypeid)",
                    "table": "ndb.elementdatasettaxagroups",
                    "columns": [
                        "datasettypeid",
                        "taxagroupid",
                        "elementtypeid"
                    ]
                }
            ],
            "constraints": [
                {
                    "name": "fk_datasettypeid",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (datasettypeid) REFERENCES ndb.datasettypes(datasettypeid)",
                    "table": "ndb.elementdatasettaxagroups",
                    "referenced_table": "datasettypes",
                    "columns": [
                        "datasettypeid"
                    ],
                    "referenced_columns": [
                        "datasettypeid"
                    ]
                },
                {
                    "name": "elementdatasettaxagroups_pkey",
                    "type": "PRIMARY KEY",
                    "def": "PRIMARY KEY (datasettypeid, taxagroupid, elementtypeid)",
                    "table": "ndb.elementdatasettaxagroups",
                    "referenced_table": "",
                    "columns": [
                        "datasettypeid",
                        "taxagroupid",
                        "elementtypeid"
                    ]
                },
                {
                    "name": "edt_group",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (taxagroupid) REFERENCES ndb.taxagrouptypes(taxagroupid)",
                    "table": "ndb.elementdatasettaxagroups",
                    "referenced_table": "taxagrouptypes",
                    "columns": [
                        "taxagroupid"
                    ],
                    "referenced_columns": [
                        "taxagroupid"
                    ]
                }
            ],
            "triggers": [
                {
                    "name": "tr_sites_modifydate",
                    "def": "CREATE TRIGGER tr_sites_modifydate BEFORE INSERT OR UPDATE ON ndb.elementdatasettaxagroups FOR EACH ROW EXECUTE FUNCTION ndb.update_recdatemodified()"
                }
            ]
        },
        {
            "name": "ndb.elementmaturities",
            "type": "BASE TABLE",
            "columns": [
                {
                    "name": "maturityid",
                    "type": "integer",
                    "nullable": false,
                    "default": "nextval('ndb.seq_elementmaturities_maturityid'::regclass)"
                },
                {
                    "name": "maturity",
                    "type": "varchar(36)",
                    "nullable": false
                },
                {
                    "name": "recdatecreated",
                    "type": "timestamp(0) without time zone",
                    "nullable": false,
                    "default": "timezone('UTC'::text, now())"
                },
                {
                    "name": "recdatemodified",
                    "type": "timestamp(0) without time zone",
                    "nullable": false
                }
            ],
            "indexes": [
                {
                    "name": "elementmaturities_pkey",
                    "def": "CREATE UNIQUE INDEX elementmaturities_pkey ON ndb.elementmaturities USING btree (maturityid)",
                    "table": "ndb.elementmaturities",
                    "columns": [
                        "maturityid"
                    ]
                },
                {
                    "name": "ix_elementmaturities",
                    "def": "CREATE UNIQUE INDEX ix_elementmaturities ON ndb.elementmaturities USING btree (maturity) WITH (fillfactor='10')",
                    "table": "ndb.elementmaturities",
                    "columns": [
                        "maturity"
                    ]
                }
            ],
            "constraints": [
                {
                    "name": "elementmaturities_pkey",
                    "type": "PRIMARY KEY",
                    "def": "PRIMARY KEY (maturityid)",
                    "table": "ndb.elementmaturities",
                    "referenced_table": "",
                    "columns": [
                        "maturityid"
                    ]
                }
            ],
            "triggers": [
                {
                    "name": "tr_sites_modifydate",
                    "def": "CREATE TRIGGER tr_sites_modifydate BEFORE INSERT OR UPDATE ON ndb.elementmaturities FOR EACH ROW EXECUTE FUNCTION ndb.update_recdatemodified()"
                }
            ]
        },
        {
            "name": "ndb.elementportions",
            "type": "BASE TABLE",
            "columns": [
                {
                    "name": "portionid",
                    "type": "integer",
                    "nullable": false,
                    "default": "nextval('ndb.seq_elementportions_portionid'::regclass)"
                },
                {
                    "name": "portion",
                    "type": "varchar(48)",
                    "nullable": true
                },
                {
                    "name": "recdatecreated",
                    "type": "timestamp(0) without time zone",
                    "nullable": false,
                    "default": "timezone('UTC'::text, now())"
                },
                {
                    "name": "recdatemodified",
                    "type": "timestamp(0) without time zone",
                    "nullable": false
                }
            ],
            "indexes": [
                {
                    "name": "elementportions_pkey",
                    "def": "CREATE UNIQUE INDEX elementportions_pkey ON ndb.elementportions USING btree (portionid)",
                    "table": "ndb.elementportions",
                    "columns": [
                        "portionid"
                    ]
                },
                {
                    "name": "ix_elementportions",
                    "def": "CREATE UNIQUE INDEX ix_elementportions ON ndb.elementportions USING btree (portion) WITH (fillfactor='10')",
                    "table": "ndb.elementportions",
                    "columns": [
                        "portion"
                    ]
                }
            ],
            "constraints": [
                {
                    "name": "elementportions_pkey",
                    "type": "PRIMARY KEY",
                    "def": "PRIMARY KEY (portionid)",
                    "table": "ndb.elementportions",
                    "referenced_table": "",
                    "columns": [
                        "portionid"
                    ]
                }
            ],
            "triggers": [
                {
                    "name": "tr_sites_modifydate",
                    "def": "CREATE TRIGGER tr_sites_modifydate BEFORE INSERT OR UPDATE ON ndb.elementportions FOR EACH ROW EXECUTE FUNCTION ndb.update_recdatemodified()"
                }
            ]
        },
        {
            "name": "ndb.elementsymmetries",
            "type": "BASE TABLE",
            "columns": [
                {
                    "name": "symmetryid",
                    "type": "integer",
                    "nullable": false,
                    "default": "nextval('ndb.seq_elementsymmetries_symmetryid'::regclass)"
                },
                {
                    "name": "symmetry",
                    "type": "varchar(24)",
                    "nullable": false
                },
                {
                    "name": "recdatecreated",
                    "type": "timestamp(0) without time zone",
                    "nullable": false,
                    "default": "timezone('UTC'::text, now())"
                },
                {
                    "name": "recdatemodified",
                    "type": "timestamp(0) without time zone",
                    "nullable": false
                }
            ],
            "indexes": [
                {
                    "name": "elementsymmetries_pkey",
                    "def": "CREATE UNIQUE INDEX elementsymmetries_pkey ON ndb.elementsymmetries USING btree (symmetryid)",
                    "table": "ndb.elementsymmetries",
                    "columns": [
                        "symmetryid"
                    ]
                },
                {
                    "name": "ix_elementsymmetries",
                    "def": "CREATE UNIQUE INDEX ix_elementsymmetries ON ndb.elementsymmetries USING btree (symmetry) WITH (fillfactor='10')",
                    "table": "ndb.elementsymmetries",
                    "columns": [
                        "symmetry"
                    ]
                }
            ],
            "constraints": [
                {
                    "name": "elementsymmetries_pkey",
                    "type": "PRIMARY KEY",
                    "def": "PRIMARY KEY (symmetryid)",
                    "table": "ndb.elementsymmetries",
                    "referenced_table": "",
                    "columns": [
                        "symmetryid"
                    ]
                }
            ],
            "triggers": [
                {
                    "name": "tr_sites_modifydate",
                    "def": "CREATE TRIGGER tr_sites_modifydate BEFORE INSERT OR UPDATE ON ndb.elementsymmetries FOR EACH ROW EXECUTE FUNCTION ndb.update_recdatemodified()"
                }
            ]
        },
        {
            "name": "ndb.elementtaxagroupmaturities",
            "type": "BASE TABLE",
            "columns": [
                {
                    "name": "elementtaxagroupid",
                    "type": "integer",
                    "nullable": false
                },
                {
                    "name": "maturityid",
                    "type": "integer",
                    "nullable": false
                },
                {
                    "name": "recdatecreated",
                    "type": "timestamp(0) without time zone",
                    "nullable": false,
                    "default": "timezone('UTC'::text, now())"
                },
                {
                    "name": "recdatemodified",
                    "type": "timestamp(0) without time zone",
                    "nullable": false
                }
            ],
            "indexes": [
                {
                    "name": "elementtaxagroupmaturities_pkey",
                    "def": "CREATE UNIQUE INDEX elementtaxagroupmaturities_pkey ON ndb.elementtaxagroupmaturities USING btree (elementtaxagroupid, maturityid)",
                    "table": "ndb.elementtaxagroupmaturities",
                    "columns": [
                        "elementtaxagroupid",
                        "maturityid"
                    ]
                }
            ],
            "constraints": [
                {
                    "name": "fk_elementtaxagroupmaturities_elementmaturities",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (maturityid) REFERENCES ndb.elementmaturities(maturityid) ON UPDATE CASCADE ON DELETE CASCADE",
                    "table": "ndb.elementtaxagroupmaturities",
                    "referenced_table": "elementmaturities",
                    "columns": [
                        "maturityid"
                    ],
                    "referenced_columns": [
                        "maturityid"
                    ]
                },
                {
                    "name": "elementtaxagroupmaturities_pkey",
                    "type": "PRIMARY KEY",
                    "def": "PRIMARY KEY (elementtaxagroupid, maturityid)",
                    "table": "ndb.elementtaxagroupmaturities",
                    "referenced_table": "",
                    "columns": [
                        "elementtaxagroupid",
                        "maturityid"
                    ]
                },
                {
                    "name": "fk_elementtaxagroupmaturities_elementtaxagroup",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (elementtaxagroupid) REFERENCES ndb.elementtaxagroups(elementtaxagroupid) ON UPDATE CASCADE ON DELETE CASCADE",
                    "table": "ndb.elementtaxagroupmaturities",
                    "referenced_table": "elementtaxagroups",
                    "columns": [
                        "elementtaxagroupid"
                    ],
                    "referenced_columns": [
                        "elementtaxagroupid"
                    ]
                }
            ],
            "triggers": [
                {
                    "name": "tr_sites_modifydate",
                    "def": "CREATE TRIGGER tr_sites_modifydate BEFORE INSERT OR UPDATE ON ndb.elementtaxagroupmaturities FOR EACH ROW EXECUTE FUNCTION ndb.update_recdatemodified()"
                }
            ]
        },
        {
            "name": "ndb.elementtaxagroupportions",
            "type": "BASE TABLE",
            "columns": [
                {
                    "name": "elementtaxagroupid",
                    "type": "integer",
                    "nullable": false
                },
                {
                    "name": "portionid",
                    "type": "integer",
                    "nullable": false
                },
                {
                    "name": "recdatecreated",
                    "type": "timestamp(0) without time zone",
                    "nullable": false,
                    "default": "timezone('UTC'::text, now())"
                },
                {
                    "name": "recdatemodified",
                    "type": "timestamp(0) without time zone",
                    "nullable": false
                }
            ],
            "indexes": [
                {
                    "name": "elementtaxagroupportions_pkey",
                    "def": "CREATE UNIQUE INDEX elementtaxagroupportions_pkey ON ndb.elementtaxagroupportions USING btree (elementtaxagroupid, portionid)",
                    "table": "ndb.elementtaxagroupportions",
                    "columns": [
                        "elementtaxagroupid",
                        "portionid"
                    ]
                }
            ],
            "constraints": [
                {
                    "name": "fk_elementtaxagroupportions_elementportions",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (portionid) REFERENCES ndb.elementportions(portionid) ON UPDATE CASCADE ON DELETE CASCADE",
                    "table": "ndb.elementtaxagroupportions",
                    "referenced_table": "elementportions",
                    "columns": [
                        "portionid"
                    ],
                    "referenced_columns": [
                        "portionid"
                    ]
                },
                {
                    "name": "elementtaxagroupportions_pkey",
                    "type": "PRIMARY KEY",
                    "def": "PRIMARY KEY (elementtaxagroupid, portionid)",
                    "table": "ndb.elementtaxagroupportions",
                    "referenced_table": "",
                    "columns": [
                        "elementtaxagroupid",
                        "portionid"
                    ]
                },
                {
                    "name": "fk_elementtaxagroupportions_elementtaxagroups",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (elementtaxagroupid) REFERENCES ndb.elementtaxagroups(elementtaxagroupid) ON UPDATE CASCADE ON DELETE CASCADE",
                    "table": "ndb.elementtaxagroupportions",
                    "referenced_table": "elementtaxagroups",
                    "columns": [
                        "elementtaxagroupid"
                    ],
                    "referenced_columns": [
                        "elementtaxagroupid"
                    ]
                }
            ],
            "triggers": [
                {
                    "name": "tr_sites_modifydate",
                    "def": "CREATE TRIGGER tr_sites_modifydate BEFORE INSERT OR UPDATE ON ndb.elementtaxagroupportions FOR EACH ROW EXECUTE FUNCTION ndb.update_recdatemodified()"
                }
            ]
        },
        {
            "name": "ndb.elementtaxagroups",
            "type": "BASE TABLE",
            "columns": [
                {
                    "name": "elementtaxagroupid",
                    "type": "integer",
                    "nullable": false,
                    "default": "nextval('ndb.seq_elementtaxagroups_elementtaxagroupid'::regclass)"
                },
                {
                    "name": "taxagroupid",
                    "type": "varchar(3)",
                    "nullable": false
                },
                {
                    "name": "elementtypeid",
                    "type": "integer",
                    "nullable": false
                },
                {
                    "name": "recdatecreated",
                    "type": "timestamp(0) without time zone",
                    "nullable": false,
                    "default": "timezone('UTC'::text, now())"
                },
                {
                    "name": "recdatemodified",
                    "type": "timestamp(0) without time zone",
                    "nullable": false
                }
            ],
            "indexes": [
                {
                    "name": "elementtaxagroups_pkey",
                    "def": "CREATE UNIQUE INDEX elementtaxagroups_pkey ON ndb.elementtaxagroups USING btree (elementtaxagroupid)",
                    "table": "ndb.elementtaxagroups",
                    "columns": [
                        "elementtaxagroupid"
                    ]
                },
                {
                    "name": "ix_elementtaxagrouptypes",
                    "def": "CREATE UNIQUE INDEX ix_elementtaxagrouptypes ON ndb.elementtaxagroups USING btree (taxagroupid, elementtypeid) WITH (fillfactor='10')",
                    "table": "ndb.elementtaxagroups",
                    "columns": [
                        "taxagroupid",
                        "elementtypeid"
                    ]
                }
            ],
            "constraints": [
                {
                    "name": "elementtaxagroups_pkey",
                    "type": "PRIMARY KEY",
                    "def": "PRIMARY KEY (elementtaxagroupid)",
                    "table": "ndb.elementtaxagroups",
                    "referenced_table": "",
                    "columns": [
                        "elementtaxagroupid"
                    ]
                },
                {
                    "name": "fk_elementtaxagrouptypes_elementtypes",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (elementtypeid) REFERENCES ndb.elementtypes(elementtypeid) ON UPDATE CASCADE ON DELETE CASCADE",
                    "table": "ndb.elementtaxagroups",
                    "referenced_table": "elementtypes",
                    "columns": [
                        "elementtypeid"
                    ],
                    "referenced_columns": [
                        "elementtypeid"
                    ]
                },
                {
                    "name": "fk_elementtaxagrouptypes_taxagrouptypes",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (taxagroupid) REFERENCES ndb.taxagrouptypes(taxagroupid) ON UPDATE CASCADE ON DELETE CASCADE",
                    "table": "ndb.elementtaxagroups",
                    "referenced_table": "taxagrouptypes",
                    "columns": [
                        "taxagroupid"
                    ],
                    "referenced_columns": [
                        "taxagroupid"
                    ]
                }
            ],
            "triggers": [
                {
                    "name": "tr_sites_modifydate",
                    "def": "CREATE TRIGGER tr_sites_modifydate BEFORE INSERT OR UPDATE ON ndb.elementtaxagroups FOR EACH ROW EXECUTE FUNCTION ndb.update_recdatemodified()"
                }
            ]
        },
        {
            "name": "ndb.elementtaxagroupsymmetries",
            "type": "BASE TABLE",
            "columns": [
                {
                    "name": "elementtaxagroupid",
                    "type": "integer",
                    "nullable": false
                },
                {
                    "name": "symmetryid",
                    "type": "integer",
                    "nullable": false
                },
                {
                    "name": "recdatecreated",
                    "type": "timestamp(0) without time zone",
                    "nullable": false,
                    "default": "timezone('UTC'::text, now())"
                },
                {
                    "name": "recdatemodified",
                    "type": "timestamp(0) without time zone",
                    "nullable": false
                }
            ],
            "indexes": [
                {
                    "name": "elementtaxagroupsymmetries_pkey",
                    "def": "CREATE UNIQUE INDEX elementtaxagroupsymmetries_pkey ON ndb.elementtaxagroupsymmetries USING btree (elementtaxagroupid, symmetryid)",
                    "table": "ndb.elementtaxagroupsymmetries",
                    "columns": [
                        "elementtaxagroupid",
                        "symmetryid"
                    ]
                }
            ],
            "constraints": [
                {
                    "name": "fk_elementtaxagroupsymmetries_elementsymmetries",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (symmetryid) REFERENCES ndb.elementsymmetries(symmetryid) ON UPDATE CASCADE ON DELETE CASCADE",
                    "table": "ndb.elementtaxagroupsymmetries",
                    "referenced_table": "elementsymmetries",
                    "columns": [
                        "symmetryid"
                    ],
                    "referenced_columns": [
                        "symmetryid"
                    ]
                },
                {
                    "name": "fk_elementtaxagroupsymmetries_elementtaxagroups",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (elementtaxagroupid) REFERENCES ndb.elementtaxagroups(elementtaxagroupid) ON UPDATE CASCADE ON DELETE CASCADE",
                    "table": "ndb.elementtaxagroupsymmetries",
                    "referenced_table": "elementtaxagroups",
                    "columns": [
                        "elementtaxagroupid"
                    ],
                    "referenced_columns": [
                        "elementtaxagroupid"
                    ]
                },
                {
                    "name": "elementtaxagroupsymmetries_pkey",
                    "type": "PRIMARY KEY",
                    "def": "PRIMARY KEY (elementtaxagroupid, symmetryid)",
                    "table": "ndb.elementtaxagroupsymmetries",
                    "referenced_table": "",
                    "columns": [
                        "elementtaxagroupid",
                        "symmetryid"
                    ]
                }
            ],
            "triggers": [
                {
                    "name": "tr_sites_modifydate",
                    "def": "CREATE TRIGGER tr_sites_modifydate BEFORE INSERT OR UPDATE ON ndb.elementtaxagroupsymmetries FOR EACH ROW EXECUTE FUNCTION ndb.update_recdatemodified()"
                }
            ]
        },
        {
            "name": "ndb.elementtypes",
            "type": "BASE TABLE",
            "columns": [
                {
                    "name": "elementtypeid",
                    "type": "integer",
                    "nullable": false,
                    "default": "nextval('ndb.seq_elementtypes_elementtypeid'::regclass)"
                },
                {
                    "name": "elementtype",
                    "type": "varchar(64)",
                    "nullable": false
                },
                {
                    "name": "recdatecreated",
                    "type": "timestamp(0) without time zone",
                    "nullable": false,
                    "default": "timezone('UTC'::text, now())"
                },
                {
                    "name": "recdatemodified",
                    "type": "timestamp(0) without time zone",
                    "nullable": false
                }
            ],
            "indexes": [
                {
                    "name": "elementtypes_pkey",
                    "def": "CREATE UNIQUE INDEX elementtypes_pkey ON ndb.elementtypes USING btree (elementtypeid)",
                    "table": "ndb.elementtypes",
                    "columns": [
                        "elementtypeid"
                    ]
                },
                {
                    "name": "ix_elementtypes",
                    "def": "CREATE UNIQUE INDEX ix_elementtypes ON ndb.elementtypes USING btree (elementtype) WITH (fillfactor='10')",
                    "table": "ndb.elementtypes",
                    "columns": [
                        "elementtype"
                    ]
                }
            ],
            "constraints": [
                {
                    "name": "elementtypes_pkey",
                    "type": "PRIMARY KEY",
                    "def": "PRIMARY KEY (elementtypeid)",
                    "table": "ndb.elementtypes",
                    "referenced_table": "",
                    "columns": [
                        "elementtypeid"
                    ]
                }
            ],
            "triggers": [
                {
                    "name": "tr_sites_modifydate",
                    "def": "CREATE TRIGGER tr_sites_modifydate BEFORE INSERT OR UPDATE ON ndb.elementtypes FOR EACH ROW EXECUTE FUNCTION ndb.update_recdatemodified()"
                }
            ]
        },
        {
            "name": "ndb.embargo",
            "type": "BASE TABLE",
            "columns": [
                {
                    "name": "embargoid",
                    "type": "integer",
                    "nullable": false,
                    "default": "nextval('ndb.seq_embargo_embargoid'::regclass)"
                },
                {
                    "name": "embargodate",
                    "type": "date",
                    "nullable": false
                },
                {
                    "name": "embargopw",
                    "type": "varchar(20)",
                    "nullable": true
                }
            ],
            "indexes": [
                {
                    "name": "embargo_pkey",
                    "def": "CREATE UNIQUE INDEX embargo_pkey ON ndb.embargo USING btree (embargoid)",
                    "table": "ndb.embargo",
                    "columns": [
                        "embargoid"
                    ]
                }
            ],
            "constraints": [
                {
                    "name": "embargo_pkey",
                    "type": "PRIMARY KEY",
                    "def": "PRIMARY KEY (embargoid)",
                    "table": "ndb.embargo",
                    "referenced_table": "",
                    "columns": [
                        "embargoid"
                    ]
                }
            ]
        },
        {
            "name": "ndb.eventchronology",
            "type": "BASE TABLE",
            "columns": [
                {
                    "name": "eventchronologyid",
                    "type": "integer",
                    "nullable": false,
                    "default": "nextval('ndb.seq_eventchronology_eventchronologyid'::regclass)"
                },
                {
                    "name": "analysisunitid",
                    "type": "integer",
                    "nullable": true
                },
                {
                    "name": "eventid",
                    "type": "integer",
                    "nullable": false
                },
                {
                    "name": "notes",
                    "type": "text",
                    "nullable": true
                },
                {
                    "name": "recdatecreated",
                    "type": "timestamp(0) without time zone",
                    "nullable": false,
                    "default": "timezone('UTC'::text, now())"
                },
                {
                    "name": "recdatemodified",
                    "type": "timestamp(0) without time zone",
                    "nullable": false
                },
                {
                    "name": "chroncontrolid",
                    "type": "integer",
                    "nullable": false
                }
            ],
            "indexes": [
                {
                    "name": "eventchronology_pkey",
                    "def": "CREATE UNIQUE INDEX eventchronology_pkey ON ndb.eventchronology USING btree (eventchronologyid)",
                    "table": "ndb.eventchronology",
                    "columns": [
                        "eventchronologyid"
                    ]
                },
                {
                    "name": "uniqueeventset",
                    "def": "CREATE UNIQUE INDEX uniqueeventset ON ndb.eventchronology USING btree (analysisunitid, eventid, chroncontrolid)",
                    "table": "ndb.eventchronology",
                    "columns": [
                        "analysisunitid",
                        "eventid",
                        "chroncontrolid"
                    ]
                },
                {
                    "name": "ix_analysisunitid_eventchronology",
                    "def": "CREATE INDEX ix_analysisunitid_eventchronology ON ndb.eventchronology USING btree (analysisunitid) WITH (fillfactor='10')",
                    "table": "ndb.eventchronology",
                    "columns": [
                        "analysisunitid"
                    ]
                },
                {
                    "name": "ix_eventid_eventchronology",
                    "def": "CREATE INDEX ix_eventid_eventchronology ON ndb.eventchronology USING btree (eventid) WITH (fillfactor='10')",
                    "table": "ndb.eventchronology",
                    "columns": [
                        "eventid"
                    ]
                }
            ],
            "constraints": [
                {
                    "name": "evc_alu",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (analysisunitid) REFERENCES ndb.analysisunits(analysisunitid)",
                    "table": "ndb.eventchronology",
                    "referenced_table": "analysisunits",
                    "columns": [
                        "analysisunitid"
                    ],
                    "referenced_columns": [
                        "analysisunitid"
                    ]
                },
                {
                    "name": "evc_ccid",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (chroncontrolid) REFERENCES ndb.chroncontrols(chroncontrolid)",
                    "table": "ndb.eventchronology",
                    "referenced_table": "chroncontrols",
                    "columns": [
                        "chroncontrolid"
                    ],
                    "referenced_columns": [
                        "chroncontrolid"
                    ]
                },
                {
                    "name": "eventchronology_pkey",
                    "type": "PRIMARY KEY",
                    "def": "PRIMARY KEY (eventchronologyid)",
                    "table": "ndb.eventchronology",
                    "referenced_table": "",
                    "columns": [
                        "eventchronologyid"
                    ]
                },
                {
                    "name": "evc_evt",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (eventid) REFERENCES ndb.events(eventid)",
                    "table": "ndb.eventchronology",
                    "referenced_table": "events",
                    "columns": [
                        "eventid"
                    ],
                    "referenced_columns": [
                        "eventid"
                    ]
                },
                {
                    "name": "uniqueeventset",
                    "type": "UNIQUE",
                    "def": "UNIQUE (analysisunitid, eventid, chroncontrolid)",
                    "table": "ndb.eventchronology",
                    "referenced_table": "",
                    "columns": [
                        "analysisunitid",
                        "eventid",
                        "chroncontrolid"
                    ]
                }
            ],
            "triggers": [
                {
                    "name": "tr_sites_modifydate",
                    "def": "CREATE TRIGGER tr_sites_modifydate BEFORE INSERT OR UPDATE ON ndb.eventchronology FOR EACH ROW EXECUTE FUNCTION ndb.update_recdatemodified()"
                }
            ]
        },
        {
            "name": "ndb.eventpublications",
            "type": "BASE TABLE",
            "columns": [
                {
                    "name": "eventid",
                    "type": "integer",
                    "nullable": false
                },
                {
                    "name": "publicationid",
                    "type": "integer",
                    "nullable": false
                },
                {
                    "name": "recdatecreated",
                    "type": "timestamp(0) without time zone",
                    "nullable": false,
                    "default": "timezone('UTC'::text, now())"
                },
                {
                    "name": "recdatemodified",
                    "type": "timestamp(0) without time zone",
                    "nullable": false
                }
            ],
            "indexes": [
                {
                    "name": "eventpublications_pkey",
                    "def": "CREATE UNIQUE INDEX eventpublications_pkey ON ndb.eventpublications USING btree (eventid, publicationid)",
                    "table": "ndb.eventpublications",
                    "columns": [
                        "eventid",
                        "publicationid"
                    ]
                }
            ],
            "constraints": [
                {
                    "name": "eventpublications_pkey",
                    "type": "PRIMARY KEY",
                    "def": "PRIMARY KEY (eventid, publicationid)",
                    "table": "ndb.eventpublications",
                    "referenced_table": "",
                    "columns": [
                        "eventid",
                        "publicationid"
                    ]
                },
                {
                    "name": "fk_eventpublications_events",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (eventid) REFERENCES ndb.events(eventid) ON UPDATE CASCADE ON DELETE CASCADE",
                    "table": "ndb.eventpublications",
                    "referenced_table": "events",
                    "columns": [
                        "eventid"
                    ],
                    "referenced_columns": [
                        "eventid"
                    ]
                },
                {
                    "name": "fk_eventpublications_publications",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (publicationid) REFERENCES ndb.publications(publicationid) ON UPDATE CASCADE ON DELETE CASCADE",
                    "table": "ndb.eventpublications",
                    "referenced_table": "publications",
                    "columns": [
                        "publicationid"
                    ],
                    "referenced_columns": [
                        "publicationid"
                    ]
                }
            ],
            "triggers": [
                {
                    "name": "tr_sites_modifydate",
                    "def": "CREATE TRIGGER tr_sites_modifydate BEFORE INSERT OR UPDATE ON ndb.eventpublications FOR EACH ROW EXECUTE FUNCTION ndb.update_recdatemodified()"
                }
            ]
        },
        {
            "name": "ndb.events",
            "type": "BASE TABLE",
            "columns": [
                {
                    "name": "eventid",
                    "type": "integer",
                    "nullable": false,
                    "default": "nextval('ndb.seq_events_eventid'::regclass)"
                },
                {
                    "name": "eventtypeid",
                    "type": "integer",
                    "nullable": false
                },
                {
                    "name": "eventname",
                    "type": "varchar(80)",
                    "nullable": false
                },
                {
                    "name": "c14age",
                    "type": "double precision",
                    "nullable": true
                },
                {
                    "name": "c14ageyounger",
                    "type": "double precision",
                    "nullable": true
                },
                {
                    "name": "c14ageolder",
                    "type": "double precision",
                    "nullable": true
                },
                {
                    "name": "calage",
                    "type": "double precision",
                    "nullable": true
                },
                {
                    "name": "calageyounger",
                    "type": "double precision",
                    "nullable": true
                },
                {
                    "name": "calageolder",
                    "type": "double precision",
                    "nullable": true
                },
                {
                    "name": "notes",
                    "type": "text",
                    "nullable": true
                },
                {
                    "name": "recdatecreated",
                    "type": "timestamp(0) without time zone",
                    "nullable": false,
                    "default": "timezone('UTC'::text, now())"
                },
                {
                    "name": "recdatemodified",
                    "type": "timestamp(0) without time zone",
                    "nullable": false
                }
            ],
            "indexes": [
                {
                    "name": "events_pkey",
                    "def": "CREATE UNIQUE INDEX events_pkey ON ndb.events USING btree (eventid)",
                    "table": "ndb.events",
                    "columns": [
                        "eventid"
                    ]
                }
            ],
            "constraints": [
                {
                    "name": "events_pkey",
                    "type": "PRIMARY KEY",
                    "def": "PRIMARY KEY (eventid)",
                    "table": "ndb.events",
                    "referenced_table": "",
                    "columns": [
                        "eventid"
                    ]
                },
                {
                    "name": "fk_events_eventtypes",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (eventtypeid) REFERENCES ndb.eventtypes(eventtypeid) ON UPDATE CASCADE ON DELETE CASCADE",
                    "table": "ndb.events",
                    "referenced_table": "eventtypes",
                    "columns": [
                        "eventtypeid"
                    ],
                    "referenced_columns": [
                        "eventtypeid"
                    ]
                }
            ],
            "triggers": [
                {
                    "name": "tr_sites_modifydate",
                    "def": "CREATE TRIGGER tr_sites_modifydate BEFORE INSERT OR UPDATE ON ndb.events FOR EACH ROW EXECUTE FUNCTION ndb.update_recdatemodified()"
                }
            ]
        },
        {
            "name": "ndb.eventtypes",
            "type": "BASE TABLE",
            "columns": [
                {
                    "name": "eventtypeid",
                    "type": "integer",
                    "nullable": false,
                    "default": "nextval('ndb.seq_eventtypes_eventtypeid'::regclass)"
                },
                {
                    "name": "eventtype",
                    "type": "varchar(40)",
                    "nullable": false
                },
                {
                    "name": "recdatecreated",
                    "type": "timestamp(0) without time zone",
                    "nullable": false,
                    "default": "timezone('UTC'::text, now())"
                },
                {
                    "name": "recdatemodified",
                    "type": "timestamp(0) without time zone",
                    "nullable": false
                },
                {
                    "name": "chroncontroltypeid",
                    "type": "integer",
                    "nullable": true
                }
            ],
            "indexes": [
                {
                    "name": "eventtypes_pkey",
                    "def": "CREATE UNIQUE INDEX eventtypes_pkey ON ndb.eventtypes USING btree (eventtypeid)",
                    "table": "ndb.eventtypes",
                    "columns": [
                        "eventtypeid"
                    ]
                }
            ],
            "constraints": [
                {
                    "name": "evt_cct",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (chroncontroltypeid) REFERENCES ndb.chroncontroltypes(chroncontroltypeid)",
                    "table": "ndb.eventtypes",
                    "referenced_table": "chroncontroltypes",
                    "columns": [
                        "chroncontroltypeid"
                    ],
                    "referenced_columns": [
                        "chroncontroltypeid"
                    ]
                },
                {
                    "name": "eventtypes_pkey",
                    "type": "PRIMARY KEY",
                    "def": "PRIMARY KEY (eventtypeid)",
                    "table": "ndb.eventtypes",
                    "referenced_table": "",
                    "columns": [
                        "eventtypeid"
                    ]
                }
            ],
            "triggers": [
                {
                    "name": "tr_sites_modifydate",
                    "def": "CREATE TRIGGER tr_sites_modifydate BEFORE INSERT OR UPDATE ON ndb.eventtypes FOR EACH ROW EXECUTE FUNCTION ndb.update_recdatemodified()"
                }
            ]
        },
        {
            "name": "ndb.externaldatabases",
            "type": "BASE TABLE",
            "columns": [
                {
                    "name": "extdatabaseid",
                    "type": "integer",
                    "nullable": false,
                    "default": "nextval('ndb.seq_externaldatabases_extdatabaseid'::regclass)"
                },
                {
                    "name": "extdatabasename",
                    "type": "varchar(80)",
                    "nullable": false
                },
                {
                    "name": "url",
                    "type": "varchar(128)",
                    "nullable": true
                },
                {
                    "name": "recdatecreated",
                    "type": "timestamp(0) without time zone",
                    "nullable": false,
                    "default": "timezone('UTC'::text, now())"
                },
                {
                    "name": "recdatemodified",
                    "type": "timestamp(0) without time zone",
                    "nullable": false
                },
                {
                    "name": "urlmask",
                    "type": "varchar(128)",
                    "nullable": true
                }
            ],
            "indexes": [
                {
                    "name": "externaldatabases_pkey",
                    "def": "CREATE UNIQUE INDEX externaldatabases_pkey ON ndb.externaldatabases USING btree (extdatabaseid)",
                    "table": "ndb.externaldatabases",
                    "columns": [
                        "extdatabaseid"
                    ]
                }
            ],
            "constraints": [
                {
                    "name": "externaldatabases_pkey",
                    "type": "PRIMARY KEY",
                    "def": "PRIMARY KEY (extdatabaseid)",
                    "table": "ndb.externaldatabases",
                    "referenced_table": "",
                    "columns": [
                        "extdatabaseid"
                    ]
                }
            ],
            "triggers": [
                {
                    "name": "tr_sites_modifydate",
                    "def": "CREATE TRIGGER tr_sites_modifydate BEFORE INSERT OR UPDATE ON ndb.externaldatabases FOR EACH ROW EXECUTE FUNCTION ndb.update_recdatemodified()"
                }
            ]
        },
        {
            "name": "ndb.externalpublications",
            "type": "BASE TABLE",
            "columns": [
                {
                    "name": "publicationid",
                    "type": "integer",
                    "nullable": false
                },
                {
                    "name": "extdatabaseid",
                    "type": "integer",
                    "nullable": false
                },
                {
                    "name": "extpublicationid",
                    "type": "integer",
                    "nullable": false
                },
                {
                    "name": "recdatecreated",
                    "type": "timestamp(0) without time zone",
                    "nullable": false,
                    "default": "timezone('UTC'::text, now())"
                },
                {
                    "name": "recdatemodified",
                    "type": "timestamp(0) without time zone",
                    "nullable": false
                }
            ],
            "indexes": [
                {
                    "name": "externalpublications_pkey",
                    "def": "CREATE UNIQUE INDEX externalpublications_pkey ON ndb.externalpublications USING btree (publicationid, extdatabaseid)",
                    "table": "ndb.externalpublications",
                    "columns": [
                        "publicationid",
                        "extdatabaseid"
                    ]
                }
            ],
            "constraints": [
                {
                    "name": "fk_externalpublications_externaldatabases",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (extdatabaseid) REFERENCES ndb.externaldatabases(extdatabaseid) ON UPDATE CASCADE ON DELETE CASCADE",
                    "table": "ndb.externalpublications",
                    "referenced_table": "externaldatabases",
                    "columns": [
                        "extdatabaseid"
                    ],
                    "referenced_columns": [
                        "extdatabaseid"
                    ]
                },
                {
                    "name": "externalpublications_pkey",
                    "type": "PRIMARY KEY",
                    "def": "PRIMARY KEY (publicationid, extdatabaseid)",
                    "table": "ndb.externalpublications",
                    "referenced_table": "",
                    "columns": [
                        "publicationid",
                        "extdatabaseid"
                    ]
                },
                {
                    "name": "fk_externalpublications_publications",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (publicationid) REFERENCES ndb.publications(publicationid) ON UPDATE CASCADE ON DELETE CASCADE",
                    "table": "ndb.externalpublications",
                    "referenced_table": "publications",
                    "columns": [
                        "publicationid"
                    ],
                    "referenced_columns": [
                        "publicationid"
                    ]
                }
            ],
            "triggers": [
                {
                    "name": "tr_sites_modifydate",
                    "def": "CREATE TRIGGER tr_sites_modifydate BEFORE INSERT OR UPDATE ON ndb.externalpublications FOR EACH ROW EXECUTE FUNCTION ndb.update_recdatemodified()"
                }
            ]
        },
        {
            "name": "ndb.externaltaxa",
            "type": "BASE TABLE",
            "columns": [
                {
                    "name": "taxonid",
                    "type": "integer",
                    "nullable": false
                },
                {
                    "name": "extdatabaseid",
                    "type": "integer",
                    "nullable": false
                },
                {
                    "name": "exttaxonid",
                    "type": "varchar(64)",
                    "nullable": false
                },
                {
                    "name": "url",
                    "type": "varchar(128)",
                    "nullable": true
                },
                {
                    "name": "recdatecreated",
                    "type": "timestamp(0) without time zone",
                    "nullable": false,
                    "default": "timezone('UTC'::text, now())"
                },
                {
                    "name": "recdatemodified",
                    "type": "timestamp(0) without time zone",
                    "nullable": false
                }
            ],
            "indexes": [
                {
                    "name": "externaltaxa_pkey",
                    "def": "CREATE UNIQUE INDEX externaltaxa_pkey ON ndb.externaltaxa USING btree (taxonid, extdatabaseid, exttaxonid)",
                    "table": "ndb.externaltaxa",
                    "columns": [
                        "taxonid",
                        "extdatabaseid",
                        "exttaxonid"
                    ]
                },
                {
                    "name": "ix_extdatabaseid_exttaxonid_externaltaxa",
                    "def": "CREATE INDEX ix_extdatabaseid_exttaxonid_externaltaxa ON ndb.externaltaxa USING btree (extdatabaseid, exttaxonid) WITH (fillfactor='10')",
                    "table": "ndb.externaltaxa",
                    "columns": [
                        "extdatabaseid",
                        "exttaxonid"
                    ]
                }
            ],
            "constraints": [
                {
                    "name": "fk_externaltaxa_externaldatabases",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (extdatabaseid) REFERENCES ndb.externaldatabases(extdatabaseid) ON UPDATE CASCADE ON DELETE CASCADE",
                    "table": "ndb.externaltaxa",
                    "referenced_table": "externaldatabases",
                    "columns": [
                        "extdatabaseid"
                    ],
                    "referenced_columns": [
                        "extdatabaseid"
                    ]
                },
                {
                    "name": "externaltaxa_pkey",
                    "type": "PRIMARY KEY",
                    "def": "PRIMARY KEY (taxonid, extdatabaseid, exttaxonid)",
                    "table": "ndb.externaltaxa",
                    "referenced_table": "",
                    "columns": [
                        "taxonid",
                        "extdatabaseid",
                        "exttaxonid"
                    ]
                },
                {
                    "name": "fk_externaltaxa_taxa",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (taxonid) REFERENCES ndb.taxa(taxonid) ON UPDATE CASCADE ON DELETE CASCADE",
                    "table": "ndb.externaltaxa",
                    "referenced_table": "taxa",
                    "columns": [
                        "taxonid"
                    ],
                    "referenced_columns": [
                        "taxonid"
                    ]
                }
            ],
            "triggers": [
                {
                    "name": "tr_sites_modifydate",
                    "def": "CREATE TRIGGER tr_sites_modifydate BEFORE INSERT OR UPDATE ON ndb.externaltaxa FOR EACH ROW EXECUTE FUNCTION ndb.update_recdatemodified()"
                }
            ]
        },
        {
            "name": "ndb.faciestypes",
            "type": "BASE TABLE",
            "comment": "Lookup table of Facies Types. Table is referenced by the AnalysisUnits table.",
            "columns": [
                {
                    "name": "faciesid",
                    "type": "integer",
                    "nullable": false,
                    "default": "nextval('ndb.seq_faciestypes_faciesid'::regclass)",
                    "comment": "An arbitrary Facies identification number."
                },
                {
                    "name": "facies",
                    "type": "varchar(64)",
                    "nullable": false,
                    "comment": "Short Facies description."
                },
                {
                    "name": "recdatecreated",
                    "type": "timestamp(0) without time zone",
                    "nullable": false,
                    "default": "timezone('UTC'::text, now())"
                },
                {
                    "name": "recdatemodified",
                    "type": "timestamp(0) without time zone",
                    "nullable": false
                }
            ],
            "indexes": [
                {
                    "name": "faciestypes_pkey",
                    "def": "CREATE UNIQUE INDEX faciestypes_pkey ON ndb.faciestypes USING btree (faciesid)",
                    "table": "ndb.faciestypes",
                    "columns": [
                        "faciesid"
                    ]
                }
            ],
            "constraints": [
                {
                    "name": "faciestypes_pkey",
                    "type": "PRIMARY KEY",
                    "def": "PRIMARY KEY (faciesid)",
                    "table": "ndb.faciestypes",
                    "referenced_table": "",
                    "columns": [
                        "faciesid"
                    ]
                }
            ],
            "triggers": [
                {
                    "name": "tr_sites_modifydate",
                    "def": "CREATE TRIGGER tr_sites_modifydate BEFORE INSERT OR UPDATE ON ndb.faciestypes FOR EACH ROW EXECUTE FUNCTION ndb.update_recdatemodified()"
                }
            ]
        },
        {
            "name": "ndb.formtaxa",
            "type": "BASE TABLE",
            "columns": [
                {
                    "name": "formtaxonid",
                    "type": "integer",
                    "nullable": false,
                    "default": "nextval('ndb.seq_formtaxa_formtaxonid'::regclass)"
                },
                {
                    "name": "taxonid",
                    "type": "integer",
                    "nullable": false
                },
                {
                    "name": "affinityid",
                    "type": "integer",
                    "nullable": false
                },
                {
                    "name": "publicationid",
                    "type": "integer",
                    "nullable": false
                },
                {
                    "name": "systematicdescription",
                    "type": "boolean",
                    "nullable": false
                },
                {
                    "name": "recdatecreated",
                    "type": "timestamp(0) without time zone",
                    "nullable": false,
                    "default": "timezone('UTC'::text, now())"
                },
                {
                    "name": "recdatemodified",
                    "type": "timestamp(0) without time zone",
                    "nullable": false
                }
            ],
            "indexes": [
                {
                    "name": "formtaxa_pkey",
                    "def": "CREATE UNIQUE INDEX formtaxa_pkey ON ndb.formtaxa USING btree (formtaxonid)",
                    "table": "ndb.formtaxa",
                    "columns": [
                        "formtaxonid"
                    ]
                }
            ],
            "constraints": [
                {
                    "name": "formtaxa_pkey",
                    "type": "PRIMARY KEY",
                    "def": "PRIMARY KEY (formtaxonid)",
                    "table": "ndb.formtaxa",
                    "referenced_table": "",
                    "columns": [
                        "formtaxonid"
                    ]
                },
                {
                    "name": "fk_formtaxa_publications",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (publicationid) REFERENCES ndb.publications(publicationid) ON UPDATE CASCADE ON DELETE CASCADE",
                    "table": "ndb.formtaxa",
                    "referenced_table": "publications",
                    "columns": [
                        "publicationid"
                    ],
                    "referenced_columns": [
                        "publicationid"
                    ]
                },
                {
                    "name": "fk_formtaxa_taxa",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (taxonid) REFERENCES ndb.taxa(taxonid)",
                    "table": "ndb.formtaxa",
                    "referenced_table": "taxa",
                    "columns": [
                        "taxonid"
                    ],
                    "referenced_columns": [
                        "taxonid"
                    ]
                },
                {
                    "name": "fk_formtaxa_taxa1",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (affinityid) REFERENCES ndb.taxa(taxonid) ON UPDATE CASCADE ON DELETE CASCADE",
                    "table": "ndb.formtaxa",
                    "referenced_table": "taxa",
                    "columns": [
                        "affinityid"
                    ],
                    "referenced_columns": [
                        "taxonid"
                    ]
                }
            ],
            "triggers": [
                {
                    "name": "tr_sites_modifydate",
                    "def": "CREATE TRIGGER tr_sites_modifydate BEFORE INSERT OR UPDATE ON ndb.formtaxa FOR EACH ROW EXECUTE FUNCTION ndb.update_recdatemodified()"
                }
            ]
        },
        {
            "name": "ndb.fractiondated",
            "type": "BASE TABLE",
            "columns": [
                {
                    "name": "fractionid",
                    "type": "integer",
                    "nullable": false,
                    "default": "nextval('ndb.seq_fractiondated_fractionid'::regclass)"
                },
                {
                    "name": "fraction",
                    "type": "varchar(80)",
                    "nullable": false
                },
                {
                    "name": "recdatecreated",
                    "type": "timestamp(0) without time zone",
                    "nullable": false,
                    "default": "timezone('UTC'::text, now())"
                },
                {
                    "name": "recdatemodified",
                    "type": "timestamp(0) without time zone",
                    "nullable": false
                }
            ],
            "indexes": [
                {
                    "name": "fractiondated_pkey",
                    "def": "CREATE UNIQUE INDEX fractiondated_pkey ON ndb.fractiondated USING btree (fractionid)",
                    "table": "ndb.fractiondated",
                    "columns": [
                        "fractionid"
                    ]
                }
            ],
            "constraints": [
                {
                    "name": "fractiondated_pkey",
                    "type": "PRIMARY KEY",
                    "def": "PRIMARY KEY (fractionid)",
                    "table": "ndb.fractiondated",
                    "referenced_table": "",
                    "columns": [
                        "fractionid"
                    ]
                }
            ],
            "triggers": [
                {
                    "name": "tr_sites_modifydate",
                    "def": "CREATE TRIGGER tr_sites_modifydate BEFORE INSERT OR UPDATE ON ndb.fractiondated FOR EACH ROW EXECUTE FUNCTION ndb.update_recdatemodified()"
                }
            ]
        },
        {
            "name": "ndb.geochroncontrols",
            "type": "BASE TABLE",
            "columns": [
                {
                    "name": "chroncontrolid",
                    "type": "integer",
                    "nullable": false
                },
                {
                    "name": "geochronid",
                    "type": "integer",
                    "nullable": false
                },
                {
                    "name": "recdatecreated",
                    "type": "timestamp(0) without time zone",
                    "nullable": false,
                    "default": "timezone('UTC'::text, now())"
                },
                {
                    "name": "recdatemodified",
                    "type": "timestamp(0) without time zone",
                    "nullable": false
                }
            ],
            "indexes": [
                {
                    "name": "geochroncontrols_pkey",
                    "def": "CREATE UNIQUE INDEX geochroncontrols_pkey ON ndb.geochroncontrols USING btree (chroncontrolid, geochronid)",
                    "table": "ndb.geochroncontrols",
                    "columns": [
                        "chroncontrolid",
                        "geochronid"
                    ]
                },
                {
                    "name": "ix_chroncontrolid_geochroncontrols",
                    "def": "CREATE INDEX ix_chroncontrolid_geochroncontrols ON ndb.geochroncontrols USING btree (chroncontrolid) WITH (fillfactor='10')",
                    "table": "ndb.geochroncontrols",
                    "columns": [
                        "chroncontrolid"
                    ]
                },
                {
                    "name": "ix_geochronid_geochroncontrols",
                    "def": "CREATE INDEX ix_geochronid_geochroncontrols ON ndb.geochroncontrols USING btree (geochronid) WITH (fillfactor='10')",
                    "table": "ndb.geochroncontrols",
                    "columns": [
                        "geochronid"
                    ]
                }
            ],
            "constraints": [
                {
                    "name": "fk_geochroncontrols_chroncontrols",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (chroncontrolid) REFERENCES ndb.chroncontrols(chroncontrolid) ON UPDATE CASCADE ON DELETE CASCADE",
                    "table": "ndb.geochroncontrols",
                    "referenced_table": "chroncontrols",
                    "columns": [
                        "chroncontrolid"
                    ],
                    "referenced_columns": [
                        "chroncontrolid"
                    ]
                },
                {
                    "name": "geochroncontrols_pkey",
                    "type": "PRIMARY KEY",
                    "def": "PRIMARY KEY (chroncontrolid, geochronid)",
                    "table": "ndb.geochroncontrols",
                    "referenced_table": "",
                    "columns": [
                        "chroncontrolid",
                        "geochronid"
                    ]
                },
                {
                    "name": "fk_geochroncontrols_geochronology",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (geochronid) REFERENCES ndb.geochronology(geochronid) ON UPDATE CASCADE ON DELETE CASCADE",
                    "table": "ndb.geochroncontrols",
                    "referenced_table": "geochronology",
                    "columns": [
                        "geochronid"
                    ],
                    "referenced_columns": [
                        "geochronid"
                    ]
                }
            ],
            "triggers": [
                {
                    "name": "tr_sites_modifydate",
                    "def": "CREATE TRIGGER tr_sites_modifydate BEFORE INSERT OR UPDATE ON ndb.geochroncontrols FOR EACH ROW EXECUTE FUNCTION ndb.update_recdatemodified()"
                }
            ]
        },
        {
            "name": "ndb.geochronology",
            "type": "BASE TABLE",
            "comment": "This table stores geochronologic data. Geochronologic measurements are from geochronologic samples, which are from Analysis Units, which may have a depth and thickness. Geochronologic measurements may be from the same or different Analysis Units as fossils. In the case of faunal excavations, geochronologic samples are typically from the same Analysis Units as the fossils, and there may be multiple geochronologic samples from a single Analysis Unit. In the case of cores used for microfossil analysis, geochronologic samples are often from separate Analysis Units; dated core sections are often thicker than microfossil Analysis Units.",
            "columns": [
                {
                    "name": "geochronid",
                    "type": "integer",
                    "nullable": false,
                    "default": "nextval('ndb.seq_geochronology_geochronid'::regclass)",
                    "comment": "An arbitrary Geochronologic identification number."
                },
                {
                    "name": "sampleid",
                    "type": "integer",
                    "nullable": false,
                    "comment": "Sample identification number. Field links to Samples table."
                },
                {
                    "name": "geochrontypeid",
                    "type": "integer",
                    "nullable": false,
                    "comment": "Identification number for the type of Geochronologic analysis, e.g. «Carbon-14», «Thermoluminescence». Field links to the GeochronTypes table."
                },
                {
                    "name": "agetypeid",
                    "type": "integer",
                    "nullable": false,
                    "comment": "Identification number for the age units, e.g. «Radiocarbon years BP», «Calibrated radiocarbon years BP»."
                },
                {
                    "name": "age",
                    "type": "double precision",
                    "nullable": true,
                    "comment": "Reported age value of the geochronologic measurement."
                },
                {
                    "name": "errorolder",
                    "type": "double precision",
                    "nullable": true,
                    "comment": "The older error limit of the age value. For a date reported with ±1 SD or σ, the ErrorOlder and ErrorYounger values are this value."
                },
                {
                    "name": "erroryounger",
                    "type": "double precision",
                    "nullable": true,
                    "comment": "The younger error limit of the age value."
                },
                {
                    "name": "infinite",
                    "type": "boolean",
                    "nullable": false,
                    "comment": "Is «True» for and infinite or “greater than” geochronologic measurement, otherwise is «False»."
                },
                {
                    "name": "delta13c",
                    "type": "double precision",
                    "nullable": true,
                    "comment": "The measured or assumed δ13C value for radiocarbon dates, if provided. Radiocarbon dates are assumed to be normalized to δ13C, and if uncorrected and normalized ages are reported, the normalized age should be entered in the database."
                },
                {
                    "name": "labnumber",
                    "type": "varchar(40)",
                    "nullable": true,
                    "comment": "Lab number for the geochronologic measurement."
                },
                {
                    "name": "materialdated",
                    "type": "varchar(255)",
                    "nullable": true,
                    "comment": "Material analyzed for a geochronologic measurement."
                },
                {
                    "name": "notes",
                    "type": "text",
                    "nullable": true,
                    "comment": "Free form notes or comments about the geochronologic measurement."
                },
                {
                    "name": "recdatecreated",
                    "type": "timestamp(0) without time zone",
                    "nullable": false,
                    "default": "timezone('UTC'::text, now())"
                },
                {
                    "name": "recdatemodified",
                    "type": "timestamp(0) without time zone",
                    "nullable": false
                }
            ],
            "indexes": [
                {
                    "name": "geochronology_pkey",
                    "def": "CREATE UNIQUE INDEX geochronology_pkey ON ndb.geochronology USING btree (geochronid)",
                    "table": "ndb.geochronology",
                    "columns": [
                        "geochronid"
                    ]
                },
                {
                    "name": "geoage_idx",
                    "def": "CREATE INDEX geoage_idx ON ndb.geochronology USING btree (age)",
                    "table": "ndb.geochronology",
                    "columns": [
                        "age"
                    ]
                },
                {
                    "name": "ix_sampleid_geochronology",
                    "def": "CREATE INDEX ix_sampleid_geochronology ON ndb.geochronology USING btree (sampleid) WITH (fillfactor='10')",
                    "table": "ndb.geochronology",
                    "columns": [
                        "sampleid"
                    ]
                },
                {
                    "name": "geochronology_labnumber_idx",
                    "def": "CREATE INDEX geochronology_labnumber_idx ON ndb.geochronology USING btree (labnumber)",
                    "table": "ndb.geochronology",
                    "columns": [
                        "labnumber"
                    ]
                },
                {
                    "name": "geochronology_unique",
                    "def": "CREATE UNIQUE INDEX geochronology_unique ON ndb.geochronology USING btree (sampleid, labnumber)",
                    "table": "ndb.geochronology",
                    "columns": [
                        "sampleid",
                        "labnumber"
                    ]
                }
            ],
            "constraints": [
                {
                    "name": "fk_geochronology_agetypes",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (agetypeid) REFERENCES ndb.agetypes(agetypeid)",
                    "table": "ndb.geochronology",
                    "referenced_table": "agetypes",
                    "columns": [
                        "agetypeid"
                    ],
                    "referenced_columns": [
                        "agetypeid"
                    ]
                },
                {
                    "name": "geochronology_pkey",
                    "type": "PRIMARY KEY",
                    "def": "PRIMARY KEY (geochronid)",
                    "table": "ndb.geochronology",
                    "referenced_table": "",
                    "columns": [
                        "geochronid"
                    ]
                },
                {
                    "name": "fk_geochronology_geochrontypes",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (geochrontypeid) REFERENCES ndb.geochrontypes(geochrontypeid) ON UPDATE CASCADE ON DELETE CASCADE",
                    "table": "ndb.geochronology",
                    "referenced_table": "geochrontypes",
                    "columns": [
                        "geochrontypeid"
                    ],
                    "referenced_columns": [
                        "geochrontypeid"
                    ]
                },
                {
                    "name": "fk_geochronology_samples",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (sampleid) REFERENCES ndb.samples(sampleid) ON UPDATE CASCADE ON DELETE CASCADE",
                    "table": "ndb.geochronology",
                    "referenced_table": "samples",
                    "columns": [
                        "sampleid"
                    ],
                    "referenced_columns": [
                        "sampleid"
                    ]
                },
                {
                    "name": "geochronology_unique",
                    "type": "UNIQUE",
                    "def": "UNIQUE (sampleid, labnumber)",
                    "table": "ndb.geochronology",
                    "referenced_table": "",
                    "columns": [
                        "sampleid",
                        "labnumber"
                    ]
                }
            ],
            "triggers": [
                {
                    "name": "tr_sites_modifydate",
                    "def": "CREATE TRIGGER tr_sites_modifydate BEFORE INSERT OR UPDATE ON ndb.geochronology FOR EACH ROW EXECUTE FUNCTION ndb.update_recdatemodified()"
                }
            ]
        },
        {
            "name": "ndb.geochronpublications",
            "type": "BASE TABLE",
            "comment": "Publications in which Geochronologic measurements are reported. Many older radiocarbon dates are reported in the journal Radiocarbon. Dates may be reported in multiple publications. The “publication” could be a database such as the online Canadian Archaeological Radiocarbon Database.",
            "columns": [
                {
                    "name": "geochronid",
                    "type": "integer",
                    "nullable": false,
                    "comment": "Geochronologic identification number. Field links to the Geochronology table."
                },
                {
                    "name": "publicationid",
                    "type": "integer",
                    "nullable": false,
                    "comment": "Publication identification number. Field links to the Publications table."
                },
                {
                    "name": "recdatecreated",
                    "type": "timestamp(0) without time zone",
                    "nullable": false,
                    "default": "timezone('UTC'::text, now())"
                },
                {
                    "name": "recdatemodified",
                    "type": "timestamp(0) without time zone",
                    "nullable": false
                }
            ],
            "indexes": [
                {
                    "name": "geochronpublications_pkey",
                    "def": "CREATE UNIQUE INDEX geochronpublications_pkey ON ndb.geochronpublications USING btree (geochronid, publicationid)",
                    "table": "ndb.geochronpublications",
                    "columns": [
                        "geochronid",
                        "publicationid"
                    ]
                },
                {
                    "name": "ix_geochronid_geochronpublications",
                    "def": "CREATE INDEX ix_geochronid_geochronpublications ON ndb.geochronpublications USING btree (geochronid) WITH (fillfactor='10')",
                    "table": "ndb.geochronpublications",
                    "columns": [
                        "geochronid"
                    ]
                },
                {
                    "name": "ix_publicationid_geochronpublications",
                    "def": "CREATE INDEX ix_publicationid_geochronpublications ON ndb.geochronpublications USING btree (publicationid) WITH (fillfactor='10')",
                    "table": "ndb.geochronpublications",
                    "columns": [
                        "publicationid"
                    ]
                }
            ],
            "constraints": [
                {
                    "name": "fk_geochronpublications_geochronology",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (geochronid) REFERENCES ndb.geochronology(geochronid) ON UPDATE CASCADE ON DELETE CASCADE",
                    "table": "ndb.geochronpublications",
                    "referenced_table": "geochronology",
                    "columns": [
                        "geochronid"
                    ],
                    "referenced_columns": [
                        "geochronid"
                    ]
                },
                {
                    "name": "geochronpublications_pkey",
                    "type": "PRIMARY KEY",
                    "def": "PRIMARY KEY (geochronid, publicationid)",
                    "table": "ndb.geochronpublications",
                    "referenced_table": "",
                    "columns": [
                        "geochronid",
                        "publicationid"
                    ]
                },
                {
                    "name": "fk_geochronpublications_publications",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (publicationid) REFERENCES ndb.publications(publicationid) ON UPDATE CASCADE ON DELETE CASCADE",
                    "table": "ndb.geochronpublications",
                    "referenced_table": "publications",
                    "columns": [
                        "publicationid"
                    ],
                    "referenced_columns": [
                        "publicationid"
                    ]
                }
            ],
            "triggers": [
                {
                    "name": "tr_sites_modifydate",
                    "def": "CREATE TRIGGER tr_sites_modifydate BEFORE INSERT OR UPDATE ON ndb.geochronpublications FOR EACH ROW EXECUTE FUNCTION ndb.update_recdatemodified()"
                }
            ]
        },
        {
            "name": "ndb.geochrontypes",
            "type": "BASE TABLE",
            "comment": "Lookup table for Geochronology Types. Table is referenced by the Geochronology table.",
            "columns": [
                {
                    "name": "geochrontypeid",
                    "type": "integer",
                    "nullable": false,
                    "default": "nextval('ndb.seq_geochrontypes_geochrontypeid'::regclass)",
                    "comment": "Geochronology Type identification number."
                },
                {
                    "name": "geochrontype",
                    "type": "varchar(64)",
                    "nullable": false,
                    "comment": "Type of Geochronologic measurement."
                },
                {
                    "name": "recdatecreated",
                    "type": "timestamp(0) without time zone",
                    "nullable": false,
                    "default": "timezone('UTC'::text, now())"
                },
                {
                    "name": "recdatemodified",
                    "type": "timestamp(0) without time zone",
                    "nullable": false
                }
            ],
            "indexes": [
                {
                    "name": "geochrontypes_pkey",
                    "def": "CREATE UNIQUE INDEX geochrontypes_pkey ON ndb.geochrontypes USING btree (geochrontypeid)",
                    "table": "ndb.geochrontypes",
                    "columns": [
                        "geochrontypeid"
                    ]
                }
            ],
            "constraints": [
                {
                    "name": "geochrontypes_pkey",
                    "type": "PRIMARY KEY",
                    "def": "PRIMARY KEY (geochrontypeid)",
                    "table": "ndb.geochrontypes",
                    "referenced_table": "",
                    "columns": [
                        "geochrontypeid"
                    ]
                }
            ],
            "triggers": [
                {
                    "name": "tr_sites_modifydate",
                    "def": "CREATE TRIGGER tr_sites_modifydate BEFORE INSERT OR UPDATE ON ndb.geochrontypes FOR EACH ROW EXECUTE FUNCTION ndb.update_recdatemodified()"
                }
            ]
        },
        {
            "name": "ndb.geopaths",
            "type": "BASE TABLE",
            "columns": [
                {
                    "name": "geoout",
                    "type": "integer[]",
                    "nullable": false
                },
                {
                    "name": "geoin",
                    "type": "bigint",
                    "nullable": false
                }
            ],
            "indexes": [
                {
                    "name": "geopaths_pkey",
                    "def": "CREATE UNIQUE INDEX geopaths_pkey ON ndb.geopaths USING btree (geoout, geoin)",
                    "table": "ndb.geopaths",
                    "columns": [
                        "geoout",
                        "geoin"
                    ]
                }
            ],
            "constraints": [
                {
                    "name": "geopaths_pkey",
                    "type": "PRIMARY KEY",
                    "def": "PRIMARY KEY (geoout, geoin)",
                    "table": "ndb.geopaths",
                    "referenced_table": "",
                    "columns": [
                        "geoout",
                        "geoin"
                    ]
                },
                {
                    "name": "geopaths_geoin_fkey",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (geoin) REFERENCES ndb.geopoliticalunits(geopoliticalid)",
                    "table": "ndb.geopaths",
                    "referenced_table": "geopoliticalunits",
                    "columns": [
                        "geoin"
                    ],
                    "referenced_columns": [
                        "geopoliticalid"
                    ]
                }
            ]
        },
        {
            "name": "ndb.geopoldepth",
            "type": "VIEW",
            "columns": [
                {
                    "name": "geopoliticalid",
                    "type": "integer",
                    "nullable": true
                },
                {
                    "name": "geopoliticalname",
                    "type": "varchar(255)",
                    "nullable": true
                },
                {
                    "name": "geopoliticalunit",
                    "type": "varchar(255)",
                    "nullable": true
                },
                {
                    "name": "rank",
                    "type": "integer",
                    "nullable": true
                },
                {
                    "name": "path",
                    "type": "integer[]",
                    "nullable": true
                }
            ],
            "def": "CREATE VIEW geopoldepth AS (\n WITH RECURSIVE gpid_path AS (\n         SELECT gp_1.geopoliticalid,\n            (gp_1.geopoliticalid)::text AS gpid\n           FROM ndb.geopoliticalunits gp_1\n          WHERE (gp_1.rank = 1)\n        UNION ALL\n         SELECT gpu_1.geopoliticalid,\n            concat(gpa.gpid, ',', gpu_1.geopoliticalid) AS concat\n           FROM (ndb.geopoliticalunits gpu_1\n             JOIN gpid_path gpa ON ((gpa.geopoliticalid = gpu_1.highergeopoliticalid)))\n        )\n SELECT gp.geopoliticalid,\n    gpu.geopoliticalname,\n    gpu.geopoliticalunit,\n    gpu.rank,\n    (string_to_array(gp.gpid, ','::text))::integer[] AS path\n   FROM (gpid_path gp\n     JOIN ndb.geopoliticalunits gpu ON ((gpu.geopoliticalid = gp.geopoliticalid)))\n  ORDER BY gp.geopoliticalid\n)",
            "referenced_tables": [
                "ndb.geopoliticalunits",
                "gpid_path"
            ]
        },
        {
            "name": "ndb.isobiomarkerbandtypes",
            "type": "BASE TABLE",
            "columns": [
                {
                    "name": "isobiomarkerbandtypeid",
                    "type": "integer",
                    "nullable": false,
                    "default": "nextval('ndb.seq_isobiomarkerbandtypes_isobiomarkerbandtypeid'::regclass)"
                },
                {
                    "name": "isobiomarkertypeid",
                    "type": "integer",
                    "nullable": false
                },
                {
                    "name": "isobiomarkerbandtype",
                    "type": "varchar(50)",
                    "nullable": false
                },
                {
                    "name": "recdatecreated",
                    "type": "timestamp(0) without time zone",
                    "nullable": false,
                    "default": "timezone('UTC'::text, now())"
                },
                {
                    "name": "recdatemodified",
                    "type": "timestamp(0) without time zone",
                    "nullable": false
                }
            ],
            "indexes": [
                {
                    "name": "isobiomarkerbandtypes_pkey",
                    "def": "CREATE UNIQUE INDEX isobiomarkerbandtypes_pkey ON ndb.isobiomarkerbandtypes USING btree (isobiomarkerbandtypeid)",
                    "table": "ndb.isobiomarkerbandtypes",
                    "columns": [
                        "isobiomarkerbandtypeid"
                    ]
                }
            ],
            "constraints": [
                {
                    "name": "isobiomarkerbandtypes_pkey",
                    "type": "PRIMARY KEY",
                    "def": "PRIMARY KEY (isobiomarkerbandtypeid)",
                    "table": "ndb.isobiomarkerbandtypes",
                    "referenced_table": "",
                    "columns": [
                        "isobiomarkerbandtypeid"
                    ]
                },
                {
                    "name": "fk_isobiomarkerbands_isobiomarkertypes",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (isobiomarkertypeid) REFERENCES ndb.isobiomarkertypes(isobiomarkertypeid) ON UPDATE CASCADE ON DELETE CASCADE",
                    "table": "ndb.isobiomarkerbandtypes",
                    "referenced_table": "isobiomarkertypes",
                    "columns": [
                        "isobiomarkertypeid"
                    ],
                    "referenced_columns": [
                        "isobiomarkertypeid"
                    ]
                }
            ],
            "triggers": [
                {
                    "name": "tr_sites_modifydate",
                    "def": "CREATE TRIGGER tr_sites_modifydate BEFORE INSERT OR UPDATE ON ndb.isobiomarkerbandtypes FOR EACH ROW EXECUTE FUNCTION ndb.update_recdatemodified()"
                }
            ]
        },
        {
            "name": "ndb.isobiomarkertypes",
            "type": "BASE TABLE",
            "columns": [
                {
                    "name": "isobiomarkertypeid",
                    "type": "integer",
                    "nullable": false,
                    "default": "nextval('ndb.seq_isobiomarkertypes_isobiomarkertypeid'::regclass)"
                },
                {
                    "name": "isobiomarkertype",
                    "type": "varchar(50)",
                    "nullable": false
                },
                {
                    "name": "recdatecreated",
                    "type": "timestamp(0) without time zone",
                    "nullable": false,
                    "default": "timezone('UTC'::text, now())"
                },
                {
                    "name": "recdatemodified",
                    "type": "timestamp(0) without time zone",
                    "nullable": false
                }
            ],
            "indexes": [
                {
                    "name": "isobiomarkertypes_pkey",
                    "def": "CREATE UNIQUE INDEX isobiomarkertypes_pkey ON ndb.isobiomarkertypes USING btree (isobiomarkertypeid)",
                    "table": "ndb.isobiomarkertypes",
                    "columns": [
                        "isobiomarkertypeid"
                    ]
                }
            ],
            "constraints": [
                {
                    "name": "isobiomarkertypes_pkey",
                    "type": "PRIMARY KEY",
                    "def": "PRIMARY KEY (isobiomarkertypeid)",
                    "table": "ndb.isobiomarkertypes",
                    "referenced_table": "",
                    "columns": [
                        "isobiomarkertypeid"
                    ]
                }
            ],
            "triggers": [
                {
                    "name": "tr_sites_modifydate",
                    "def": "CREATE TRIGGER tr_sites_modifydate BEFORE INSERT OR UPDATE ON ndb.isobiomarkertypes FOR EACH ROW EXECUTE FUNCTION ndb.update_recdatemodified()"
                }
            ]
        },
        {
            "name": "ndb.isoinstrumentation",
            "type": "BASE TABLE",
            "columns": [
                {
                    "name": "datasetid",
                    "type": "integer",
                    "nullable": false
                },
                {
                    "name": "variableid",
                    "type": "integer",
                    "nullable": false
                },
                {
                    "name": "isoinstrumentationtypeid",
                    "type": "integer",
                    "nullable": true
                },
                {
                    "name": "isosampleintrosystemtypeid",
                    "type": "integer",
                    "nullable": true
                },
                {
                    "name": "insterrorpercent",
                    "type": "double precision",
                    "nullable": true
                },
                {
                    "name": "insterrorrunsd",
                    "type": "double precision",
                    "nullable": true
                },
                {
                    "name": "insterrorlongtermpercent",
                    "type": "double precision",
                    "nullable": true
                },
                {
                    "name": "notes",
                    "type": "text",
                    "nullable": true
                },
                {
                    "name": "recdatecreated",
                    "type": "timestamp(0) without time zone",
                    "nullable": false,
                    "default": "timezone('UTC'::text, now())"
                },
                {
                    "name": "recdatemodified",
                    "type": "timestamp(0) without time zone",
                    "nullable": false
                }
            ],
            "indexes": [
                {
                    "name": "isoinstrumentation_pkey",
                    "def": "CREATE UNIQUE INDEX isoinstrumentation_pkey ON ndb.isoinstrumentation USING btree (datasetid, variableid)",
                    "table": "ndb.isoinstrumentation",
                    "columns": [
                        "datasetid",
                        "variableid"
                    ]
                }
            ],
            "constraints": [
                {
                    "name": "fk_isoinstrumentation_datasets",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (datasetid) REFERENCES ndb.datasets(datasetid) ON UPDATE CASCADE ON DELETE CASCADE",
                    "table": "ndb.isoinstrumentation",
                    "referenced_table": "datasets",
                    "columns": [
                        "datasetid"
                    ],
                    "referenced_columns": [
                        "datasetid"
                    ]
                },
                {
                    "name": "isoinstrumentation_pkey",
                    "type": "PRIMARY KEY",
                    "def": "PRIMARY KEY (datasetid, variableid)",
                    "table": "ndb.isoinstrumentation",
                    "referenced_table": "",
                    "columns": [
                        "datasetid",
                        "variableid"
                    ]
                },
                {
                    "name": "fk_isoinstrumentation_isoinstrumentationtypes",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (isoinstrumentationtypeid) REFERENCES ndb.isoinstrumentationtypes(isoinstrumentationtypeid) ON UPDATE CASCADE ON DELETE CASCADE",
                    "table": "ndb.isoinstrumentation",
                    "referenced_table": "isoinstrumentationtypes",
                    "columns": [
                        "isoinstrumentationtypeid"
                    ],
                    "referenced_columns": [
                        "isoinstrumentationtypeid"
                    ]
                },
                {
                    "name": "fk_isoinstrumentation_isosampleintrosystemtypes",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (isosampleintrosystemtypeid) REFERENCES ndb.isosampleintrosystemtypes(isosampleintrosystemtypeid) ON UPDATE CASCADE ON DELETE CASCADE",
                    "table": "ndb.isoinstrumentation",
                    "referenced_table": "isosampleintrosystemtypes",
                    "columns": [
                        "isosampleintrosystemtypeid"
                    ],
                    "referenced_columns": [
                        "isosampleintrosystemtypeid"
                    ]
                },
                {
                    "name": "fk_isoinstrumentation_variables",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (variableid) REFERENCES ndb.variables(variableid) ON UPDATE CASCADE ON DELETE CASCADE",
                    "table": "ndb.isoinstrumentation",
                    "referenced_table": "variables",
                    "columns": [
                        "variableid"
                    ],
                    "referenced_columns": [
                        "variableid"
                    ]
                }
            ],
            "triggers": [
                {
                    "name": "tr_sites_modifydate",
                    "def": "CREATE TRIGGER tr_sites_modifydate BEFORE INSERT OR UPDATE ON ndb.isoinstrumentation FOR EACH ROW EXECUTE FUNCTION ndb.update_recdatemodified()"
                }
            ]
        },
        {
            "name": "ndb.isoinstrumentationtypes",
            "type": "BASE TABLE",
            "columns": [
                {
                    "name": "isoinstrumentationtypeid",
                    "type": "integer",
                    "nullable": false,
                    "default": "nextval('ndb.seq_isoinstrumentationtypes_isoinstrumentationtypeid'::regclass)"
                },
                {
                    "name": "isoinstrumentationtype",
                    "type": "varchar(256)",
                    "nullable": false
                },
                {
                    "name": "recdatecreated",
                    "type": "timestamp(0) without time zone",
                    "nullable": false,
                    "default": "timezone('UTC'::text, now())"
                },
                {
                    "name": "recdatemodified",
                    "type": "timestamp(0) without time zone",
                    "nullable": false
                }
            ],
            "indexes": [
                {
                    "name": "isoinstrumentationtypes_pkey",
                    "def": "CREATE UNIQUE INDEX isoinstrumentationtypes_pkey ON ndb.isoinstrumentationtypes USING btree (isoinstrumentationtypeid)",
                    "table": "ndb.isoinstrumentationtypes",
                    "columns": [
                        "isoinstrumentationtypeid"
                    ]
                }
            ],
            "constraints": [
                {
                    "name": "isoinstrumentationtypes_pkey",
                    "type": "PRIMARY KEY",
                    "def": "PRIMARY KEY (isoinstrumentationtypeid)",
                    "table": "ndb.isoinstrumentationtypes",
                    "referenced_table": "",
                    "columns": [
                        "isoinstrumentationtypeid"
                    ]
                }
            ],
            "triggers": [
                {
                    "name": "tr_sites_modifydate",
                    "def": "CREATE TRIGGER tr_sites_modifydate BEFORE INSERT OR UPDATE ON ndb.isoinstrumentationtypes FOR EACH ROW EXECUTE FUNCTION ndb.update_recdatemodified()"
                }
            ]
        },
        {
            "name": "ndb.isomatanalsubstrate",
            "type": "BASE TABLE",
            "columns": [
                {
                    "name": "isomatanaltypeid",
                    "type": "integer",
                    "nullable": false
                },
                {
                    "name": "isosubstratetypeid",
                    "type": "integer",
                    "nullable": false
                },
                {
                    "name": "recdatecreated",
                    "type": "timestamp(0) without time zone",
                    "nullable": false,
                    "default": "timezone('UTC'::text, now())"
                },
                {
                    "name": "recdatemodified",
                    "type": "timestamp(0) without time zone",
                    "nullable": false
                }
            ],
            "indexes": [
                {
                    "name": "isomatanalsubstrate_pkey",
                    "def": "CREATE UNIQUE INDEX isomatanalsubstrate_pkey ON ndb.isomatanalsubstrate USING btree (isomatanaltypeid, isosubstratetypeid)",
                    "table": "ndb.isomatanalsubstrate",
                    "columns": [
                        "isomatanaltypeid",
                        "isosubstratetypeid"
                    ]
                }
            ],
            "constraints": [
                {
                    "name": "isomatanalsubstrate_pkey",
                    "type": "PRIMARY KEY",
                    "def": "PRIMARY KEY (isomatanaltypeid, isosubstratetypeid)",
                    "table": "ndb.isomatanalsubstrate",
                    "referenced_table": "",
                    "columns": [
                        "isomatanaltypeid",
                        "isosubstratetypeid"
                    ]
                },
                {
                    "name": "fk_isomatanalsubstrate_isomaterialanalyzedtypes",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (isomatanaltypeid) REFERENCES ndb.isomaterialanalyzedtypes(isomatanaltypeid) ON UPDATE CASCADE ON DELETE CASCADE",
                    "table": "ndb.isomatanalsubstrate",
                    "referenced_table": "isomaterialanalyzedtypes",
                    "columns": [
                        "isomatanaltypeid"
                    ],
                    "referenced_columns": [
                        "isomatanaltypeid"
                    ]
                },
                {
                    "name": "fk_isomatanalsubstrate_isosubstratetypes",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (isosubstratetypeid) REFERENCES ndb.isosubstratetypes(isosubstratetypeid) ON UPDATE CASCADE ON DELETE CASCADE",
                    "table": "ndb.isomatanalsubstrate",
                    "referenced_table": "isosubstratetypes",
                    "columns": [
                        "isosubstratetypeid"
                    ],
                    "referenced_columns": [
                        "isosubstratetypeid"
                    ]
                }
            ],
            "triggers": [
                {
                    "name": "tr_sites_modifydate",
                    "def": "CREATE TRIGGER tr_sites_modifydate BEFORE INSERT OR UPDATE ON ndb.isomatanalsubstrate FOR EACH ROW EXECUTE FUNCTION ndb.update_recdatemodified()"
                }
            ]
        },
        {
            "name": "ndb.isomaterialanalyzedtypes",
            "type": "BASE TABLE",
            "columns": [
                {
                    "name": "isomatanaltypeid",
                    "type": "integer",
                    "nullable": false,
                    "default": "nextval('ndb.seq_isomaterialanalyzedtypes_isomatanaltypeid'::regclass)"
                },
                {
                    "name": "isomaterialanalyzedtype",
                    "type": "varchar(50)",
                    "nullable": false
                },
                {
                    "name": "recdatecreated",
                    "type": "timestamp(0) without time zone",
                    "nullable": false,
                    "default": "timezone('UTC'::text, now())"
                },
                {
                    "name": "recdatemodified",
                    "type": "timestamp(0) without time zone",
                    "nullable": false
                }
            ],
            "indexes": [
                {
                    "name": "isomaterialanalyzedtypes_pkey",
                    "def": "CREATE UNIQUE INDEX isomaterialanalyzedtypes_pkey ON ndb.isomaterialanalyzedtypes USING btree (isomatanaltypeid)",
                    "table": "ndb.isomaterialanalyzedtypes",
                    "columns": [
                        "isomatanaltypeid"
                    ]
                }
            ],
            "constraints": [
                {
                    "name": "isomaterialanalyzedtypes_pkey",
                    "type": "PRIMARY KEY",
                    "def": "PRIMARY KEY (isomatanaltypeid)",
                    "table": "ndb.isomaterialanalyzedtypes",
                    "referenced_table": "",
                    "columns": [
                        "isomatanaltypeid"
                    ]
                }
            ],
            "triggers": [
                {
                    "name": "tr_sites_modifydate",
                    "def": "CREATE TRIGGER tr_sites_modifydate BEFORE INSERT OR UPDATE ON ndb.isomaterialanalyzedtypes FOR EACH ROW EXECUTE FUNCTION ndb.update_recdatemodified()"
                }
            ]
        },
        {
            "name": "ndb.isometadata",
            "type": "BASE TABLE",
            "columns": [
                {
                    "name": "isometadataid",
                    "type": "integer",
                    "nullable": false,
                    "default": "nextval('ndb.seq_isometadata_isometadataid'::regclass)"
                },
                {
                    "name": "dataid",
                    "type": "integer",
                    "nullable": false
                },
                {
                    "name": "isomatanaltypeid",
                    "type": "integer",
                    "nullable": true
                },
                {
                    "name": "isosubstratetypeid",
                    "type": "integer",
                    "nullable": true
                },
                {
                    "name": "analystid",
                    "type": "integer",
                    "nullable": true
                },
                {
                    "name": "lab",
                    "type": "varchar(255)",
                    "nullable": true
                },
                {
                    "name": "labnumber",
                    "type": "varchar(64)",
                    "nullable": true
                },
                {
                    "name": "mass_mg",
                    "type": "double precision",
                    "nullable": true
                },
                {
                    "name": "weightpercent",
                    "type": "double precision",
                    "nullable": true
                },
                {
                    "name": "atomicpercent",
                    "type": "double precision",
                    "nullable": true
                },
                {
                    "name": "reps",
                    "type": "integer",
                    "nullable": true
                },
                {
                    "name": "recdatecreated",
                    "type": "timestamp(0) without time zone",
                    "nullable": false,
                    "default": "timezone('UTC'::text, now())"
                },
                {
                    "name": "recdatemodified",
                    "type": "timestamp(0) without time zone",
                    "nullable": false
                }
            ],
            "indexes": [
                {
                    "name": "isometadata_pkey",
                    "def": "CREATE UNIQUE INDEX isometadata_pkey ON ndb.isometadata USING btree (isometadataid)",
                    "table": "ndb.isometadata",
                    "columns": [
                        "isometadataid"
                    ]
                }
            ],
            "constraints": [
                {
                    "name": "fk_isometadata_contacts",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (analystid) REFERENCES ndb.contacts(contactid)",
                    "table": "ndb.isometadata",
                    "referenced_table": "contacts",
                    "columns": [
                        "analystid"
                    ],
                    "referenced_columns": [
                        "contactid"
                    ]
                },
                {
                    "name": "fk_isometadata_data",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (dataid) REFERENCES ndb.data(dataid) ON UPDATE CASCADE ON DELETE CASCADE",
                    "table": "ndb.isometadata",
                    "referenced_table": "data",
                    "columns": [
                        "dataid"
                    ],
                    "referenced_columns": [
                        "dataid"
                    ]
                },
                {
                    "name": "fk_isometadata_isomaterialanalyzedtypes",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (isomatanaltypeid) REFERENCES ndb.isomaterialanalyzedtypes(isomatanaltypeid) ON DELETE SET NULL",
                    "table": "ndb.isometadata",
                    "referenced_table": "isomaterialanalyzedtypes",
                    "columns": [
                        "isomatanaltypeid"
                    ],
                    "referenced_columns": [
                        "isomatanaltypeid"
                    ]
                },
                {
                    "name": "isometadata_pkey",
                    "type": "PRIMARY KEY",
                    "def": "PRIMARY KEY (isometadataid)",
                    "table": "ndb.isometadata",
                    "referenced_table": "",
                    "columns": [
                        "isometadataid"
                    ]
                },
                {
                    "name": "fk_isometadata_isosubstratetypes",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (isosubstratetypeid) REFERENCES ndb.isosubstratetypes(isosubstratetypeid) ON UPDATE CASCADE ON DELETE SET NULL",
                    "table": "ndb.isometadata",
                    "referenced_table": "isosubstratetypes",
                    "columns": [
                        "isosubstratetypeid"
                    ],
                    "referenced_columns": [
                        "isosubstratetypeid"
                    ]
                }
            ],
            "triggers": [
                {
                    "name": "tr_sites_modifydate",
                    "def": "CREATE TRIGGER tr_sites_modifydate BEFORE INSERT OR UPDATE ON ndb.isometadata FOR EACH ROW EXECUTE FUNCTION ndb.update_recdatemodified()"
                }
            ]
        },
        {
            "name": "ndb.isopretreatmenttypes",
            "type": "BASE TABLE",
            "columns": [
                {
                    "name": "isopretreatmenttypeid",
                    "type": "integer",
                    "nullable": false,
                    "default": "nextval('ndb.seq_isopretreatmenttypes_isopretreatmenttypeid'::regclass)"
                },
                {
                    "name": "isopretreatmenttype",
                    "type": "varchar(50)",
                    "nullable": false
                },
                {
                    "name": "isopretreatmentqualifier",
                    "type": "varchar(50)",
                    "nullable": true
                },
                {
                    "name": "recdatecreated",
                    "type": "timestamp(0) without time zone",
                    "nullable": false,
                    "default": "timezone('UTC'::text, now())"
                },
                {
                    "name": "recdatemodified",
                    "type": "timestamp(0) without time zone",
                    "nullable": false
                }
            ],
            "indexes": [
                {
                    "name": "isopretreatmenttypes_pkey",
                    "def": "CREATE UNIQUE INDEX isopretreatmenttypes_pkey ON ndb.isopretreatmenttypes USING btree (isopretreatmenttypeid)",
                    "table": "ndb.isopretreatmenttypes",
                    "columns": [
                        "isopretreatmenttypeid"
                    ]
                }
            ],
            "constraints": [
                {
                    "name": "isopretreatmenttypes_pkey",
                    "type": "PRIMARY KEY",
                    "def": "PRIMARY KEY (isopretreatmenttypeid)",
                    "table": "ndb.isopretreatmenttypes",
                    "referenced_table": "",
                    "columns": [
                        "isopretreatmenttypeid"
                    ]
                }
            ],
            "triggers": [
                {
                    "name": "tr_sites_modifydate",
                    "def": "CREATE TRIGGER tr_sites_modifydate BEFORE INSERT OR UPDATE ON ndb.isopretreatmenttypes FOR EACH ROW EXECUTE FUNCTION ndb.update_recdatemodified()"
                }
            ]
        },
        {
            "name": "ndb.isosampleintrosystemtypes",
            "type": "BASE TABLE",
            "columns": [
                {
                    "name": "isosampleintrosystemtypeid",
                    "type": "integer",
                    "nullable": false,
                    "default": "nextval('ndb.seq_isosampleintrosystemtypes_isosampleintrosystemtypeid'::regclass)"
                },
                {
                    "name": "isosampleintrosystemtype",
                    "type": "varchar(256)",
                    "nullable": false
                },
                {
                    "name": "recdatecreated",
                    "type": "timestamp(0) without time zone",
                    "nullable": false,
                    "default": "timezone('UTC'::text, now())"
                },
                {
                    "name": "recdatemodified",
                    "type": "timestamp(0) without time zone",
                    "nullable": false
                }
            ],
            "indexes": [
                {
                    "name": "isosampleintrosystemtypes_pkey",
                    "def": "CREATE UNIQUE INDEX isosampleintrosystemtypes_pkey ON ndb.isosampleintrosystemtypes USING btree (isosampleintrosystemtypeid)",
                    "table": "ndb.isosampleintrosystemtypes",
                    "columns": [
                        "isosampleintrosystemtypeid"
                    ]
                }
            ],
            "constraints": [
                {
                    "name": "isosampleintrosystemtypes_pkey",
                    "type": "PRIMARY KEY",
                    "def": "PRIMARY KEY (isosampleintrosystemtypeid)",
                    "table": "ndb.isosampleintrosystemtypes",
                    "referenced_table": "",
                    "columns": [
                        "isosampleintrosystemtypeid"
                    ]
                }
            ],
            "triggers": [
                {
                    "name": "tr_sites_modifydate",
                    "def": "CREATE TRIGGER tr_sites_modifydate BEFORE INSERT OR UPDATE ON ndb.isosampleintrosystemtypes FOR EACH ROW EXECUTE FUNCTION ndb.update_recdatemodified()"
                }
            ]
        },
        {
            "name": "ndb.isosampleorigintypes",
            "type": "BASE TABLE",
            "columns": [
                {
                    "name": "isosampleorigintypeid",
                    "type": "integer",
                    "nullable": false,
                    "default": "nextval('ndb.seq_isosampleorigintypes_isosampleorigintypeid'::regclass)"
                },
                {
                    "name": "isosampleorigintype",
                    "type": "varchar(50)",
                    "nullable": false
                },
                {
                    "name": "recdatecreated",
                    "type": "timestamp(0) without time zone",
                    "nullable": false,
                    "default": "timezone('UTC'::text, now())"
                },
                {
                    "name": "recdatemodified",
                    "type": "timestamp(0) without time zone",
                    "nullable": false
                }
            ],
            "indexes": [
                {
                    "name": "isosampleorigintypes_pkey",
                    "def": "CREATE UNIQUE INDEX isosampleorigintypes_pkey ON ndb.isosampleorigintypes USING btree (isosampleorigintypeid)",
                    "table": "ndb.isosampleorigintypes",
                    "columns": [
                        "isosampleorigintypeid"
                    ]
                }
            ],
            "constraints": [
                {
                    "name": "isosampleorigintypes_pkey",
                    "type": "PRIMARY KEY",
                    "def": "PRIMARY KEY (isosampleorigintypeid)",
                    "table": "ndb.isosampleorigintypes",
                    "referenced_table": "",
                    "columns": [
                        "isosampleorigintypeid"
                    ]
                }
            ],
            "triggers": [
                {
                    "name": "tr_sites_modifydate",
                    "def": "CREATE TRIGGER tr_sites_modifydate BEFORE INSERT OR UPDATE ON ndb.isosampleorigintypes FOR EACH ROW EXECUTE FUNCTION ndb.update_recdatemodified()"
                }
            ]
        },
        {
            "name": "ndb.isosamplepretreatments",
            "type": "BASE TABLE",
            "columns": [
                {
                    "name": "dataid",
                    "type": "integer",
                    "nullable": false
                },
                {
                    "name": "isopretreatmenttypeid",
                    "type": "integer",
                    "nullable": false
                },
                {
                    "name": "order",
                    "type": "integer",
                    "nullable": false
                },
                {
                    "name": "value",
                    "type": "double precision",
                    "nullable": true
                },
                {
                    "name": "recdatecreated",
                    "type": "timestamp(0) without time zone",
                    "nullable": false,
                    "default": "timezone('UTC'::text, now())"
                },
                {
                    "name": "recdatemodified",
                    "type": "timestamp(0) without time zone",
                    "nullable": false
                }
            ],
            "indexes": [
                {
                    "name": "isosamplepretreatments_pkey",
                    "def": "CREATE UNIQUE INDEX isosamplepretreatments_pkey ON ndb.isosamplepretreatments USING btree (dataid, isopretreatmenttypeid, \"order\")",
                    "table": "ndb.isosamplepretreatments",
                    "columns": [
                        "dataid",
                        "isopretreatmenttypeid",
                        "order"
                    ]
                }
            ],
            "constraints": [
                {
                    "name": "fk_isosamplepretreatments_data",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (dataid) REFERENCES ndb.data(dataid) ON UPDATE CASCADE ON DELETE CASCADE",
                    "table": "ndb.isosamplepretreatments",
                    "referenced_table": "data",
                    "columns": [
                        "dataid"
                    ],
                    "referenced_columns": [
                        "dataid"
                    ]
                },
                {
                    "name": "fk_isosamplepretreatments_isopretratmenttypes",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (isopretreatmenttypeid) REFERENCES ndb.isopretreatmenttypes(isopretreatmenttypeid) ON UPDATE CASCADE ON DELETE CASCADE",
                    "table": "ndb.isosamplepretreatments",
                    "referenced_table": "isopretreatmenttypes",
                    "columns": [
                        "isopretreatmenttypeid"
                    ],
                    "referenced_columns": [
                        "isopretreatmenttypeid"
                    ]
                },
                {
                    "name": "isosamplepretreatments_pkey",
                    "type": "PRIMARY KEY",
                    "def": "PRIMARY KEY (dataid, isopretreatmenttypeid, \"order\")",
                    "table": "ndb.isosamplepretreatments",
                    "referenced_table": "",
                    "columns": [
                        "dataid",
                        "isopretreatmenttypeid",
                        "order"
                    ]
                }
            ],
            "triggers": [
                {
                    "name": "tr_sites_modifydate",
                    "def": "CREATE TRIGGER tr_sites_modifydate BEFORE INSERT OR UPDATE ON ndb.isosamplepretreatments FOR EACH ROW EXECUTE FUNCTION ndb.update_recdatemodified()"
                }
            ]
        },
        {
            "name": "ndb.isoscaletypes",
            "type": "BASE TABLE",
            "columns": [
                {
                    "name": "isoscaletypeid",
                    "type": "integer",
                    "nullable": false,
                    "default": "nextval('ndb.seq_isoscaletypes_isoscaletypeid'::regclass)"
                },
                {
                    "name": "isoscaleacronym",
                    "type": "varchar(24)",
                    "nullable": false
                },
                {
                    "name": "isoscalename",
                    "type": "varchar(80)",
                    "nullable": false
                },
                {
                    "name": "recdatecreated",
                    "type": "timestamp(0) without time zone",
                    "nullable": false,
                    "default": "timezone('UTC'::text, now())"
                },
                {
                    "name": "recdatemodified",
                    "type": "timestamp(0) without time zone",
                    "nullable": false
                }
            ],
            "indexes": [
                {
                    "name": "isoscaletypes_pkey",
                    "def": "CREATE UNIQUE INDEX isoscaletypes_pkey ON ndb.isoscaletypes USING btree (isoscaletypeid)",
                    "table": "ndb.isoscaletypes",
                    "columns": [
                        "isoscaletypeid"
                    ]
                }
            ],
            "constraints": [
                {
                    "name": "isoscaletypes_pkey",
                    "type": "PRIMARY KEY",
                    "def": "PRIMARY KEY (isoscaletypeid)",
                    "table": "ndb.isoscaletypes",
                    "referenced_table": "",
                    "columns": [
                        "isoscaletypeid"
                    ]
                }
            ],
            "triggers": [
                {
                    "name": "tr_sites_modifydate",
                    "def": "CREATE TRIGGER tr_sites_modifydate BEFORE INSERT OR UPDATE ON ndb.isoscaletypes FOR EACH ROW EXECUTE FUNCTION ndb.update_recdatemodified()"
                }
            ]
        },
        {
            "name": "ndb.isospecimendata",
            "type": "BASE TABLE",
            "columns": [
                {
                    "name": "isospecimendataid",
                    "type": "integer",
                    "nullable": false,
                    "default": "nextval('ndb.seq_isospecimendata_isospecimendataid'::regclass)"
                },
                {
                    "name": "dataid",
                    "type": "integer",
                    "nullable": false
                },
                {
                    "name": "specimenid",
                    "type": "integer",
                    "nullable": false
                },
                {
                    "name": "sd",
                    "type": "double precision",
                    "nullable": true
                },
                {
                    "name": "recdatecreated",
                    "type": "timestamp(0) without time zone",
                    "nullable": false,
                    "default": "timezone('UTC'::text, now())"
                },
                {
                    "name": "recdatemodified",
                    "type": "timestamp(0) without time zone",
                    "nullable": false
                }
            ],
            "indexes": [
                {
                    "name": "isospecimendata_pkey",
                    "def": "CREATE UNIQUE INDEX isospecimendata_pkey ON ndb.isospecimendata USING btree (isospecimendataid)",
                    "table": "ndb.isospecimendata",
                    "columns": [
                        "isospecimendataid"
                    ]
                }
            ],
            "constraints": [
                {
                    "name": "fk_isospecimendata_data",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (dataid) REFERENCES ndb.data(dataid) ON UPDATE CASCADE ON DELETE CASCADE",
                    "table": "ndb.isospecimendata",
                    "referenced_table": "data",
                    "columns": [
                        "dataid"
                    ],
                    "referenced_columns": [
                        "dataid"
                    ]
                },
                {
                    "name": "isospecimendata_pkey",
                    "type": "PRIMARY KEY",
                    "def": "PRIMARY KEY (isospecimendataid)",
                    "table": "ndb.isospecimendata",
                    "referenced_table": "",
                    "columns": [
                        "isospecimendataid"
                    ]
                },
                {
                    "name": "fk_isospecimendata_specimens",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (specimenid) REFERENCES ndb.specimens(specimenid) ON DELETE CASCADE",
                    "table": "ndb.isospecimendata",
                    "referenced_table": "specimens",
                    "columns": [
                        "specimenid"
                    ],
                    "referenced_columns": [
                        "specimenid"
                    ]
                }
            ],
            "triggers": [
                {
                    "name": "tr_sites_modifydate",
                    "def": "CREATE TRIGGER tr_sites_modifydate BEFORE INSERT OR UPDATE ON ndb.isospecimendata FOR EACH ROW EXECUTE FUNCTION ndb.update_recdatemodified()"
                }
            ]
        },
        {
            "name": "ndb.isosrmetadata",
            "type": "BASE TABLE",
            "columns": [
                {
                    "name": "datasetid",
                    "type": "integer",
                    "nullable": false
                },
                {
                    "name": "variableid",
                    "type": "integer",
                    "nullable": false
                },
                {
                    "name": "srlocalvalue",
                    "type": "double precision",
                    "nullable": true
                },
                {
                    "name": "srlocalgeolcontext",
                    "type": "text",
                    "nullable": true
                },
                {
                    "name": "recdatecreated",
                    "type": "timestamp(0) without time zone",
                    "nullable": false,
                    "default": "timezone('UTC'::text, now())"
                },
                {
                    "name": "recdatemodified",
                    "type": "timestamp(0) without time zone",
                    "nullable": false
                }
            ],
            "indexes": [
                {
                    "name": "isosrmetadata_pkey",
                    "def": "CREATE UNIQUE INDEX isosrmetadata_pkey ON ndb.isosrmetadata USING btree (datasetid, variableid)",
                    "table": "ndb.isosrmetadata",
                    "columns": [
                        "datasetid",
                        "variableid"
                    ]
                }
            ],
            "constraints": [
                {
                    "name": "fk_isosrmetadata_datasets",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (datasetid) REFERENCES ndb.datasets(datasetid) ON UPDATE CASCADE ON DELETE CASCADE",
                    "table": "ndb.isosrmetadata",
                    "referenced_table": "datasets",
                    "columns": [
                        "datasetid"
                    ],
                    "referenced_columns": [
                        "datasetid"
                    ]
                },
                {
                    "name": "isosrmetadata_pkey",
                    "type": "PRIMARY KEY",
                    "def": "PRIMARY KEY (datasetid, variableid)",
                    "table": "ndb.isosrmetadata",
                    "referenced_table": "",
                    "columns": [
                        "datasetid",
                        "variableid"
                    ]
                },
                {
                    "name": "fk_isosrmetadata_variables",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (variableid) REFERENCES ndb.variables(variableid) ON UPDATE CASCADE ON DELETE CASCADE",
                    "table": "ndb.isosrmetadata",
                    "referenced_table": "variables",
                    "columns": [
                        "variableid"
                    ],
                    "referenced_columns": [
                        "variableid"
                    ]
                }
            ],
            "triggers": [
                {
                    "name": "tr_sites_modifydate",
                    "def": "CREATE TRIGGER tr_sites_modifydate BEFORE INSERT OR UPDATE ON ndb.isosrmetadata FOR EACH ROW EXECUTE FUNCTION ndb.update_recdatemodified()"
                }
            ]
        },
        {
            "name": "ndb.isostandards",
            "type": "BASE TABLE",
            "columns": [
                {
                    "name": "datasetid",
                    "type": "integer",
                    "nullable": false
                },
                {
                    "name": "variableid",
                    "type": "integer",
                    "nullable": false
                },
                {
                    "name": "isostandardid",
                    "type": "integer",
                    "nullable": false
                },
                {
                    "name": "value",
                    "type": "double precision",
                    "nullable": false
                },
                {
                    "name": "recdatecreated",
                    "type": "timestamp(0) without time zone",
                    "nullable": false,
                    "default": "timezone('UTC'::text, now())"
                },
                {
                    "name": "recdatemodified",
                    "type": "timestamp(0) without time zone",
                    "nullable": false
                }
            ],
            "indexes": [
                {
                    "name": "isostandards_pkey",
                    "def": "CREATE UNIQUE INDEX isostandards_pkey ON ndb.isostandards USING btree (datasetid, variableid, isostandardid)",
                    "table": "ndb.isostandards",
                    "columns": [
                        "datasetid",
                        "variableid",
                        "isostandardid"
                    ]
                }
            ],
            "constraints": [
                {
                    "name": "fk_isostandards_datasets",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (datasetid) REFERENCES ndb.datasets(datasetid) ON UPDATE CASCADE ON DELETE CASCADE",
                    "table": "ndb.isostandards",
                    "referenced_table": "datasets",
                    "columns": [
                        "datasetid"
                    ],
                    "referenced_columns": [
                        "datasetid"
                    ]
                },
                {
                    "name": "isostandards_pkey",
                    "type": "PRIMARY KEY",
                    "def": "PRIMARY KEY (datasetid, variableid, isostandardid)",
                    "table": "ndb.isostandards",
                    "referenced_table": "",
                    "columns": [
                        "datasetid",
                        "variableid",
                        "isostandardid"
                    ]
                },
                {
                    "name": "fk_isostandards_isostandardtypes",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (isostandardid) REFERENCES ndb.isostandardtypes(isostandardtypeid) ON UPDATE CASCADE ON DELETE CASCADE",
                    "table": "ndb.isostandards",
                    "referenced_table": "isostandardtypes",
                    "columns": [
                        "isostandardid"
                    ],
                    "referenced_columns": [
                        "isostandardtypeid"
                    ]
                },
                {
                    "name": "fk_isostandards_variables",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (variableid) REFERENCES ndb.variables(variableid) ON UPDATE CASCADE ON DELETE CASCADE",
                    "table": "ndb.isostandards",
                    "referenced_table": "variables",
                    "columns": [
                        "variableid"
                    ],
                    "referenced_columns": [
                        "variableid"
                    ]
                }
            ],
            "triggers": [
                {
                    "name": "tr_sites_modifydate",
                    "def": "CREATE TRIGGER tr_sites_modifydate BEFORE INSERT OR UPDATE ON ndb.isostandards FOR EACH ROW EXECUTE FUNCTION ndb.update_recdatemodified()"
                }
            ]
        },
        {
            "name": "ndb.isostandardtypes",
            "type": "BASE TABLE",
            "columns": [
                {
                    "name": "isostandardtypeid",
                    "type": "integer",
                    "nullable": false,
                    "default": "nextval('ndb.seq_isostandardtypes_isostandardtypeid'::regclass)"
                },
                {
                    "name": "isostandardtype",
                    "type": "varchar(128)",
                    "nullable": false
                },
                {
                    "name": "isostandardmaterial",
                    "type": "varchar(128)",
                    "nullable": false
                },
                {
                    "name": "recdatecreated",
                    "type": "timestamp(0) without time zone",
                    "nullable": false,
                    "default": "timezone('UTC'::text, now())"
                },
                {
                    "name": "recdatemodified",
                    "type": "timestamp(0) without time zone",
                    "nullable": false
                }
            ],
            "indexes": [
                {
                    "name": "isostandardtypes_pkey",
                    "def": "CREATE UNIQUE INDEX isostandardtypes_pkey ON ndb.isostandardtypes USING btree (isostandardtypeid)",
                    "table": "ndb.isostandardtypes",
                    "columns": [
                        "isostandardtypeid"
                    ]
                }
            ],
            "constraints": [
                {
                    "name": "isostandardtypes_pkey",
                    "type": "PRIMARY KEY",
                    "def": "PRIMARY KEY (isostandardtypeid)",
                    "table": "ndb.isostandardtypes",
                    "referenced_table": "",
                    "columns": [
                        "isostandardtypeid"
                    ]
                }
            ],
            "triggers": [
                {
                    "name": "tr_sites_modifydate",
                    "def": "CREATE TRIGGER tr_sites_modifydate BEFORE INSERT OR UPDATE ON ndb.isostandardtypes FOR EACH ROW EXECUTE FUNCTION ndb.update_recdatemodified()"
                }
            ]
        },
        {
            "name": "ndb.isostratdata",
            "type": "BASE TABLE",
            "columns": [
                {
                    "name": "dataid",
                    "type": "integer",
                    "nullable": false
                },
                {
                    "name": "sd",
                    "type": "double precision",
                    "nullable": true
                },
                {
                    "name": "taxonid",
                    "type": "integer",
                    "nullable": true
                },
                {
                    "name": "elementtypeid",
                    "type": "integer",
                    "nullable": true
                },
                {
                    "name": "recdatecreated",
                    "type": "timestamp(0) without time zone",
                    "nullable": false,
                    "default": "timezone('UTC'::text, now())"
                },
                {
                    "name": "recdatemodified",
                    "type": "timestamp(0) without time zone",
                    "nullable": false
                }
            ],
            "indexes": [
                {
                    "name": "isostratdata_pkey",
                    "def": "CREATE UNIQUE INDEX isostratdata_pkey ON ndb.isostratdata USING btree (dataid)",
                    "table": "ndb.isostratdata",
                    "columns": [
                        "dataid"
                    ]
                }
            ],
            "constraints": [
                {
                    "name": "fk_isostratdata_data",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (dataid) REFERENCES ndb.data(dataid) ON UPDATE CASCADE ON DELETE CASCADE",
                    "table": "ndb.isostratdata",
                    "referenced_table": "data",
                    "columns": [
                        "dataid"
                    ],
                    "referenced_columns": [
                        "dataid"
                    ]
                },
                {
                    "name": "fk_isostratdata_elementtypes",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (elementtypeid) REFERENCES ndb.elementtypes(elementtypeid) ON UPDATE CASCADE ON DELETE CASCADE",
                    "table": "ndb.isostratdata",
                    "referenced_table": "elementtypes",
                    "columns": [
                        "elementtypeid"
                    ],
                    "referenced_columns": [
                        "elementtypeid"
                    ]
                },
                {
                    "name": "isostratdata_pkey",
                    "type": "PRIMARY KEY",
                    "def": "PRIMARY KEY (dataid)",
                    "table": "ndb.isostratdata",
                    "referenced_table": "",
                    "columns": [
                        "dataid"
                    ]
                },
                {
                    "name": "fk_isostratdata_taxa",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (taxonid) REFERENCES ndb.taxa(taxonid)",
                    "table": "ndb.isostratdata",
                    "referenced_table": "taxa",
                    "columns": [
                        "taxonid"
                    ],
                    "referenced_columns": [
                        "taxonid"
                    ]
                }
            ],
            "triggers": [
                {
                    "name": "tr_sites_modifydate",
                    "def": "CREATE TRIGGER tr_sites_modifydate BEFORE INSERT OR UPDATE ON ndb.isostratdata FOR EACH ROW EXECUTE FUNCTION ndb.update_recdatemodified()"
                }
            ]
        },
        {
            "name": "ndb.isosubstratetypes",
            "type": "BASE TABLE",
            "columns": [
                {
                    "name": "isosubstratetypeid",
                    "type": "integer",
                    "nullable": false,
                    "default": "nextval('ndb.seq_isosubstratetypes_isosubstratetypeid'::regclass)"
                },
                {
                    "name": "isosubstratetype",
                    "type": "varchar(50)",
                    "nullable": false
                },
                {
                    "name": "recdatecreated",
                    "type": "timestamp(0) without time zone",
                    "nullable": false,
                    "default": "timezone('UTC'::text, now())"
                },
                {
                    "name": "recdatemodified",
                    "type": "timestamp(0) without time zone",
                    "nullable": false
                }
            ],
            "indexes": [
                {
                    "name": "isosubstratetypes_pkey",
                    "def": "CREATE UNIQUE INDEX isosubstratetypes_pkey ON ndb.isosubstratetypes USING btree (isosubstratetypeid)",
                    "table": "ndb.isosubstratetypes",
                    "columns": [
                        "isosubstratetypeid"
                    ]
                }
            ],
            "constraints": [
                {
                    "name": "isosubstratetypes_pkey",
                    "type": "PRIMARY KEY",
                    "def": "PRIMARY KEY (isosubstratetypeid)",
                    "table": "ndb.isosubstratetypes",
                    "referenced_table": "",
                    "columns": [
                        "isosubstratetypeid"
                    ]
                }
            ],
            "triggers": [
                {
                    "name": "tr_sites_modifydate",
                    "def": "CREATE TRIGGER tr_sites_modifydate BEFORE INSERT OR UPDATE ON ndb.isosubstratetypes FOR EACH ROW EXECUTE FUNCTION ndb.update_recdatemodified()"
                }
            ]
        },
        {
            "name": "ndb.isovariablescaletypes",
            "type": "BASE TABLE",
            "columns": [
                {
                    "name": "variableid",
                    "type": "integer",
                    "nullable": false
                },
                {
                    "name": "isoscaletypeid",
                    "type": "integer",
                    "nullable": false
                },
                {
                    "name": "recdatecreated",
                    "type": "timestamp(0) without time zone",
                    "nullable": false,
                    "default": "timezone('UTC'::text, now())"
                },
                {
                    "name": "recdatemodified",
                    "type": "timestamp(0) without time zone",
                    "nullable": false
                }
            ],
            "indexes": [
                {
                    "name": "isovariablescaletypes_pkey",
                    "def": "CREATE UNIQUE INDEX isovariablescaletypes_pkey ON ndb.isovariablescaletypes USING btree (variableid, isoscaletypeid)",
                    "table": "ndb.isovariablescaletypes",
                    "columns": [
                        "variableid",
                        "isoscaletypeid"
                    ]
                }
            ],
            "constraints": [
                {
                    "name": "fk_isovariablescaletypes_isoscaletypes",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (isoscaletypeid) REFERENCES ndb.isoscaletypes(isoscaletypeid) ON UPDATE CASCADE ON DELETE CASCADE",
                    "table": "ndb.isovariablescaletypes",
                    "referenced_table": "isoscaletypes",
                    "columns": [
                        "isoscaletypeid"
                    ],
                    "referenced_columns": [
                        "isoscaletypeid"
                    ]
                },
                {
                    "name": "isovariablescaletypes_pkey",
                    "type": "PRIMARY KEY",
                    "def": "PRIMARY KEY (variableid, isoscaletypeid)",
                    "table": "ndb.isovariablescaletypes",
                    "referenced_table": "",
                    "columns": [
                        "variableid",
                        "isoscaletypeid"
                    ]
                },
                {
                    "name": "fk_isovariablescaletypes_variables",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (variableid) REFERENCES ndb.variables(variableid) ON UPDATE CASCADE ON DELETE CASCADE",
                    "table": "ndb.isovariablescaletypes",
                    "referenced_table": "variables",
                    "columns": [
                        "variableid"
                    ],
                    "referenced_columns": [
                        "variableid"
                    ]
                }
            ],
            "triggers": [
                {
                    "name": "tr_sites_modifydate",
                    "def": "CREATE TRIGGER tr_sites_modifydate BEFORE INSERT OR UPDATE ON ndb.isovariablescaletypes FOR EACH ROW EXECUTE FUNCTION ndb.update_recdatemodified()"
                }
            ]
        },
        {
            "name": "ndb.keywords",
            "type": "BASE TABLE",
            "comment": "Lookup table of Keywords referenced by the SampleKeywords table. The table provides a means to identify samples sharing a common attribute. For example, the keyword «modern sample» identifies modern surface samples in the database. These samples include individual surface samples, as well as core tops. Although not implemented, a «pre-European settlement» keyword would be a means to identify samples just predating European settlement.",
            "columns": [
                {
                    "name": "keywordid",
                    "type": "integer",
                    "nullable": false,
                    "default": "nextval('ndb.seq_keywords_keywordid'::regclass)",
                    "comment": "An arbitrary Keyword identification number."
                },
                {
                    "name": "keyword",
                    "type": "varchar(64)",
                    "nullable": false,
                    "comment": "A keyword for identifying samples sharing a common attribute."
                },
                {
                    "name": "recdatecreated",
                    "type": "timestamp(0) without time zone",
                    "nullable": false,
                    "default": "timezone('UTC'::text, now())"
                },
                {
                    "name": "recdatemodified",
                    "type": "timestamp(0) without time zone",
                    "nullable": false
                }
            ],
            "indexes": [
                {
                    "name": "keywords_pkey",
                    "def": "CREATE UNIQUE INDEX keywords_pkey ON ndb.keywords USING btree (keywordid)",
                    "table": "ndb.keywords",
                    "columns": [
                        "keywordid"
                    ]
                }
            ],
            "constraints": [
                {
                    "name": "keywords_pkey",
                    "type": "PRIMARY KEY",
                    "def": "PRIMARY KEY (keywordid)",
                    "table": "ndb.keywords",
                    "referenced_table": "",
                    "columns": [
                        "keywordid"
                    ]
                }
            ],
            "triggers": [
                {
                    "name": "tr_sites_modifydate",
                    "def": "CREATE TRIGGER tr_sites_modifydate BEFORE INSERT OR UPDATE ON ndb.keywords FOR EACH ROW EXECUTE FUNCTION ndb.update_recdatemodified()"
                }
            ]
        },
        {
            "name": "ndb.lakeparameters",
            "type": "BASE TABLE",
            "columns": [
                {
                    "name": "siteid",
                    "type": "integer",
                    "nullable": false,
                    "comment": "FK: SiteID links to Sites table"
                },
                {
                    "name": "lakeparameterid",
                    "type": "integer",
                    "nullable": false,
                    "comment": "FK: LakeParameter ID links to LakeParameterTypes table"
                },
                {
                    "name": "value",
                    "type": "double precision",
                    "nullable": false,
                    "comment": "Numerical value of parameter"
                },
                {
                    "name": "recdatecreated",
                    "type": "timestamp(0) without time zone",
                    "nullable": false,
                    "default": "timezone('UTC'::text, now())"
                },
                {
                    "name": "recdatemodified",
                    "type": "timestamp(0) without time zone",
                    "nullable": false
                }
            ],
            "indexes": [
                {
                    "name": "lakeparameters_pkey",
                    "def": "CREATE UNIQUE INDEX lakeparameters_pkey ON ndb.lakeparameters USING btree (siteid, lakeparameterid)",
                    "table": "ndb.lakeparameters",
                    "columns": [
                        "siteid",
                        "lakeparameterid"
                    ]
                },
                {
                    "name": "ix_lakeparameterid_lakeparameters",
                    "def": "CREATE INDEX ix_lakeparameterid_lakeparameters ON ndb.lakeparameters USING btree (lakeparameterid) WITH (fillfactor='10')",
                    "table": "ndb.lakeparameters",
                    "columns": [
                        "lakeparameterid"
                    ]
                },
                {
                    "name": "ix_siteid_lakeparameters",
                    "def": "CREATE INDEX ix_siteid_lakeparameters ON ndb.lakeparameters USING btree (siteid) WITH (fillfactor='10')",
                    "table": "ndb.lakeparameters",
                    "columns": [
                        "siteid"
                    ]
                }
            ],
            "constraints": [
                {
                    "name": "lakeparameters_pkey",
                    "type": "PRIMARY KEY",
                    "def": "PRIMARY KEY (siteid, lakeparameterid)",
                    "table": "ndb.lakeparameters",
                    "referenced_table": "",
                    "columns": [
                        "siteid",
                        "lakeparameterid"
                    ]
                },
                {
                    "name": "fk_lakeparameters_lakeparametertypes",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (lakeparameterid) REFERENCES ndb.lakeparametertypes(lakeparameterid) ON UPDATE CASCADE ON DELETE CASCADE",
                    "table": "ndb.lakeparameters",
                    "referenced_table": "lakeparametertypes",
                    "columns": [
                        "lakeparameterid"
                    ],
                    "referenced_columns": [
                        "lakeparameterid"
                    ]
                },
                {
                    "name": "fk_lakeparameters_sites",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (siteid) REFERENCES ndb.sites(siteid) ON UPDATE CASCADE ON DELETE CASCADE",
                    "table": "ndb.lakeparameters",
                    "referenced_table": "sites",
                    "columns": [
                        "siteid"
                    ],
                    "referenced_columns": [
                        "siteid"
                    ]
                }
            ],
            "triggers": [
                {
                    "name": "tr_sites_modifydate",
                    "def": "CREATE TRIGGER tr_sites_modifydate BEFORE INSERT OR UPDATE ON ndb.lakeparameters FOR EACH ROW EXECUTE FUNCTION ndb.update_recdatemodified()"
                }
            ]
        },
        {
            "name": "ndb.leadmodelbasis",
            "type": "BASE TABLE",
            "columns": [
                {
                    "name": "pbbasisid",
                    "type": "integer",
                    "nullable": false,
                    "default": "nextval('ndb.leadmodelbasis_pbbasisid_seq'::regclass)"
                },
                {
                    "name": "pbbasis",
                    "type": "text",
                    "nullable": true
                }
            ],
            "indexes": [
                {
                    "name": "leadmodelbasis_pkey",
                    "def": "CREATE UNIQUE INDEX leadmodelbasis_pkey ON ndb.leadmodelbasis USING btree (pbbasisid)",
                    "table": "ndb.leadmodelbasis",
                    "columns": [
                        "pbbasisid"
                    ]
                }
            ],
            "constraints": [
                {
                    "name": "leadmodelbasis_pkey",
                    "type": "PRIMARY KEY",
                    "def": "PRIMARY KEY (pbbasisid)",
                    "table": "ndb.leadmodelbasis",
                    "referenced_table": "",
                    "columns": [
                        "pbbasisid"
                    ]
                }
            ]
        },
        {
            "name": "ndb.lithology",
            "type": "BASE TABLE",
            "comment": "This table stores the lithologic descriptions of Collection Units.",
            "columns": [
                {
                    "name": "lithologyid",
                    "type": "integer",
                    "nullable": false,
                    "default": "nextval('ndb.seq_lithology_lithologyid'::regclass)",
                    "comment": "An arbitrary identification number for a lithologic unit."
                },
                {
                    "name": "collectionunitid",
                    "type": "integer",
                    "nullable": false,
                    "comment": "Collection Unit identification number. Field links to the CollectionUnits table."
                },
                {
                    "name": "depthtop",
                    "type": "double precision",
                    "nullable": true,
                    "comment": "Depth of the top of the lithologic unit in cm."
                },
                {
                    "name": "depthbottom",
                    "type": "double precision",
                    "nullable": true,
                    "comment": "Depth of the bottom of the lithologic unit in cm."
                },
                {
                    "name": "lowerboundary",
                    "type": "varchar(255)",
                    "nullable": true
                },
                {
                    "name": "description",
                    "type": "text",
                    "nullable": true,
                    "comment": "Description of the lithologic unit. These can be quite detailed, with Munsell color or Troels-Smith descriptions. Some examples:\ninterbedded gray silt and peat\nmarly fine-detritus copropel\nhumified sedge and Sphagnum peat\nsedge peat 5YR 5/4\ngray sandy loam with mammoth and other animal bones\ngrey-green gyttja, oxidizing to gray-brown\nAg 3, Ga 1, medium gray, firm, elastic\nnig3, strf0, elas2, sicc0; Th2 T12 Tb+\nLd°4, Ga+, Dg+, Dh+"
                },
                {
                    "name": "recdatecreated",
                    "type": "timestamp(0) without time zone",
                    "nullable": false,
                    "default": "timezone('UTC'::text, now())"
                },
                {
                    "name": "recdatemodified",
                    "type": "timestamp(0) without time zone",
                    "nullable": false
                }
            ],
            "indexes": [
                {
                    "name": "lithology_pkey",
                    "def": "CREATE UNIQUE INDEX lithology_pkey ON ndb.lithology USING btree (lithologyid)",
                    "table": "ndb.lithology",
                    "columns": [
                        "lithologyid"
                    ]
                },
                {
                    "name": "ix_collectionunitid_lithology",
                    "def": "CREATE INDEX ix_collectionunitid_lithology ON ndb.lithology USING btree (collectionunitid) WITH (fillfactor='10')",
                    "table": "ndb.lithology",
                    "columns": [
                        "collectionunitid"
                    ]
                }
            ],
            "constraints": [
                {
                    "name": "fk_lithology_collectionunits",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (collectionunitid) REFERENCES ndb.collectionunits(collectionunitid) ON UPDATE CASCADE ON DELETE CASCADE",
                    "table": "ndb.lithology",
                    "referenced_table": "collectionunits",
                    "columns": [
                        "collectionunitid"
                    ],
                    "referenced_columns": [
                        "collectionunitid"
                    ]
                },
                {
                    "name": "lithology_pkey",
                    "type": "PRIMARY KEY",
                    "def": "PRIMARY KEY (lithologyid)",
                    "table": "ndb.lithology",
                    "referenced_table": "",
                    "columns": [
                        "lithologyid"
                    ]
                }
            ],
            "triggers": [
                {
                    "name": "tr_sites_modifydate",
                    "def": "CREATE TRIGGER tr_sites_modifydate BEFORE INSERT OR UPDATE ON ndb.lithology FOR EACH ROW EXECUTE FUNCTION ndb.update_recdatemodified()"
                }
            ]
        },
        {
            "name": "ndb.lithostrat",
            "type": "BASE TABLE",
            "columns": [
                {
                    "name": "lithostratid",
                    "type": "integer",
                    "nullable": false,
                    "default": "nextval('ndb.seq_lithostrat_lithostratid'::regclass)"
                },
                {
                    "name": "lithostratunitid",
                    "type": "integer",
                    "nullable": false
                },
                {
                    "name": "lithostratname",
                    "type": "varchar(64)",
                    "nullable": false
                },
                {
                    "name": "higherlithostratid",
                    "type": "integer",
                    "nullable": false
                },
                {
                    "name": "recdatecreated",
                    "type": "timestamp(0) without time zone",
                    "nullable": false,
                    "default": "timezone('UTC'::text, now())"
                },
                {
                    "name": "recdatemodified",
                    "type": "timestamp(0) without time zone",
                    "nullable": false
                }
            ],
            "indexes": [
                {
                    "name": "lithostrat_pkey",
                    "def": "CREATE UNIQUE INDEX lithostrat_pkey ON ndb.lithostrat USING btree (lithostratid)",
                    "table": "ndb.lithostrat",
                    "columns": [
                        "lithostratid"
                    ]
                }
            ],
            "constraints": [
                {
                    "name": "fk_higherlithostratid",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (higherlithostratid) REFERENCES ndb.lithostrat(lithostratid)",
                    "table": "ndb.lithostrat",
                    "referenced_table": "lithostrat",
                    "columns": [
                        "higherlithostratid"
                    ],
                    "referenced_columns": [
                        "lithostratid"
                    ]
                },
                {
                    "name": "lithostrat_pkey",
                    "type": "PRIMARY KEY",
                    "def": "PRIMARY KEY (lithostratid)",
                    "table": "ndb.lithostrat",
                    "referenced_table": "",
                    "columns": [
                        "lithostratid"
                    ]
                },
                {
                    "name": "fk_lithostratunits_lithostrattypes",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (lithostratunitid) REFERENCES ndb.lithostratunits(lithostratunitid) ON UPDATE CASCADE ON DELETE CASCADE",
                    "table": "ndb.lithostrat",
                    "referenced_table": "lithostratunits",
                    "columns": [
                        "lithostratunitid"
                    ],
                    "referenced_columns": [
                        "lithostratunitid"
                    ]
                }
            ],
            "triggers": [
                {
                    "name": "tr_sites_modifydate",
                    "def": "CREATE TRIGGER tr_sites_modifydate BEFORE INSERT OR UPDATE ON ndb.lithostrat FOR EACH ROW EXECUTE FUNCTION ndb.update_recdatemodified()"
                }
            ]
        },
        {
            "name": "ndb.lithostratunits",
            "type": "BASE TABLE",
            "columns": [
                {
                    "name": "lithostratunitid",
                    "type": "integer",
                    "nullable": false,
                    "default": "nextval('ndb.seq_lithostratunits_lithostratunitid'::regclass)"
                },
                {
                    "name": "lithostratunit",
                    "type": "varchar(24)",
                    "nullable": false
                },
                {
                    "name": "rank",
                    "type": "integer",
                    "nullable": false
                },
                {
                    "name": "recdatecreated",
                    "type": "timestamp(0) without time zone",
                    "nullable": false,
                    "default": "timezone('UTC'::text, now())"
                },
                {
                    "name": "recdatemodified",
                    "type": "timestamp(0) without time zone",
                    "nullable": false
                }
            ],
            "indexes": [
                {
                    "name": "lithostratunits_pkey",
                    "def": "CREATE UNIQUE INDEX lithostratunits_pkey ON ndb.lithostratunits USING btree (lithostratunitid)",
                    "table": "ndb.lithostratunits",
                    "columns": [
                        "lithostratunitid"
                    ]
                }
            ],
            "constraints": [
                {
                    "name": "lithostratunits_pkey",
                    "type": "PRIMARY KEY",
                    "def": "PRIMARY KEY (lithostratunitid)",
                    "table": "ndb.lithostratunits",
                    "referenced_table": "",
                    "columns": [
                        "lithostratunitid"
                    ]
                }
            ],
            "triggers": [
                {
                    "name": "tr_sites_modifydate",
                    "def": "CREATE TRIGGER tr_sites_modifydate BEFORE INSERT OR UPDATE ON ndb.lithostratunits FOR EACH ROW EXECUTE FUNCTION ndb.update_recdatemodified()"
                }
            ]
        },
        {
            "name": "ndb.publicationeditors",
            "type": "BASE TABLE",
            "comment": "This table stores the editors of publications for which chapters or sections are the primary bibliographic entries. Chapter authors are stored in the PublicatonAuthors table, where they are linked to the Contacts table. However, publication editors are not cross-referenced in the Contacts table, because chapter authors are the principal citation.",
            "columns": [
                {
                    "name": "editorid",
                    "type": "integer",
                    "nullable": false,
                    "default": "nextval('ndb.seq_publicationeditors_editorid'::regclass)",
                    "comment": "An arbitrary Editor identification number."
                },
                {
                    "name": "publicationid",
                    "type": "integer",
                    "nullable": false,
                    "comment": "Publication identification number. Field links to the Publications table."
                },
                {
                    "name": "editororder",
                    "type": "integer",
                    "nullable": true,
                    "comment": "Ordinal number for the position in which the editor’s name appears in the publication’s author list."
                },
                {
                    "name": "familyname",
                    "type": "varchar(64)",
                    "nullable": true,
                    "comment": "Family name of editor"
                },
                {
                    "name": "initials",
                    "type": "varchar(8)",
                    "nullable": true,
                    "comment": "Initials of editor’s given names"
                },
                {
                    "name": "suffix",
                    "type": "varchar(8)",
                    "nullable": true,
                    "comment": "Authors suffix (e.g. «Jr.»)"
                },
                {
                    "name": "recdatecreated",
                    "type": "timestamp(0) without time zone",
                    "nullable": false,
                    "default": "timezone('UTC'::text, now())"
                },
                {
                    "name": "recdatemodified",
                    "type": "timestamp(0) without time zone",
                    "nullable": false
                }
            ],
            "indexes": [
                {
                    "name": "publicationeditors_pkey",
                    "def": "CREATE UNIQUE INDEX publicationeditors_pkey ON ndb.publicationeditors USING btree (editorid)",
                    "table": "ndb.publicationeditors",
                    "columns": [
                        "editorid"
                    ]
                },
                {
                    "name": "ix_publicationid_publicationeditors",
                    "def": "CREATE INDEX ix_publicationid_publicationeditors ON ndb.publicationeditors USING btree (publicationid) WITH (fillfactor='10')",
                    "table": "ndb.publicationeditors",
                    "columns": [
                        "publicationid"
                    ]
                }
            ],
            "constraints": [
                {
                    "name": "publicationeditors_pkey",
                    "type": "PRIMARY KEY",
                    "def": "PRIMARY KEY (editorid)",
                    "table": "ndb.publicationeditors",
                    "referenced_table": "",
                    "columns": [
                        "editorid"
                    ]
                },
                {
                    "name": "fk_publicationeditors_publications",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (publicationid) REFERENCES ndb.publications(publicationid) ON UPDATE CASCADE ON DELETE CASCADE",
                    "table": "ndb.publicationeditors",
                    "referenced_table": "publications",
                    "columns": [
                        "publicationid"
                    ],
                    "referenced_columns": [
                        "publicationid"
                    ]
                }
            ],
            "triggers": [
                {
                    "name": "tr_sites_modifydate",
                    "def": "CREATE TRIGGER tr_sites_modifydate BEFORE INSERT OR UPDATE ON ndb.publicationeditors FOR EACH ROW EXECUTE FUNCTION ndb.update_recdatemodified()"
                }
            ]
        },
        {
            "name": "ndb.publicationtranslators",
            "type": "BASE TABLE",
            "columns": [
                {
                    "name": "translatorid",
                    "type": "integer",
                    "nullable": false,
                    "default": "nextval('ndb.seq_publicationtranslators_translatorid'::regclass)"
                },
                {
                    "name": "publicationid",
                    "type": "integer",
                    "nullable": false
                },
                {
                    "name": "translatororder",
                    "type": "integer",
                    "nullable": true
                },
                {
                    "name": "familyname",
                    "type": "varchar(64)",
                    "nullable": true
                },
                {
                    "name": "initials",
                    "type": "varchar(8)",
                    "nullable": true
                },
                {
                    "name": "suffix",
                    "type": "varchar(8)",
                    "nullable": true
                },
                {
                    "name": "recdatecreated",
                    "type": "timestamp(0) without time zone",
                    "nullable": false,
                    "default": "timezone('UTC'::text, now())"
                },
                {
                    "name": "recdatemodified",
                    "type": "timestamp(0) without time zone",
                    "nullable": false
                }
            ],
            "indexes": [
                {
                    "name": "publicationtranslators_pkey",
                    "def": "CREATE UNIQUE INDEX publicationtranslators_pkey ON ndb.publicationtranslators USING btree (translatorid)",
                    "table": "ndb.publicationtranslators",
                    "columns": [
                        "translatorid"
                    ]
                }
            ],
            "constraints": [
                {
                    "name": "fk_publicationtranslators_publications",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (publicationid) REFERENCES ndb.publications(publicationid) ON UPDATE CASCADE ON DELETE CASCADE",
                    "table": "ndb.publicationtranslators",
                    "referenced_table": "publications",
                    "columns": [
                        "publicationid"
                    ],
                    "referenced_columns": [
                        "publicationid"
                    ]
                },
                {
                    "name": "publicationtranslators_pkey",
                    "type": "PRIMARY KEY",
                    "def": "PRIMARY KEY (translatorid)",
                    "table": "ndb.publicationtranslators",
                    "referenced_table": "",
                    "columns": [
                        "translatorid"
                    ]
                }
            ],
            "triggers": [
                {
                    "name": "tr_sites_modifydate",
                    "def": "CREATE TRIGGER tr_sites_modifydate BEFORE INSERT OR UPDATE ON ndb.publicationtranslators FOR EACH ROW EXECUTE FUNCTION ndb.update_recdatemodified()"
                }
            ]
        },
        {
            "name": "ndb.pubtsv",
            "type": "VIEW",
            "columns": [
                {
                    "name": "publicationid",
                    "type": "integer",
                    "nullable": true
                },
                {
                    "name": "pubtsv",
                    "type": "tsvector",
                    "nullable": true
                }
            ],
            "def": "CREATE VIEW pubtsv AS (\n SELECT pu.publicationid,\n    (((((setweight(to_tsvector(COALESCE(pu.articletitle, ''::text)), 'A'::\"char\") || setweight(to_tsvector(COALESCE(pu.booktitle, ''::text)), 'A'::\"char\")) || setweight(to_tsvector(COALESCE(pu.journal, ''::text)), 'B'::\"char\")) || setweight(to_tsvector(COALESCE(pu.seriestitle, ''::text)), 'B'::\"char\")) || setweight(to_tsvector(COALESCE(pu.volumetitle, ''::text)), 'B'::\"char\")) || setweight(to_tsvector(COALESCE(pu.citation, ''::text)), 'C'::\"char\")) AS pubtsv\n   FROM ndb.publications pu\n)",
            "referenced_tables": [
                "ndb.publications"
            ]
        },
        {
            "name": "ndb.radiocarbon",
            "type": "BASE TABLE",
            "columns": [
                {
                    "name": "geochronid",
                    "type": "integer",
                    "nullable": false
                },
                {
                    "name": "radiocarbonmethodid",
                    "type": "integer",
                    "nullable": true
                },
                {
                    "name": "percentc",
                    "type": "double precision",
                    "nullable": true
                },
                {
                    "name": "percentn",
                    "type": "double precision",
                    "nullable": true
                },
                {
                    "name": "delta13c",
                    "type": "double precision",
                    "nullable": true
                },
                {
                    "name": "delta15n",
                    "type": "double precision",
                    "nullable": true
                },
                {
                    "name": "percentcollagen",
                    "type": "double precision",
                    "nullable": true
                },
                {
                    "name": "reservoir",
                    "type": "double precision",
                    "nullable": true
                },
                {
                    "name": "recdatecreated",
                    "type": "timestamp(0) without time zone",
                    "nullable": false,
                    "default": "timezone('UTC'::text, now())"
                },
                {
                    "name": "recdatemodified",
                    "type": "timestamp(0) without time zone",
                    "nullable": false
                },
                {
                    "name": "masscmg",
                    "type": "double precision",
                    "nullable": true
                },
                {
                    "name": "cnratio",
                    "type": "double precision",
                    "nullable": true
                }
            ],
            "indexes": [
                {
                    "name": "radiocarbon_pkey",
                    "def": "CREATE UNIQUE INDEX radiocarbon_pkey ON ndb.radiocarbon USING btree (geochronid)",
                    "table": "ndb.radiocarbon",
                    "columns": [
                        "geochronid"
                    ]
                },
                {
                    "name": "radiocarbon_unique",
                    "def": "CREATE UNIQUE INDEX radiocarbon_unique ON ndb.radiocarbon USING btree (geochronid)",
                    "table": "ndb.radiocarbon",
                    "columns": [
                        "geochronid"
                    ]
                }
            ],
            "constraints": [
                {
                    "name": "fk_geochrons_geochronid",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (geochronid) REFERENCES ndb.geochronology(geochronid) ON DELETE CASCADE",
                    "table": "ndb.radiocarbon",
                    "referenced_table": "geochronology",
                    "columns": [
                        "geochronid"
                    ],
                    "referenced_columns": [
                        "geochronid"
                    ]
                },
                {
                    "name": "radiocarbon_pkey",
                    "type": "PRIMARY KEY",
                    "def": "PRIMARY KEY (geochronid)",
                    "table": "ndb.radiocarbon",
                    "referenced_table": "",
                    "columns": [
                        "geochronid"
                    ]
                },
                {
                    "name": "fk_radiocarbonmethodid",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (radiocarbonmethodid) REFERENCES ndb.radiocarbonmethods(radiocarbonmethodid)",
                    "table": "ndb.radiocarbon",
                    "referenced_table": "radiocarbonmethods",
                    "columns": [
                        "radiocarbonmethodid"
                    ],
                    "referenced_columns": [
                        "radiocarbonmethodid"
                    ]
                },
                {
                    "name": "radiocarbon_unique",
                    "type": "UNIQUE",
                    "def": "UNIQUE (geochronid)",
                    "table": "ndb.radiocarbon",
                    "referenced_table": "",
                    "columns": [
                        "geochronid"
                    ]
                }
            ],
            "triggers": [
                {
                    "name": "cnratio_compute_trigger",
                    "def": "CREATE TRIGGER cnratio_compute_trigger BEFORE INSERT OR UPDATE ON ndb.radiocarbon FOR EACH ROW EXECUTE FUNCTION ndb.compute_cnratio()"
                },
                {
                    "name": "tr_sites_modifydate",
                    "def": "CREATE TRIGGER tr_sites_modifydate BEFORE INSERT OR UPDATE ON ndb.radiocarbon FOR EACH ROW EXECUTE FUNCTION ndb.update_recdatemodified()"
                }
            ]
        },
        {
            "name": "ndb.radiocarbonmethods",
            "type": "BASE TABLE",
            "columns": [
                {
                    "name": "radiocarbonmethodid",
                    "type": "integer",
                    "nullable": false,
                    "default": "nextval('ndb.seq_radiocarbonmethods_radiocarbonmethodid'::regclass)"
                },
                {
                    "name": "radiocarbonmethod",
                    "type": "varchar(64)",
                    "nullable": false
                },
                {
                    "name": "recdatecreated",
                    "type": "timestamp(0) without time zone",
                    "nullable": false,
                    "default": "timezone('UTC'::text, now())"
                },
                {
                    "name": "recdatemodified",
                    "type": "timestamp(0) without time zone",
                    "nullable": false
                }
            ],
            "indexes": [
                {
                    "name": "radiocarbonmethods_pkey",
                    "def": "CREATE UNIQUE INDEX radiocarbonmethods_pkey ON ndb.radiocarbonmethods USING btree (radiocarbonmethodid)",
                    "table": "ndb.radiocarbonmethods",
                    "columns": [
                        "radiocarbonmethodid"
                    ]
                }
            ],
            "constraints": [
                {
                    "name": "radiocarbonmethods_pkey",
                    "type": "PRIMARY KEY",
                    "def": "PRIMARY KEY (radiocarbonmethodid)",
                    "table": "ndb.radiocarbonmethods",
                    "referenced_table": "",
                    "columns": [
                        "radiocarbonmethodid"
                    ]
                }
            ],
            "triggers": [
                {
                    "name": "tr_sites_modifydate",
                    "def": "CREATE TRIGGER tr_sites_modifydate BEFORE INSERT OR UPDATE ON ndb.radiocarbonmethods FOR EACH ROW EXECUTE FUNCTION ndb.update_recdatemodified()"
                }
            ]
        },
        {
            "name": "ndb.relativeagepublications",
            "type": "BASE TABLE",
            "comment": "This table stores Publications in which Relative Ages are reported for CollectionUnits.",
            "columns": [
                {
                    "name": "relativeageid",
                    "type": "integer",
                    "nullable": false,
                    "comment": "Relative Ages identification number. Field links to the RelativeAges table."
                },
                {
                    "name": "publicationid",
                    "type": "integer",
                    "nullable": false,
                    "comment": "Publication identification number. Field links to Publications table."
                },
                {
                    "name": "recdatecreated",
                    "type": "timestamp(0) without time zone",
                    "nullable": false,
                    "default": "timezone('UTC'::text, now())"
                },
                {
                    "name": "recdatemodified",
                    "type": "timestamp(0) without time zone",
                    "nullable": false
                }
            ],
            "indexes": [
                {
                    "name": "relativeagepublications_pkey",
                    "def": "CREATE UNIQUE INDEX relativeagepublications_pkey ON ndb.relativeagepublications USING btree (relativeageid, publicationid)",
                    "table": "ndb.relativeagepublications",
                    "columns": [
                        "relativeageid",
                        "publicationid"
                    ]
                },
                {
                    "name": "ix_relativeageid_relativeagepublications",
                    "def": "CREATE INDEX ix_relativeageid_relativeagepublications ON ndb.relativeagepublications USING btree (relativeageid) WITH (fillfactor='10')",
                    "table": "ndb.relativeagepublications",
                    "columns": [
                        "relativeageid"
                    ]
                }
            ],
            "constraints": [
                {
                    "name": "fk_relativeagepublications_publications",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (publicationid) REFERENCES ndb.publications(publicationid) ON UPDATE CASCADE ON DELETE CASCADE",
                    "table": "ndb.relativeagepublications",
                    "referenced_table": "publications",
                    "columns": [
                        "publicationid"
                    ],
                    "referenced_columns": [
                        "publicationid"
                    ]
                },
                {
                    "name": "relativeagepublications_pkey",
                    "type": "PRIMARY KEY",
                    "def": "PRIMARY KEY (relativeageid, publicationid)",
                    "table": "ndb.relativeagepublications",
                    "referenced_table": "",
                    "columns": [
                        "relativeageid",
                        "publicationid"
                    ]
                },
                {
                    "name": "fk_relativeagepublications_relativeages",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (relativeageid) REFERENCES ndb.relativeages(relativeageid) ON UPDATE CASCADE ON DELETE CASCADE",
                    "table": "ndb.relativeagepublications",
                    "referenced_table": "relativeages",
                    "columns": [
                        "relativeageid"
                    ],
                    "referenced_columns": [
                        "relativeageid"
                    ]
                }
            ],
            "triggers": [
                {
                    "name": "tr_sites_modifydate",
                    "def": "CREATE TRIGGER tr_sites_modifydate BEFORE INSERT OR UPDATE ON ndb.relativeagepublications FOR EACH ROW EXECUTE FUNCTION ndb.update_recdatemodified()"
                }
            ]
        },
        {
            "name": "ndb.relativeages",
            "type": "BASE TABLE",
            "comment": "Lookup table of RelativeAges. Table is referenced by the RelativeChronology table.",
            "columns": [
                {
                    "name": "relativeageid",
                    "type": "integer",
                    "nullable": false,
                    "default": "nextval('ndb.seq_relativeages_relativeageid'::regclass)",
                    "comment": "An arbitrary Relative Age identification number."
                },
                {
                    "name": "relativeageunitid",
                    "type": "integer",
                    "nullable": false,
                    "comment": "Relative Age Unit (e.g. «Marine isotope stage», «Land mammal age»). Field links to the RelativeAgeUnits lookup table."
                },
                {
                    "name": "relativeagescaleid",
                    "type": "integer",
                    "nullable": false,
                    "comment": "Relative Age Scale (e.g. «Geologic time scale», «Marine isotope stages»). Field links to the RelativeAgeScales lookup table."
                },
                {
                    "name": "relativeage",
                    "type": "varchar(64)",
                    "nullable": false,
                    "comment": "Relative Age (e.g. «Rancholabrean», a land mammal age; «MIS 11», marine isotope stage 11)."
                },
                {
                    "name": "c14ageyounger",
                    "type": "double precision",
                    "nullable": true,
                    "comment": "Younger age of the Relative Age unit in 14C yr B.P. Applies only to Relative Age units within the radiocarbon time scale."
                },
                {
                    "name": "c14ageolder",
                    "type": "double precision",
                    "nullable": true,
                    "comment": "Older age of the Relative Age unit in 14C yr B.P. Applies only to Relative Age units within the radiocarbon time scale."
                },
                {
                    "name": "calageyounger",
                    "type": "double precision",
                    "nullable": true,
                    "comment": "Younger age of the Relative Age unit in calendar years."
                },
                {
                    "name": "calageolder",
                    "type": "double precision",
                    "nullable": true,
                    "comment": "Older age of the Relative age unit in calendar years."
                },
                {
                    "name": "notes",
                    "type": "text",
                    "nullable": true,
                    "comment": "Free form notes or comments about Relative Age unit."
                },
                {
                    "name": "recdatecreated",
                    "type": "timestamp(0) without time zone",
                    "nullable": false,
                    "default": "timezone('UTC'::text, now())"
                },
                {
                    "name": "recdatemodified",
                    "type": "timestamp(0) without time zone",
                    "nullable": false
                }
            ],
            "indexes": [
                {
                    "name": "relativeages_pkey",
                    "def": "CREATE UNIQUE INDEX relativeages_pkey ON ndb.relativeages USING btree (relativeageid)",
                    "table": "ndb.relativeages",
                    "columns": [
                        "relativeageid"
                    ]
                },
                {
                    "name": "ix_relativeagescaleid_relativeages",
                    "def": "CREATE INDEX ix_relativeagescaleid_relativeages ON ndb.relativeages USING btree (relativeagescaleid) WITH (fillfactor='10')",
                    "table": "ndb.relativeages",
                    "columns": [
                        "relativeagescaleid"
                    ]
                }
            ],
            "constraints": [
                {
                    "name": "relativeages_pkey",
                    "type": "PRIMARY KEY",
                    "def": "PRIMARY KEY (relativeageid)",
                    "table": "ndb.relativeages",
                    "referenced_table": "",
                    "columns": [
                        "relativeageid"
                    ]
                },
                {
                    "name": "fk_relativeages_relativeagescales",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (relativeagescaleid) REFERENCES ndb.relativeagescales(relativeagescaleid) ON UPDATE CASCADE ON DELETE CASCADE",
                    "table": "ndb.relativeages",
                    "referenced_table": "relativeagescales",
                    "columns": [
                        "relativeagescaleid"
                    ],
                    "referenced_columns": [
                        "relativeagescaleid"
                    ]
                },
                {
                    "name": "fk_relativeages_relativeageunits",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (relativeageunitid) REFERENCES ndb.relativeageunits(relativeageunitid) ON UPDATE CASCADE ON DELETE CASCADE",
                    "table": "ndb.relativeages",
                    "referenced_table": "relativeageunits",
                    "columns": [
                        "relativeageunitid"
                    ],
                    "referenced_columns": [
                        "relativeageunitid"
                    ]
                }
            ],
            "triggers": [
                {
                    "name": "tr_sites_modifydate",
                    "def": "CREATE TRIGGER tr_sites_modifydate BEFORE INSERT OR UPDATE ON ndb.relativeages FOR EACH ROW EXECUTE FUNCTION ndb.update_recdatemodified()"
                }
            ]
        },
        {
            "name": "ndb.relativeagescales",
            "type": "BASE TABLE",
            "comment": "Lookup table of Relative Age Scales. Table is referenced by the RelativeAges table.",
            "columns": [
                {
                    "name": "relativeagescaleid",
                    "type": "integer",
                    "nullable": false,
                    "default": "nextval('ndb.seq_relativeagescales_relativeagescaleid'::regclass)",
                    "comment": "An arbitrary Relative Age Scale identification number."
                },
                {
                    "name": "relativeagescale",
                    "type": "varchar(64)",
                    "nullable": false,
                    "comment": "Relative Age Scale. The table stores the following Relative Age Scales:\nArchaeological time scale\nGeologic time scale\nGeomagnetic polarity time scale\nMarine isotope stages\nNorth American land mammal ages\nQuaternary event classification\n"
                },
                {
                    "name": "recdatecreated",
                    "type": "timestamp(0) without time zone",
                    "nullable": false,
                    "default": "timezone('UTC'::text, now())"
                },
                {
                    "name": "recdatemodified",
                    "type": "timestamp(0) without time zone",
                    "nullable": false
                }
            ],
            "indexes": [
                {
                    "name": "relativeagescales_pkey",
                    "def": "CREATE UNIQUE INDEX relativeagescales_pkey ON ndb.relativeagescales USING btree (relativeagescaleid)",
                    "table": "ndb.relativeagescales",
                    "columns": [
                        "relativeagescaleid"
                    ]
                }
            ],
            "constraints": [
                {
                    "name": "relativeagescales_pkey",
                    "type": "PRIMARY KEY",
                    "def": "PRIMARY KEY (relativeagescaleid)",
                    "table": "ndb.relativeagescales",
                    "referenced_table": "",
                    "columns": [
                        "relativeagescaleid"
                    ]
                }
            ],
            "triggers": [
                {
                    "name": "tr_sites_modifydate",
                    "def": "CREATE TRIGGER tr_sites_modifydate BEFORE INSERT OR UPDATE ON ndb.relativeagescales FOR EACH ROW EXECUTE FUNCTION ndb.update_recdatemodified()"
                }
            ]
        },
        {
            "name": "ndb.relativeageunits",
            "type": "BASE TABLE",
            "comment": "Lookup table of RelativeAgeUnits. Table is referenced by the RelativeAges table.",
            "columns": [
                {
                    "name": "relativeageunitid",
                    "type": "integer",
                    "nullable": false,
                    "default": "nextval('ndb.seq_relativeageunits_relativeageunitid'::regclass)",
                    "comment": "An arbitrary Relative Age Unit identification number."
                },
                {
                    "name": "relativeageunit",
                    "type": "varchar(64)",
                    "nullable": false,
                    "comment": "Relative Age Unit. Below are the Relative Age Units for the «Geologic time scale» with an example Relative Age."
                },
                {
                    "name": "recdatecreated",
                    "type": "timestamp(0) without time zone",
                    "nullable": false,
                    "default": "timezone('UTC'::text, now())"
                },
                {
                    "name": "recdatemodified",
                    "type": "timestamp(0) without time zone",
                    "nullable": false
                }
            ],
            "indexes": [
                {
                    "name": "relativeageunits_pkey",
                    "def": "CREATE UNIQUE INDEX relativeageunits_pkey ON ndb.relativeageunits USING btree (relativeageunitid)",
                    "table": "ndb.relativeageunits",
                    "columns": [
                        "relativeageunitid"
                    ]
                }
            ],
            "constraints": [
                {
                    "name": "relativeageunits_pkey",
                    "type": "PRIMARY KEY",
                    "def": "PRIMARY KEY (relativeageunitid)",
                    "table": "ndb.relativeageunits",
                    "referenced_table": "",
                    "columns": [
                        "relativeageunitid"
                    ]
                }
            ],
            "triggers": [
                {
                    "name": "tr_sites_modifydate",
                    "def": "CREATE TRIGGER tr_sites_modifydate BEFORE INSERT OR UPDATE ON ndb.relativeageunits FOR EACH ROW EXECUTE FUNCTION ndb.update_recdatemodified()"
                }
            ]
        },
        {
            "name": "ndb.relativechronology",
            "type": "BASE TABLE",
            "comment": "This table stores relative chronologic data. Relative Ages are assigned to Analysis Units, The Relative Age data along with any possible Geochronology and Tephrachronology data are used to create a chronology.",
            "columns": [
                {
                    "name": "relativechronid",
                    "type": "integer",
                    "nullable": false,
                    "default": "nextval('ndb.seq_relativechronology_relativechronid'::regclass)",
                    "comment": "An arbitrary Relative Chronology identification number."
                },
                {
                    "name": "analysisunitid",
                    "type": "integer",
                    "nullable": false,
                    "comment": "Analysis Unit identification number. Field links to the AnalysisUnits table."
                },
                {
                    "name": "relativeageid",
                    "type": "integer",
                    "nullable": false,
                    "comment": "Relative Age identification number. Field links to the RelativeAges lookup table."
                },
                {
                    "name": "notes",
                    "type": "text",
                    "nullable": true,
                    "comment": "Free form notes or comments."
                },
                {
                    "name": "recdatecreated",
                    "type": "timestamp(0) without time zone",
                    "nullable": false,
                    "default": "timezone('UTC'::text, now())"
                },
                {
                    "name": "recdatemodified",
                    "type": "timestamp(0) without time zone",
                    "nullable": false
                },
                {
                    "name": "chroncontrolid",
                    "type": "integer",
                    "nullable": true
                }
            ],
            "indexes": [
                {
                    "name": "relativechronology_pkey",
                    "def": "CREATE UNIQUE INDEX relativechronology_pkey ON ndb.relativechronology USING btree (relativechronid)",
                    "table": "ndb.relativechronology",
                    "columns": [
                        "relativechronid"
                    ]
                },
                {
                    "name": "ix_analysisunitid_relativechronology",
                    "def": "CREATE INDEX ix_analysisunitid_relativechronology ON ndb.relativechronology USING btree (analysisunitid) WITH (fillfactor='10')",
                    "table": "ndb.relativechronology",
                    "columns": [
                        "analysisunitid"
                    ]
                },
                {
                    "name": "ix_relativeageid_relativechronology",
                    "def": "CREATE INDEX ix_relativeageid_relativechronology ON ndb.relativechronology USING btree (relativeageid) WITH (fillfactor='10')",
                    "table": "ndb.relativechronology",
                    "columns": [
                        "relativeageid"
                    ]
                }
            ],
            "constraints": [
                {
                    "name": "fk_relativechronology_analysisunits",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (analysisunitid) REFERENCES ndb.analysisunits(analysisunitid) ON UPDATE CASCADE ON DELETE CASCADE",
                    "table": "ndb.relativechronology",
                    "referenced_table": "analysisunits",
                    "columns": [
                        "analysisunitid"
                    ],
                    "referenced_columns": [
                        "analysisunitid"
                    ]
                },
                {
                    "name": "rc_ccid",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (chroncontrolid) REFERENCES ndb.chroncontrols(chroncontrolid) ON UPDATE CASCADE ON DELETE CASCADE",
                    "table": "ndb.relativechronology",
                    "referenced_table": "chroncontrols",
                    "columns": [
                        "chroncontrolid"
                    ],
                    "referenced_columns": [
                        "chroncontrolid"
                    ]
                },
                {
                    "name": "fk_relativechronology_relativeages",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (relativeageid) REFERENCES ndb.relativeages(relativeageid) ON UPDATE CASCADE ON DELETE CASCADE",
                    "table": "ndb.relativechronology",
                    "referenced_table": "relativeages",
                    "columns": [
                        "relativeageid"
                    ],
                    "referenced_columns": [
                        "relativeageid"
                    ]
                },
                {
                    "name": "relativechronology_pkey",
                    "type": "PRIMARY KEY",
                    "def": "PRIMARY KEY (relativechronid)",
                    "table": "ndb.relativechronology",
                    "referenced_table": "",
                    "columns": [
                        "relativechronid"
                    ]
                }
            ],
            "triggers": [
                {
                    "name": "tr_sites_modifydate",
                    "def": "CREATE TRIGGER tr_sites_modifydate BEFORE INSERT OR UPDATE ON ndb.relativechronology FOR EACH ROW EXECUTE FUNCTION ndb.update_recdatemodified()"
                }
            ]
        },
        {
            "name": "ndb.repositoryinstitutions",
            "type": "BASE TABLE",
            "comment": "A lookup table of institutions that are repositories for fossil specimens. Table is referenced by the RepositorySpecimens table.",
            "columns": [
                {
                    "name": "repositoryid",
                    "type": "integer",
                    "nullable": false,
                    "default": "nextval('ndb.seq_repositoryinstitutions_repositoryid'::regclass)",
                    "comment": "An arbitrary Repository identification number. Repositories include museums, university departments, and various governmental agencies."
                },
                {
                    "name": "acronym",
                    "type": "varchar(64)",
                    "nullable": false,
                    "comment": "A unique acronym for the repository. Many repositories have well-established acronyms (e.g. AMNH = American Museum of Natural History); however, there is no official list. Various acronyms have been used for some institutions, and in some cases the same acronym has been used for different institutions. Consequently, the database acronym may differ from the acronym used in some publications. For example, «CMNH» has been used for the Carnegie Museum of Natural History, the Cleveland Museum of Natural History, and the Cincinnati Museum of Natural History. In Neotoma, two of these institutions were assigned different acronyms, ones that have been used for them in other publications: CM – Carnegie Museum of Natural History, CLM – Cleveland Museum of Natural History."
                },
                {
                    "name": "repository",
                    "type": "varchar(128)",
                    "nullable": false,
                    "comment": "The full name of the repository."
                },
                {
                    "name": "notes",
                    "type": "text",
                    "nullable": true,
                    "comment": "Free form notes or comments about the repository, especially notes about name changes, closures, and specimen transfers. In some cases, it is known that the specimens were transferred, but their current disposition may be uncertain."
                },
                {
                    "name": "recdatecreated",
                    "type": "timestamp(0) without time zone",
                    "nullable": false,
                    "default": "timezone('UTC'::text, now())"
                },
                {
                    "name": "recdatemodified",
                    "type": "timestamp(0) without time zone",
                    "nullable": false
                }
            ],
            "indexes": [
                {
                    "name": "repositoryinstitutions_pkey",
                    "def": "CREATE UNIQUE INDEX repositoryinstitutions_pkey ON ndb.repositoryinstitutions USING btree (repositoryid)",
                    "table": "ndb.repositoryinstitutions",
                    "columns": [
                        "repositoryid"
                    ]
                }
            ],
            "constraints": [
                {
                    "name": "repositoryinstitutions_pkey",
                    "type": "PRIMARY KEY",
                    "def": "PRIMARY KEY (repositoryid)",
                    "table": "ndb.repositoryinstitutions",
                    "referenced_table": "",
                    "columns": [
                        "repositoryid"
                    ]
                }
            ],
            "triggers": [
                {
                    "name": "tr_sites_modifydate",
                    "def": "CREATE TRIGGER tr_sites_modifydate BEFORE INSERT OR UPDATE ON ndb.repositoryinstitutions FOR EACH ROW EXECUTE FUNCTION ndb.update_recdatemodified()"
                }
            ]
        },
        {
            "name": "ndb.repositoryspecimens",
            "type": "BASE TABLE",
            "comment": "This table lists the repositories in which fossil specimens have been accessioned or reposited. The inventory in Neotoma is by Dataset, which is the collection of specimens from a Collection Unit. Occasionally, specimens from a single Collection Unit have been reposited at different institutions, in which case multiple records for that Dataset occur in the table.",
            "columns": [
                {
                    "name": "datasetid",
                    "type": "integer",
                    "nullable": false,
                    "comment": "Dataset identification number. Field links to the Datasets table."
                },
                {
                    "name": "repositoryid",
                    "type": "integer",
                    "nullable": false,
                    "comment": "Repository identification number. Field links to the RepositoryInstitutions lookup table."
                },
                {
                    "name": "notes",
                    "type": "text",
                    "nullable": true,
                    "comment": "Free form notes or comments about the disposition of the specimens."
                },
                {
                    "name": "recdatecreated",
                    "type": "timestamp(0) without time zone",
                    "nullable": false,
                    "default": "timezone('UTC'::text, now())"
                },
                {
                    "name": "recdatemodified",
                    "type": "timestamp(0) without time zone",
                    "nullable": false
                }
            ],
            "indexes": [
                {
                    "name": "repositoryspecimens_pkey",
                    "def": "CREATE UNIQUE INDEX repositoryspecimens_pkey ON ndb.repositoryspecimens USING btree (datasetid, repositoryid)",
                    "table": "ndb.repositoryspecimens",
                    "columns": [
                        "datasetid",
                        "repositoryid"
                    ]
                },
                {
                    "name": "ix_datasetid_repositoryspecimens",
                    "def": "CREATE INDEX ix_datasetid_repositoryspecimens ON ndb.repositoryspecimens USING btree (datasetid) WITH (fillfactor='10')",
                    "table": "ndb.repositoryspecimens",
                    "columns": [
                        "datasetid"
                    ]
                }
            ],
            "constraints": [
                {
                    "name": "fk_repositoryspecimens_datasets",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (datasetid) REFERENCES ndb.datasets(datasetid) ON UPDATE CASCADE ON DELETE CASCADE",
                    "table": "ndb.repositoryspecimens",
                    "referenced_table": "datasets",
                    "columns": [
                        "datasetid"
                    ],
                    "referenced_columns": [
                        "datasetid"
                    ]
                },
                {
                    "name": "fk_repositoryspecimens_repositoryinstitutions",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (repositoryid) REFERENCES ndb.repositoryinstitutions(repositoryid)",
                    "table": "ndb.repositoryspecimens",
                    "referenced_table": "repositoryinstitutions",
                    "columns": [
                        "repositoryid"
                    ],
                    "referenced_columns": [
                        "repositoryid"
                    ]
                },
                {
                    "name": "repositoryspecimens_pkey",
                    "type": "PRIMARY KEY",
                    "def": "PRIMARY KEY (datasetid, repositoryid)",
                    "table": "ndb.repositoryspecimens",
                    "referenced_table": "",
                    "columns": [
                        "datasetid",
                        "repositoryid"
                    ]
                }
            ],
            "triggers": [
                {
                    "name": "tr_sites_modifydate",
                    "def": "CREATE TRIGGER tr_sites_modifydate BEFORE INSERT OR UPDATE ON ndb.repositoryspecimens FOR EACH ROW EXECUTE FUNCTION ndb.update_recdatemodified()"
                }
            ]
        },
        {
            "name": "ndb.rocktypes",
            "type": "BASE TABLE",
            "columns": [
                {
                    "name": "rocktypeid",
                    "type": "integer",
                    "nullable": false,
                    "default": "nextval('ndb.seq_rocktypes_rocktypeid'::regclass)"
                },
                {
                    "name": "rocktype",
                    "type": "varchar(64)",
                    "nullable": false
                },
                {
                    "name": "higherrocktypeid",
                    "type": "integer",
                    "nullable": false
                },
                {
                    "name": "description",
                    "type": "text",
                    "nullable": false
                },
                {
                    "name": "recdatecreated",
                    "type": "timestamp(0) without time zone",
                    "nullable": false,
                    "default": "timezone('UTC'::text, now())"
                },
                {
                    "name": "recdatemodified",
                    "type": "timestamp(0) without time zone",
                    "nullable": false
                }
            ],
            "indexes": [
                {
                    "name": "rocktypes_pkey",
                    "def": "CREATE UNIQUE INDEX rocktypes_pkey ON ndb.rocktypes USING btree (rocktypeid)",
                    "table": "ndb.rocktypes",
                    "columns": [
                        "rocktypeid"
                    ]
                }
            ],
            "constraints": [
                {
                    "name": "fk_higherrocktypeid",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (higherrocktypeid) REFERENCES ndb.rocktypes(rocktypeid)",
                    "table": "ndb.rocktypes",
                    "referenced_table": "rocktypes",
                    "columns": [
                        "higherrocktypeid"
                    ],
                    "referenced_columns": [
                        "rocktypeid"
                    ]
                },
                {
                    "name": "rocktypes_pkey",
                    "type": "PRIMARY KEY",
                    "def": "PRIMARY KEY (rocktypeid)",
                    "table": "ndb.rocktypes",
                    "referenced_table": "",
                    "columns": [
                        "rocktypeid"
                    ]
                }
            ],
            "triggers": [
                {
                    "name": "tr_sites_modifydate",
                    "def": "CREATE TRIGGER tr_sites_modifydate BEFORE INSERT OR UPDATE ON ndb.rocktypes FOR EACH ROW EXECUTE FUNCTION ndb.update_recdatemodified()"
                }
            ]
        },
        {
            "name": "ndb.sampleanalysts",
            "type": "BASE TABLE",
            "comment": "This table lists the Sample Analysts.",
            "columns": [
                {
                    "name": "analystid",
                    "type": "integer",
                    "nullable": false,
                    "default": "nextval('ndb.seq_sampleanalysts_analystid'::regclass)",
                    "comment": "An arbitrary Sample Analyst identification number."
                },
                {
                    "name": "sampleid",
                    "type": "integer",
                    "nullable": false,
                    "comment": "Sample identification number. Field links to the Samples table."
                },
                {
                    "name": "contactid",
                    "type": "integer",
                    "nullable": false,
                    "comment": "Contact identification number. Field links to the Contacts table."
                },
                {
                    "name": "analystorder",
                    "type": "integer",
                    "nullable": false,
                    "comment": "Order in which Sample Analysts are listed if more than one (rare)."
                },
                {
                    "name": "recdatecreated",
                    "type": "timestamp(0) without time zone",
                    "nullable": false,
                    "default": "timezone('UTC'::text, now())"
                },
                {
                    "name": "recdatemodified",
                    "type": "timestamp(0) without time zone",
                    "nullable": false
                }
            ],
            "indexes": [
                {
                    "name": "sampleanalysts_pkey",
                    "def": "CREATE UNIQUE INDEX sampleanalysts_pkey ON ndb.sampleanalysts USING btree (analystid)",
                    "table": "ndb.sampleanalysts",
                    "columns": [
                        "analystid"
                    ]
                },
                {
                    "name": "ix_contactid_sampleanalysts",
                    "def": "CREATE INDEX ix_contactid_sampleanalysts ON ndb.sampleanalysts USING btree (contactid) WITH (fillfactor='10')",
                    "table": "ndb.sampleanalysts",
                    "columns": [
                        "contactid"
                    ]
                },
                {
                    "name": "ix_sampleid_sampleanalysts",
                    "def": "CREATE INDEX ix_sampleid_sampleanalysts ON ndb.sampleanalysts USING btree (sampleid) WITH (fillfactor='10')",
                    "table": "ndb.sampleanalysts",
                    "columns": [
                        "sampleid"
                    ]
                }
            ],
            "constraints": [
                {
                    "name": "fk_sampleanalysts_contacts",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (contactid) REFERENCES ndb.contacts(contactid) ON UPDATE CASCADE",
                    "table": "ndb.sampleanalysts",
                    "referenced_table": "contacts",
                    "columns": [
                        "contactid"
                    ],
                    "referenced_columns": [
                        "contactid"
                    ]
                },
                {
                    "name": "sampleanalysts_pkey",
                    "type": "PRIMARY KEY",
                    "def": "PRIMARY KEY (analystid)",
                    "table": "ndb.sampleanalysts",
                    "referenced_table": "",
                    "columns": [
                        "analystid"
                    ]
                },
                {
                    "name": "fk_sampleanalysts_samples",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (sampleid) REFERENCES ndb.samples(sampleid) ON UPDATE CASCADE ON DELETE CASCADE",
                    "table": "ndb.sampleanalysts",
                    "referenced_table": "samples",
                    "columns": [
                        "sampleid"
                    ],
                    "referenced_columns": [
                        "sampleid"
                    ]
                }
            ],
            "triggers": [
                {
                    "name": "tr_sites_modifydate",
                    "def": "CREATE TRIGGER tr_sites_modifydate BEFORE INSERT OR UPDATE ON ndb.sampleanalysts FOR EACH ROW EXECUTE FUNCTION ndb.update_recdatemodified()"
                }
            ]
        },
        {
            "name": "ndb.siteimages",
            "type": "BASE TABLE",
            "comment": "This table stores hyperlinks to jpeg images of sites.",
            "columns": [
                {
                    "name": "siteimageid",
                    "type": "integer",
                    "nullable": false,
                    "default": "nextval('ndb.seq_siteimages_siteimageid'::regclass)",
                    "comment": "An arbitrary Site Image identification number."
                },
                {
                    "name": "siteid",
                    "type": "integer",
                    "nullable": true,
                    "comment": "Site identification number. Field links to the Sites table."
                },
                {
                    "name": "contactid",
                    "type": "integer",
                    "nullable": true,
                    "comment": "Contact identification number for image attribution."
                },
                {
                    "name": "caption",
                    "type": "text",
                    "nullable": true,
                    "comment": "Caption for the image."
                },
                {
                    "name": "credit",
                    "type": "varchar(255)",
                    "nullable": true,
                    "comment": "Credit for the image. If null, the credit is formed from the ContactID."
                },
                {
                    "name": "date",
                    "type": "date",
                    "nullable": true,
                    "comment": "Date of photograph or image."
                },
                {
                    "name": "siteimage",
                    "type": "text",
                    "nullable": true,
                    "comment": "Hyperlink to a URL for the image."
                },
                {
                    "name": "recdatecreated",
                    "type": "timestamp(0) without time zone",
                    "nullable": false,
                    "default": "timezone('UTC'::text, now())"
                },
                {
                    "name": "recdatemodified",
                    "type": "timestamp(0) without time zone",
                    "nullable": false
                }
            ],
            "indexes": [
                {
                    "name": "siteimages_pkey",
                    "def": "CREATE UNIQUE INDEX siteimages_pkey ON ndb.siteimages USING btree (siteimageid)",
                    "table": "ndb.siteimages",
                    "columns": [
                        "siteimageid"
                    ]
                },
                {
                    "name": "ix_siteid_siteimages",
                    "def": "CREATE INDEX ix_siteid_siteimages ON ndb.siteimages USING btree (siteid) WITH (fillfactor='10')",
                    "table": "ndb.siteimages",
                    "columns": [
                        "siteid"
                    ]
                }
            ],
            "constraints": [
                {
                    "name": "fk_siteimages_contacts",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (contactid) REFERENCES ndb.contacts(contactid) ON UPDATE CASCADE",
                    "table": "ndb.siteimages",
                    "referenced_table": "contacts",
                    "columns": [
                        "contactid"
                    ],
                    "referenced_columns": [
                        "contactid"
                    ]
                },
                {
                    "name": "siteimages_pkey",
                    "type": "PRIMARY KEY",
                    "def": "PRIMARY KEY (siteimageid)",
                    "table": "ndb.siteimages",
                    "referenced_table": "",
                    "columns": [
                        "siteimageid"
                    ]
                },
                {
                    "name": "fk_siteimages_sites",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (siteid) REFERENCES ndb.sites(siteid) ON UPDATE CASCADE ON DELETE CASCADE",
                    "table": "ndb.siteimages",
                    "referenced_table": "sites",
                    "columns": [
                        "siteid"
                    ],
                    "referenced_columns": [
                        "siteid"
                    ]
                }
            ],
            "triggers": [
                {
                    "name": "tr_sites_modifydate",
                    "def": "CREATE TRIGGER tr_sites_modifydate BEFORE INSERT OR UPDATE ON ndb.siteimages FOR EACH ROW EXECUTE FUNCTION ndb.update_recdatemodified()"
                }
            ]
        },
        {
            "name": "ndb.sitestemp",
            "type": "BASE TABLE",
            "columns": [
                {
                    "name": "siteid",
                    "type": "integer",
                    "nullable": false
                },
                {
                    "name": "sitename",
                    "type": "varchar(128)",
                    "nullable": true
                },
                {
                    "name": "longitudeeast",
                    "type": "double precision",
                    "nullable": true
                },
                {
                    "name": "latitudenorth",
                    "type": "double precision",
                    "nullable": true
                },
                {
                    "name": "longitudewest",
                    "type": "double precision",
                    "nullable": true
                },
                {
                    "name": "latitudesouth",
                    "type": "double precision",
                    "nullable": true
                },
                {
                    "name": "altitude",
                    "type": "double precision",
                    "nullable": true
                },
                {
                    "name": "area",
                    "type": "double precision",
                    "nullable": true
                },
                {
                    "name": "sitedescription",
                    "type": "text",
                    "nullable": true
                },
                {
                    "name": "notes",
                    "type": "text",
                    "nullable": true
                },
                {
                    "name": "recdatecreated",
                    "type": "timestamp(0) without time zone",
                    "nullable": false,
                    "default": "timezone('UTC'::text, now())"
                },
                {
                    "name": "recdatemodified",
                    "type": "timestamp(0) without time zone",
                    "nullable": false
                },
                {
                    "name": "geog",
                    "type": "text",
                    "nullable": true
                }
            ],
            "indexes": [
                {
                    "name": "sitestemp_pkey",
                    "def": "CREATE UNIQUE INDEX sitestemp_pkey ON ndb.sitestemp USING btree (siteid)",
                    "table": "ndb.sitestemp",
                    "columns": [
                        "siteid"
                    ]
                }
            ],
            "constraints": [
                {
                    "name": "sitestemp_pkey",
                    "type": "PRIMARY KEY",
                    "def": "PRIMARY KEY (siteid)",
                    "table": "ndb.sitestemp",
                    "referenced_table": "",
                    "columns": [
                        "siteid"
                    ]
                }
            ],
            "triggers": [
                {
                    "name": "tr_sites_modifydate",
                    "def": "CREATE TRIGGER tr_sites_modifydate BEFORE INSERT OR UPDATE ON ndb.sitestemp FOR EACH ROW EXECUTE FUNCTION ndb.update_recdatemodified()"
                }
            ]
        },
        {
            "name": "ndb.specimendates",
            "type": "BASE TABLE",
            "comment": "This table enables queries for dated specimens of individual taxa. Although the MaterialDated field in the Geochronology table may list the taxa dated, this protocol is not enforced, and the field is not linked to the taxa table.",
            "columns": [
                {
                    "name": "specimendateid",
                    "type": "integer",
                    "nullable": false,
                    "default": "nextval('ndb.seq_specimendates_specimendateid'::regclass)",
                    "comment": "An arbitrary specimen date ID"
                },
                {
                    "name": "geochronid",
                    "type": "integer",
                    "nullable": false,
                    "comment": "Geochronologic identification number. Field links to the Geochronology table."
                },
                {
                    "name": "taxonid",
                    "type": "integer",
                    "nullable": false,
                    "comment": "Accepted name in Neotoma. Field links to Taxa table."
                },
                {
                    "name": "fractionid",
                    "type": "integer",
                    "nullable": true
                },
                {
                    "name": "sampleid",
                    "type": "integer",
                    "nullable": false,
                    "comment": "Sample ID number. Field links to the Samples table."
                },
                {
                    "name": "notes",
                    "type": "text",
                    "nullable": true,
                    "comment": "Free form notes or comments about dated specimens."
                },
                {
                    "name": "elementtypeid",
                    "type": "integer",
                    "nullable": true
                },
                {
                    "name": "recdatecreated",
                    "type": "timestamp(0) without time zone",
                    "nullable": false,
                    "default": "timezone('UTC'::text, now())"
                },
                {
                    "name": "recdatemodified",
                    "type": "timestamp(0) without time zone",
                    "nullable": false
                },
                {
                    "name": "specimenid",
                    "type": "integer",
                    "nullable": true
                }
            ],
            "indexes": [
                {
                    "name": "specimendates_pkey",
                    "def": "CREATE UNIQUE INDEX specimendates_pkey ON ndb.specimendates USING btree (specimendateid)",
                    "table": "ndb.specimendates",
                    "columns": [
                        "specimendateid"
                    ]
                },
                {
                    "name": "ix_sampleid_specimendates",
                    "def": "CREATE INDEX ix_sampleid_specimendates ON ndb.specimendates USING btree (sampleid) WITH (fillfactor='10')",
                    "table": "ndb.specimendates",
                    "columns": [
                        "sampleid"
                    ]
                },
                {
                    "name": "ix_taxonid_specimendates",
                    "def": "CREATE INDEX ix_taxonid_specimendates ON ndb.specimendates USING btree (taxonid) WITH (fillfactor='10')",
                    "table": "ndb.specimendates",
                    "columns": [
                        "taxonid"
                    ]
                }
            ],
            "constraints": [
                {
                    "name": "sd_etyid",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (elementtypeid) REFERENCES ndb.elementtypes(elementtypeid)",
                    "table": "ndb.specimendates",
                    "referenced_table": "elementtypes",
                    "columns": [
                        "elementtypeid"
                    ],
                    "referenced_columns": [
                        "elementtypeid"
                    ]
                },
                {
                    "name": "sd_fcid",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (fractionid) REFERENCES ndb.fractiondated(fractionid)",
                    "table": "ndb.specimendates",
                    "referenced_table": "fractiondated",
                    "columns": [
                        "fractionid"
                    ],
                    "referenced_columns": [
                        "fractionid"
                    ]
                },
                {
                    "name": "sd_gcid",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (geochronid) REFERENCES ndb.geochronology(geochronid) ON UPDATE CASCADE ON DELETE CASCADE",
                    "table": "ndb.specimendates",
                    "referenced_table": "geochronology",
                    "columns": [
                        "geochronid"
                    ],
                    "referenced_columns": [
                        "geochronid"
                    ]
                },
                {
                    "name": "sd_smpid",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (sampleid) REFERENCES ndb.samples(sampleid) ON UPDATE CASCADE ON DELETE CASCADE",
                    "table": "ndb.specimendates",
                    "referenced_table": "samples",
                    "columns": [
                        "sampleid"
                    ],
                    "referenced_columns": [
                        "sampleid"
                    ]
                },
                {
                    "name": "specimendates_pkey",
                    "type": "PRIMARY KEY",
                    "def": "PRIMARY KEY (specimendateid)",
                    "table": "ndb.specimendates",
                    "referenced_table": "",
                    "columns": [
                        "specimendateid"
                    ]
                },
                {
                    "name": "fk_specimendates_specimens",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (specimenid) REFERENCES ndb.specimens(specimenid) ON UPDATE CASCADE ON DELETE CASCADE",
                    "table": "ndb.specimendates",
                    "referenced_table": "specimens",
                    "columns": [
                        "specimenid"
                    ],
                    "referenced_columns": [
                        "specimenid"
                    ]
                },
                {
                    "name": "sd_txid",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (taxonid) REFERENCES ndb.taxa(taxonid)",
                    "table": "ndb.specimendates",
                    "referenced_table": "taxa",
                    "columns": [
                        "taxonid"
                    ],
                    "referenced_columns": [
                        "taxonid"
                    ]
                }
            ],
            "triggers": [
                {
                    "name": "tr_sites_modifydate",
                    "def": "CREATE TRIGGER tr_sites_modifydate BEFORE INSERT OR UPDATE ON ndb.specimendates FOR EACH ROW EXECUTE FUNCTION ndb.update_recdatemodified()"
                }
            ]
        },
        {
            "name": "ndb.specimendatescal",
            "type": "BASE TABLE",
            "columns": [
                {
                    "name": "specimendatecalid",
                    "type": "integer",
                    "nullable": false,
                    "default": "nextval('ndb.seq_specimendatescal_specimendatecalid'::regclass)"
                },
                {
                    "name": "specimendateid",
                    "type": "integer",
                    "nullable": false
                },
                {
                    "name": "calage",
                    "type": "double precision",
                    "nullable": true
                },
                {
                    "name": "calageolder",
                    "type": "double precision",
                    "nullable": true
                },
                {
                    "name": "calageyounger",
                    "type": "double precision",
                    "nullable": true
                },
                {
                    "name": "calibrationcurveid",
                    "type": "integer",
                    "nullable": true
                },
                {
                    "name": "calibrationprogramid",
                    "type": "integer",
                    "nullable": true
                },
                {
                    "name": "datecalibrated",
                    "type": "date",
                    "nullable": true
                },
                {
                    "name": "recdatecreated",
                    "type": "timestamp(0) without time zone",
                    "nullable": false,
                    "default": "timezone('UTC'::text, now())"
                },
                {
                    "name": "recdatemodified",
                    "type": "timestamp(0) without time zone",
                    "nullable": false
                }
            ],
            "indexes": [
                {
                    "name": "specimendatescal_pkey",
                    "def": "CREATE UNIQUE INDEX specimendatescal_pkey ON ndb.specimendatescal USING btree (specimendatecalid)",
                    "table": "ndb.specimendatescal",
                    "columns": [
                        "specimendatecalid"
                    ]
                }
            ],
            "constraints": [
                {
                    "name": "fk_specimendatescal_calibrationcurves",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (calibrationcurveid) REFERENCES ndb.calibrationcurves(calibrationcurveid) ON UPDATE CASCADE ON DELETE CASCADE",
                    "table": "ndb.specimendatescal",
                    "referenced_table": "calibrationcurves",
                    "columns": [
                        "calibrationcurveid"
                    ],
                    "referenced_columns": [
                        "calibrationcurveid"
                    ]
                },
                {
                    "name": "fk_specimendatescal_calibrationprograms",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (calibrationprogramid) REFERENCES ndb.calibrationprograms(calibrationprogramid) ON UPDATE CASCADE ON DELETE CASCADE",
                    "table": "ndb.specimendatescal",
                    "referenced_table": "calibrationprograms",
                    "columns": [
                        "calibrationprogramid"
                    ],
                    "referenced_columns": [
                        "calibrationprogramid"
                    ]
                },
                {
                    "name": "fk_specimendatescal_specimendates",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (specimendateid) REFERENCES ndb.specimendates(specimendateid) ON UPDATE CASCADE ON DELETE CASCADE",
                    "table": "ndb.specimendatescal",
                    "referenced_table": "specimendates",
                    "columns": [
                        "specimendateid"
                    ],
                    "referenced_columns": [
                        "specimendateid"
                    ]
                },
                {
                    "name": "specimendatescal_pkey",
                    "type": "PRIMARY KEY",
                    "def": "PRIMARY KEY (specimendatecalid)",
                    "table": "ndb.specimendatescal",
                    "referenced_table": "",
                    "columns": [
                        "specimendatecalid"
                    ]
                }
            ],
            "triggers": [
                {
                    "name": "tr_sites_modifydate",
                    "def": "CREATE TRIGGER tr_sites_modifydate BEFORE INSERT OR UPDATE ON ndb.specimendatescal FOR EACH ROW EXECUTE FUNCTION ndb.update_recdatemodified()"
                }
            ]
        },
        {
            "name": "ndb.specimendomesticstatustypes",
            "type": "BASE TABLE",
            "columns": [
                {
                    "name": "domesticstatusid",
                    "type": "integer",
                    "nullable": false,
                    "default": "nextval('ndb.seq_specimendomesticstatustypes_domesticstatusid'::regclass)"
                },
                {
                    "name": "domesticstatus",
                    "type": "varchar(24)",
                    "nullable": false
                },
                {
                    "name": "recdatecreated",
                    "type": "timestamp(0) without time zone",
                    "nullable": false,
                    "default": "timezone('UTC'::text, now())"
                },
                {
                    "name": "recdatemodified",
                    "type": "timestamp(0) without time zone",
                    "nullable": false
                }
            ],
            "indexes": [
                {
                    "name": "specimendomesticstatustypes_pkey",
                    "def": "CREATE UNIQUE INDEX specimendomesticstatustypes_pkey ON ndb.specimendomesticstatustypes USING btree (domesticstatusid)",
                    "table": "ndb.specimendomesticstatustypes",
                    "columns": [
                        "domesticstatusid"
                    ]
                }
            ],
            "constraints": [
                {
                    "name": "specimendomesticstatustypes_pkey",
                    "type": "PRIMARY KEY",
                    "def": "PRIMARY KEY (domesticstatusid)",
                    "table": "ndb.specimendomesticstatustypes",
                    "referenced_table": "",
                    "columns": [
                        "domesticstatusid"
                    ]
                }
            ],
            "triggers": [
                {
                    "name": "tr_sites_modifydate",
                    "def": "CREATE TRIGGER tr_sites_modifydate BEFORE INSERT OR UPDATE ON ndb.specimendomesticstatustypes FOR EACH ROW EXECUTE FUNCTION ndb.update_recdatemodified()"
                }
            ]
        },
        {
            "name": "ndb.specimengenbank",
            "type": "BASE TABLE",
            "columns": [
                {
                    "name": "specimenid",
                    "type": "integer",
                    "nullable": false
                },
                {
                    "name": "genbanknr",
                    "type": "varchar(50)",
                    "nullable": false
                }
            ],
            "indexes": [
                {
                    "name": "specimengenbank_pkey",
                    "def": "CREATE UNIQUE INDEX specimengenbank_pkey ON ndb.specimengenbank USING btree (specimenid, genbanknr)",
                    "table": "ndb.specimengenbank",
                    "columns": [
                        "specimenid",
                        "genbanknr"
                    ]
                }
            ],
            "constraints": [
                {
                    "name": "specimengenbank_pkey",
                    "type": "PRIMARY KEY",
                    "def": "PRIMARY KEY (specimenid, genbanknr)",
                    "table": "ndb.specimengenbank",
                    "referenced_table": "",
                    "columns": [
                        "specimenid",
                        "genbanknr"
                    ]
                },
                {
                    "name": "fk_specimengenbank_specimens",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (specimenid) REFERENCES ndb.specimens(specimenid) ON UPDATE CASCADE ON DELETE CASCADE",
                    "table": "ndb.specimengenbank",
                    "referenced_table": "specimens",
                    "columns": [
                        "specimenid"
                    ],
                    "referenced_columns": [
                        "specimenid"
                    ]
                }
            ]
        },
        {
            "name": "ndb.specimens",
            "type": "BASE TABLE",
            "columns": [
                {
                    "name": "specimenid",
                    "type": "integer",
                    "nullable": false,
                    "default": "nextval('ndb.seq_specimens_specimenid'::regclass)"
                },
                {
                    "name": "dataid",
                    "type": "integer",
                    "nullable": false
                },
                {
                    "name": "elementtypeid",
                    "type": "integer",
                    "nullable": true
                },
                {
                    "name": "symmetryid",
                    "type": "integer",
                    "nullable": true
                },
                {
                    "name": "portionid",
                    "type": "integer",
                    "nullable": true
                },
                {
                    "name": "maturityid",
                    "type": "integer",
                    "nullable": true
                },
                {
                    "name": "sexid",
                    "type": "integer",
                    "nullable": true
                },
                {
                    "name": "domesticstatusid",
                    "type": "integer",
                    "nullable": true
                },
                {
                    "name": "preservative",
                    "type": "varchar(256)",
                    "nullable": true
                },
                {
                    "name": "nisp",
                    "type": "double precision",
                    "nullable": true
                },
                {
                    "name": "repositoryid",
                    "type": "integer",
                    "nullable": true
                },
                {
                    "name": "specimennr",
                    "type": "varchar(50)",
                    "nullable": true
                },
                {
                    "name": "fieldnr",
                    "type": "varchar(50)",
                    "nullable": true
                },
                {
                    "name": "arctosnr",
                    "type": "varchar(50)",
                    "nullable": true
                },
                {
                    "name": "notes",
                    "type": "text",
                    "nullable": true
                },
                {
                    "name": "recdatecreated",
                    "type": "timestamp(0) without time zone",
                    "nullable": false,
                    "default": "timezone('UTC'::text, now())"
                },
                {
                    "name": "recdatemodified",
                    "type": "timestamp(0) without time zone",
                    "nullable": false
                }
            ],
            "indexes": [
                {
                    "name": "specimens_pkey",
                    "def": "CREATE UNIQUE INDEX specimens_pkey ON ndb.specimens USING btree (specimenid)",
                    "table": "ndb.specimens",
                    "columns": [
                        "specimenid"
                    ]
                }
            ],
            "constraints": [
                {
                    "name": "fk_specimens_data",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (dataid) REFERENCES ndb.data(dataid) ON UPDATE CASCADE ON DELETE CASCADE",
                    "table": "ndb.specimens",
                    "referenced_table": "data",
                    "columns": [
                        "dataid"
                    ],
                    "referenced_columns": [
                        "dataid"
                    ]
                },
                {
                    "name": "fk_specimens_elementmaturities",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (maturityid) REFERENCES ndb.elementmaturities(maturityid)",
                    "table": "ndb.specimens",
                    "referenced_table": "elementmaturities",
                    "columns": [
                        "maturityid"
                    ],
                    "referenced_columns": [
                        "maturityid"
                    ]
                },
                {
                    "name": "fk_specimens_elementportions",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (portionid) REFERENCES ndb.elementportions(portionid)",
                    "table": "ndb.specimens",
                    "referenced_table": "elementportions",
                    "columns": [
                        "portionid"
                    ],
                    "referenced_columns": [
                        "portionid"
                    ]
                },
                {
                    "name": "fk_specimens_elementsymmetries",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (symmetryid) REFERENCES ndb.elementsymmetries(symmetryid)",
                    "table": "ndb.specimens",
                    "referenced_table": "elementsymmetries",
                    "columns": [
                        "symmetryid"
                    ],
                    "referenced_columns": [
                        "symmetryid"
                    ]
                },
                {
                    "name": "fk_specimens_elementtypes",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (elementtypeid) REFERENCES ndb.elementtypes(elementtypeid) ON UPDATE CASCADE ON DELETE CASCADE",
                    "table": "ndb.specimens",
                    "referenced_table": "elementtypes",
                    "columns": [
                        "elementtypeid"
                    ],
                    "referenced_columns": [
                        "elementtypeid"
                    ]
                },
                {
                    "name": "fk_specimens_repositoryinstitutions",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (repositoryid) REFERENCES ndb.repositoryinstitutions(repositoryid) ON UPDATE CASCADE ON DELETE CASCADE",
                    "table": "ndb.specimens",
                    "referenced_table": "repositoryinstitutions",
                    "columns": [
                        "repositoryid"
                    ],
                    "referenced_columns": [
                        "repositoryid"
                    ]
                },
                {
                    "name": "fk_specimens_specimendomesticstatus",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (domesticstatusid) REFERENCES ndb.specimendomesticstatustypes(domesticstatusid) ON UPDATE CASCADE ON DELETE CASCADE",
                    "table": "ndb.specimens",
                    "referenced_table": "specimendomesticstatustypes",
                    "columns": [
                        "domesticstatusid"
                    ],
                    "referenced_columns": [
                        "domesticstatusid"
                    ]
                },
                {
                    "name": "specimens_pkey",
                    "type": "PRIMARY KEY",
                    "def": "PRIMARY KEY (specimenid)",
                    "table": "ndb.specimens",
                    "referenced_table": "",
                    "columns": [
                        "specimenid"
                    ]
                },
                {
                    "name": "fk_specimens_specimensex",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (sexid) REFERENCES ndb.specimensextypes(sexid) ON UPDATE CASCADE ON DELETE CASCADE",
                    "table": "ndb.specimens",
                    "referenced_table": "specimensextypes",
                    "columns": [
                        "sexid"
                    ],
                    "referenced_columns": [
                        "sexid"
                    ]
                }
            ],
            "triggers": [
                {
                    "name": "tr_sites_modifydate",
                    "def": "CREATE TRIGGER tr_sites_modifydate BEFORE INSERT OR UPDATE ON ndb.specimens FOR EACH ROW EXECUTE FUNCTION ndb.update_recdatemodified()"
                }
            ]
        },
        {
            "name": "ndb.specimensextypes",
            "type": "BASE TABLE",
            "columns": [
                {
                    "name": "sexid",
                    "type": "integer",
                    "nullable": false,
                    "default": "nextval('ndb.seq_specimensextypes_sexid'::regclass)"
                },
                {
                    "name": "sex",
                    "type": "varchar(24)",
                    "nullable": false
                },
                {
                    "name": "recdatecreated",
                    "type": "timestamp(0) without time zone",
                    "nullable": false,
                    "default": "timezone('UTC'::text, now())"
                },
                {
                    "name": "recdatemodified",
                    "type": "timestamp(0) without time zone",
                    "nullable": false
                }
            ],
            "indexes": [
                {
                    "name": "specimensextypes_pkey",
                    "def": "CREATE UNIQUE INDEX specimensextypes_pkey ON ndb.specimensextypes USING btree (sexid)",
                    "table": "ndb.specimensextypes",
                    "columns": [
                        "sexid"
                    ]
                }
            ],
            "constraints": [
                {
                    "name": "specimensextypes_pkey",
                    "type": "PRIMARY KEY",
                    "def": "PRIMARY KEY (sexid)",
                    "table": "ndb.specimensextypes",
                    "referenced_table": "",
                    "columns": [
                        "sexid"
                    ]
                }
            ],
            "triggers": [
                {
                    "name": "tr_sites_modifydate",
                    "def": "CREATE TRIGGER tr_sites_modifydate BEFORE INSERT OR UPDATE ON ndb.specimensextypes FOR EACH ROW EXECUTE FUNCTION ndb.update_recdatemodified()"
                }
            ]
        },
        {
            "name": "ndb.specimentaphonomy",
            "type": "BASE TABLE",
            "columns": [
                {
                    "name": "specimenid",
                    "type": "integer",
                    "nullable": false
                },
                {
                    "name": "taphonomictypeid",
                    "type": "integer",
                    "nullable": false
                },
                {
                    "name": "recdatecreated",
                    "type": "timestamp(0) without time zone",
                    "nullable": false,
                    "default": "timezone('UTC'::text, now())"
                },
                {
                    "name": "recdatemodified",
                    "type": "timestamp(0) without time zone",
                    "nullable": false
                }
            ],
            "indexes": [
                {
                    "name": "specimentaphonomy_pkey",
                    "def": "CREATE UNIQUE INDEX specimentaphonomy_pkey ON ndb.specimentaphonomy USING btree (specimenid, taphonomictypeid)",
                    "table": "ndb.specimentaphonomy",
                    "columns": [
                        "specimenid",
                        "taphonomictypeid"
                    ]
                }
            ],
            "constraints": [
                {
                    "name": "fk_specimentaphonomy_specimens",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (specimenid) REFERENCES ndb.specimens(specimenid) ON UPDATE CASCADE ON DELETE CASCADE",
                    "table": "ndb.specimentaphonomy",
                    "referenced_table": "specimens",
                    "columns": [
                        "specimenid"
                    ],
                    "referenced_columns": [
                        "specimenid"
                    ]
                },
                {
                    "name": "specimentaphonomy_pkey",
                    "type": "PRIMARY KEY",
                    "def": "PRIMARY KEY (specimenid, taphonomictypeid)",
                    "table": "ndb.specimentaphonomy",
                    "referenced_table": "",
                    "columns": [
                        "specimenid",
                        "taphonomictypeid"
                    ]
                },
                {
                    "name": "fk_specimentaphonomy_taphonomictypes",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (taphonomictypeid) REFERENCES ndb.taphonomictypes(taphonomictypeid) ON UPDATE CASCADE ON DELETE CASCADE",
                    "table": "ndb.specimentaphonomy",
                    "referenced_table": "taphonomictypes",
                    "columns": [
                        "taphonomictypeid"
                    ],
                    "referenced_columns": [
                        "taphonomictypeid"
                    ]
                }
            ],
            "triggers": [
                {
                    "name": "tr_sites_modifydate",
                    "def": "CREATE TRIGGER tr_sites_modifydate BEFORE INSERT OR UPDATE ON ndb.specimentaphonomy FOR EACH ROW EXECUTE FUNCTION ndb.update_recdatemodified()"
                }
            ]
        },
        {
            "name": "ndb.summarydatataphonomy",
            "type": "BASE TABLE",
            "columns": [
                {
                    "name": "dataid",
                    "type": "integer",
                    "nullable": false
                },
                {
                    "name": "taphonomictypeid",
                    "type": "integer",
                    "nullable": false
                },
                {
                    "name": "recdatecreated",
                    "type": "timestamp(0) without time zone",
                    "nullable": false,
                    "default": "timezone('UTC'::text, now())"
                },
                {
                    "name": "recdatemodified",
                    "type": "timestamp(0) without time zone",
                    "nullable": false
                }
            ],
            "indexes": [
                {
                    "name": "summarydatataphonomy_pkey",
                    "def": "CREATE UNIQUE INDEX summarydatataphonomy_pkey ON ndb.summarydatataphonomy USING btree (dataid, taphonomictypeid)",
                    "table": "ndb.summarydatataphonomy",
                    "columns": [
                        "dataid",
                        "taphonomictypeid"
                    ]
                }
            ],
            "constraints": [
                {
                    "name": "fk_summarydatataphonomy_data",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (dataid) REFERENCES ndb.data(dataid) ON UPDATE CASCADE ON DELETE CASCADE",
                    "table": "ndb.summarydatataphonomy",
                    "referenced_table": "data",
                    "columns": [
                        "dataid"
                    ],
                    "referenced_columns": [
                        "dataid"
                    ]
                },
                {
                    "name": "summarydatataphonomy_pkey",
                    "type": "PRIMARY KEY",
                    "def": "PRIMARY KEY (dataid, taphonomictypeid)",
                    "table": "ndb.summarydatataphonomy",
                    "referenced_table": "",
                    "columns": [
                        "dataid",
                        "taphonomictypeid"
                    ]
                },
                {
                    "name": "fk_summarydatataphonomy_taphonomictypes",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (taphonomictypeid) REFERENCES ndb.taphonomictypes(taphonomictypeid) ON UPDATE CASCADE ON DELETE CASCADE",
                    "table": "ndb.summarydatataphonomy",
                    "referenced_table": "taphonomictypes",
                    "columns": [
                        "taphonomictypeid"
                    ],
                    "referenced_columns": [
                        "taphonomictypeid"
                    ]
                }
            ],
            "triggers": [
                {
                    "name": "tr_sites_modifydate",
                    "def": "CREATE TRIGGER tr_sites_modifydate BEFORE INSERT OR UPDATE ON ndb.summarydatataphonomy FOR EACH ROW EXECUTE FUNCTION ndb.update_recdatemodified()"
                }
            ]
        },
        {
            "name": "ndb.synonyms",
            "type": "BASE TABLE",
            "comment": "This table lists common synonyms for taxa in the Taxa table. No effort has been made to provide a complete taxonomic synonymy, but rather to list synonyms commonly used in recent literature.  This table is not the same as the Synonomy table, also present in Neotoma, which links a specific synonymy to a dataset",
            "columns": [
                {
                    "name": "synonymid",
                    "type": "integer",
                    "nullable": false,
                    "default": "nextval('ndb.seq_synonyms_synonymid'::regclass)",
                    "comment": "An arbitrary synonym identification number."
                },
                {
                    "name": "invalidtaxonid",
                    "type": "integer",
                    "nullable": false
                },
                {
                    "name": "validtaxonid",
                    "type": "integer",
                    "nullable": false
                },
                {
                    "name": "synonymtypeid",
                    "type": "integer",
                    "nullable": true,
                    "comment": "Type of synonym. Field links to the SynonymTypes lookup table."
                },
                {
                    "name": "recdatecreated",
                    "type": "timestamp(0) without time zone",
                    "nullable": false,
                    "default": "timezone('UTC'::text, now())"
                },
                {
                    "name": "recdatemodified",
                    "type": "timestamp(0) without time zone",
                    "nullable": false
                }
            ],
            "indexes": [
                {
                    "name": "synonyms_pkey",
                    "def": "CREATE UNIQUE INDEX synonyms_pkey ON ndb.synonyms USING btree (synonymid)",
                    "table": "ndb.synonyms",
                    "columns": [
                        "synonymid"
                    ]
                },
                {
                    "name": "ix_taxonid_synonyms",
                    "def": "CREATE INDEX ix_taxonid_synonyms ON ndb.synonyms USING btree (validtaxonid) WITH (fillfactor='10')",
                    "table": "ndb.synonyms",
                    "columns": [
                        "validtaxonid"
                    ]
                }
            ],
            "constraints": [
                {
                    "name": "synonyms_pkey",
                    "type": "PRIMARY KEY",
                    "def": "PRIMARY KEY (synonymid)",
                    "table": "ndb.synonyms",
                    "referenced_table": "",
                    "columns": [
                        "synonymid"
                    ]
                },
                {
                    "name": "fk_synonyms_synonymtypes",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (synonymtypeid) REFERENCES ndb.synonymtypes(synonymtypeid) ON UPDATE CASCADE ON DELETE CASCADE",
                    "table": "ndb.synonyms",
                    "referenced_table": "synonymtypes",
                    "columns": [
                        "synonymtypeid"
                    ],
                    "referenced_columns": [
                        "synonymtypeid"
                    ]
                },
                {
                    "name": "fk_synonyms_invalidtaxa",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (invalidtaxonid) REFERENCES ndb.taxa(taxonid) ON UPDATE CASCADE ON DELETE CASCADE",
                    "table": "ndb.synonyms",
                    "referenced_table": "taxa",
                    "columns": [
                        "invalidtaxonid"
                    ],
                    "referenced_columns": [
                        "taxonid"
                    ]
                },
                {
                    "name": "fk_synonyms_validtaxa",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (validtaxonid) REFERENCES ndb.taxa(taxonid)",
                    "table": "ndb.synonyms",
                    "referenced_table": "taxa",
                    "columns": [
                        "validtaxonid"
                    ],
                    "referenced_columns": [
                        "taxonid"
                    ]
                }
            ],
            "triggers": [
                {
                    "name": "tr_sites_modifydate",
                    "def": "CREATE TRIGGER tr_sites_modifydate BEFORE INSERT OR UPDATE ON ndb.synonyms FOR EACH ROW EXECUTE FUNCTION ndb.update_recdatemodified()"
                }
            ]
        },
        {
            "name": "ndb.synonymy",
            "type": "BASE TABLE",
            "comment": "The synonymy table links dataset-level synonymies to particular publications or contacts.  This allows users to maintain the original taxonomic information within a table, but tie it to newer and more authoritative taxonomic information.",
            "columns": [
                {
                    "name": "synonymyid",
                    "type": "integer",
                    "nullable": false,
                    "default": "nextval('ndb.seq_synonymy_synonymyid'::regclass)"
                },
                {
                    "name": "datasetid",
                    "type": "integer",
                    "nullable": false,
                    "comment": "DatasetID from the Datasets table"
                },
                {
                    "name": "taxonid",
                    "type": "integer",
                    "nullable": false
                },
                {
                    "name": "reftaxonid",
                    "type": "integer",
                    "nullable": false
                },
                {
                    "name": "fromcontributor",
                    "type": "boolean",
                    "nullable": true
                },
                {
                    "name": "publicationid",
                    "type": "integer",
                    "nullable": true
                },
                {
                    "name": "notes",
                    "type": "text",
                    "nullable": true
                },
                {
                    "name": "contactid",
                    "type": "integer",
                    "nullable": true
                },
                {
                    "name": "datesynonymized",
                    "type": "date",
                    "nullable": true
                },
                {
                    "name": "recdatecreated",
                    "type": "timestamp(0) without time zone",
                    "nullable": false,
                    "default": "timezone('UTC'::text, now())"
                },
                {
                    "name": "recdatemodified",
                    "type": "timestamp(0) without time zone",
                    "nullable": false
                }
            ],
            "indexes": [
                {
                    "name": "synonymy_pkey",
                    "def": "CREATE UNIQUE INDEX synonymy_pkey ON ndb.synonymy USING btree (synonymyid)",
                    "table": "ndb.synonymy",
                    "columns": [
                        "synonymyid"
                    ]
                }
            ],
            "constraints": [
                {
                    "name": "fk_synonymy_contacts",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (contactid) REFERENCES ndb.contacts(contactid)",
                    "table": "ndb.synonymy",
                    "referenced_table": "contacts",
                    "columns": [
                        "contactid"
                    ],
                    "referenced_columns": [
                        "contactid"
                    ]
                },
                {
                    "name": "fk_synonymy_datasets",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (datasetid) REFERENCES ndb.datasets(datasetid) ON UPDATE CASCADE ON DELETE CASCADE",
                    "table": "ndb.synonymy",
                    "referenced_table": "datasets",
                    "columns": [
                        "datasetid"
                    ],
                    "referenced_columns": [
                        "datasetid"
                    ]
                },
                {
                    "name": "fk_synonymy_publications",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (publicationid) REFERENCES ndb.publications(publicationid) ON UPDATE CASCADE ON DELETE CASCADE",
                    "table": "ndb.synonymy",
                    "referenced_table": "publications",
                    "columns": [
                        "publicationid"
                    ],
                    "referenced_columns": [
                        "publicationid"
                    ]
                },
                {
                    "name": "synonymy_pkey",
                    "type": "PRIMARY KEY",
                    "def": "PRIMARY KEY (synonymyid)",
                    "table": "ndb.synonymy",
                    "referenced_table": "",
                    "columns": [
                        "synonymyid"
                    ]
                },
                {
                    "name": "fk_synonymy_taxa1",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (taxonid) REFERENCES ndb.taxa(taxonid) ON UPDATE CASCADE ON DELETE CASCADE",
                    "table": "ndb.synonymy",
                    "referenced_table": "taxa",
                    "columns": [
                        "taxonid"
                    ],
                    "referenced_columns": [
                        "taxonid"
                    ]
                },
                {
                    "name": "fk_synonymy_taxa2",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (reftaxonid) REFERENCES ndb.taxa(taxonid)",
                    "table": "ndb.synonymy",
                    "referenced_table": "taxa",
                    "columns": [
                        "reftaxonid"
                    ],
                    "referenced_columns": [
                        "taxonid"
                    ]
                }
            ],
            "triggers": [
                {
                    "name": "tr_sites_modifydate",
                    "def": "CREATE TRIGGER tr_sites_modifydate BEFORE INSERT OR UPDATE ON ndb.synonymy FOR EACH ROW EXECUTE FUNCTION ndb.update_recdatemodified()"
                }
            ]
        },
        {
            "name": "ndb.sysdiagrams",
            "type": "BASE TABLE",
            "columns": [
                {
                    "name": "name",
                    "type": "varchar",
                    "nullable": false
                },
                {
                    "name": "principal_id",
                    "type": "integer",
                    "nullable": false
                },
                {
                    "name": "diagram_id",
                    "type": "integer",
                    "nullable": false,
                    "default": "nextval('ndb.seq_sysdiagrams_diagram_id'::regclass)"
                },
                {
                    "name": "version",
                    "type": "integer",
                    "nullable": true
                },
                {
                    "name": "definition",
                    "type": "bytea",
                    "nullable": true
                }
            ],
            "indexes": [
                {
                    "name": "sysdiagrams_pkey",
                    "def": "CREATE UNIQUE INDEX sysdiagrams_pkey ON ndb.sysdiagrams USING btree (diagram_id)",
                    "table": "ndb.sysdiagrams",
                    "columns": [
                        "diagram_id"
                    ]
                }
            ],
            "constraints": [
                {
                    "name": "sysdiagrams_pkey",
                    "type": "PRIMARY KEY",
                    "def": "PRIMARY KEY (diagram_id)",
                    "table": "ndb.sysdiagrams",
                    "referenced_table": "",
                    "columns": [
                        "diagram_id"
                    ]
                }
            ]
        },
        {
            "name": "ndb.taphonomicsystems",
            "type": "BASE TABLE",
            "columns": [
                {
                    "name": "taphonomicsystemid",
                    "type": "integer",
                    "nullable": false,
                    "default": "nextval('ndb.seq_taphonomicsystems_taphonomicsystemid'::regclass)"
                },
                {
                    "name": "taphonomicsystem",
                    "type": "varchar(64)",
                    "nullable": false
                },
                {
                    "name": "notes",
                    "type": "text",
                    "nullable": true
                },
                {
                    "name": "recdatecreated",
                    "type": "timestamp(0) without time zone",
                    "nullable": false,
                    "default": "timezone('UTC'::text, now())"
                },
                {
                    "name": "recdatemodified",
                    "type": "timestamp(0) without time zone",
                    "nullable": false
                }
            ],
            "indexes": [
                {
                    "name": "taphonomicsystems_pkey",
                    "def": "CREATE UNIQUE INDEX taphonomicsystems_pkey ON ndb.taphonomicsystems USING btree (taphonomicsystemid)",
                    "table": "ndb.taphonomicsystems",
                    "columns": [
                        "taphonomicsystemid"
                    ]
                }
            ],
            "constraints": [
                {
                    "name": "taphonomicsystems_pkey",
                    "type": "PRIMARY KEY",
                    "def": "PRIMARY KEY (taphonomicsystemid)",
                    "table": "ndb.taphonomicsystems",
                    "referenced_table": "",
                    "columns": [
                        "taphonomicsystemid"
                    ]
                }
            ],
            "triggers": [
                {
                    "name": "tr_sites_modifydate",
                    "def": "CREATE TRIGGER tr_sites_modifydate BEFORE INSERT OR UPDATE ON ndb.taphonomicsystems FOR EACH ROW EXECUTE FUNCTION ndb.update_recdatemodified()"
                }
            ]
        },
        {
            "name": "ndb.taphonomicsystemsdatasettypes",
            "type": "BASE TABLE",
            "columns": [
                {
                    "name": "datasettypeid",
                    "type": "integer",
                    "nullable": false
                },
                {
                    "name": "taphonomicsystemid",
                    "type": "integer",
                    "nullable": false
                },
                {
                    "name": "recdatecreated",
                    "type": "timestamp(0) without time zone",
                    "nullable": false,
                    "default": "timezone('UTC'::text, now())"
                },
                {
                    "name": "recdatemodified",
                    "type": "timestamp(0) without time zone",
                    "nullable": false
                }
            ],
            "indexes": [
                {
                    "name": "taphonomicsystemsdatasettypes_pkey",
                    "def": "CREATE UNIQUE INDEX taphonomicsystemsdatasettypes_pkey ON ndb.taphonomicsystemsdatasettypes USING btree (datasettypeid, taphonomicsystemid)",
                    "table": "ndb.taphonomicsystemsdatasettypes",
                    "columns": [
                        "datasettypeid",
                        "taphonomicsystemid"
                    ]
                }
            ],
            "constraints": [
                {
                    "name": "fk_taphonomicsystemsdatasettypes_taphonomicsystemsdatasettypes",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (datasettypeid) REFERENCES ndb.datasettypes(datasettypeid) ON UPDATE CASCADE ON DELETE CASCADE",
                    "table": "ndb.taphonomicsystemsdatasettypes",
                    "referenced_table": "datasettypes",
                    "columns": [
                        "datasettypeid"
                    ],
                    "referenced_columns": [
                        "datasettypeid"
                    ]
                },
                {
                    "name": "fk_taphonomicsystemsdatasettypes_taphonomicsystems",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (taphonomicsystemid) REFERENCES ndb.taphonomicsystems(taphonomicsystemid) ON UPDATE CASCADE ON DELETE CASCADE",
                    "table": "ndb.taphonomicsystemsdatasettypes",
                    "referenced_table": "taphonomicsystems",
                    "columns": [
                        "taphonomicsystemid"
                    ],
                    "referenced_columns": [
                        "taphonomicsystemid"
                    ]
                },
                {
                    "name": "taphonomicsystemsdatasettypes_pkey",
                    "type": "PRIMARY KEY",
                    "def": "PRIMARY KEY (datasettypeid, taphonomicsystemid)",
                    "table": "ndb.taphonomicsystemsdatasettypes",
                    "referenced_table": "",
                    "columns": [
                        "datasettypeid",
                        "taphonomicsystemid"
                    ]
                }
            ],
            "triggers": [
                {
                    "name": "tr_sites_modifydate",
                    "def": "CREATE TRIGGER tr_sites_modifydate BEFORE INSERT OR UPDATE ON ndb.taphonomicsystemsdatasettypes FOR EACH ROW EXECUTE FUNCTION ndb.update_recdatemodified()"
                }
            ]
        },
        {
            "name": "ndb.taphonomictypes",
            "type": "BASE TABLE",
            "columns": [
                {
                    "name": "taphonomictypeid",
                    "type": "integer",
                    "nullable": false,
                    "default": "nextval('ndb.seq_taphonomictypes_taphonomictypeid'::regclass)"
                },
                {
                    "name": "taphonomicsystemid",
                    "type": "integer",
                    "nullable": true
                },
                {
                    "name": "taphonomictype",
                    "type": "varchar(64)",
                    "nullable": false
                },
                {
                    "name": "notes",
                    "type": "text",
                    "nullable": true
                },
                {
                    "name": "recdatecreated",
                    "type": "timestamp(0) without time zone",
                    "nullable": false,
                    "default": "timezone('UTC'::text, now())"
                },
                {
                    "name": "recdatemodified",
                    "type": "timestamp(0) without time zone",
                    "nullable": false
                }
            ],
            "indexes": [
                {
                    "name": "taphonomictypes_pkey",
                    "def": "CREATE UNIQUE INDEX taphonomictypes_pkey ON ndb.taphonomictypes USING btree (taphonomictypeid)",
                    "table": "ndb.taphonomictypes",
                    "columns": [
                        "taphonomictypeid"
                    ]
                }
            ],
            "constraints": [
                {
                    "name": "fk_taphonomictypes_taphonomicsystems",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (taphonomicsystemid) REFERENCES ndb.taphonomicsystems(taphonomicsystemid) ON UPDATE CASCADE ON DELETE CASCADE",
                    "table": "ndb.taphonomictypes",
                    "referenced_table": "taphonomicsystems",
                    "columns": [
                        "taphonomicsystemid"
                    ],
                    "referenced_columns": [
                        "taphonomicsystemid"
                    ]
                },
                {
                    "name": "taphonomictypes_pkey",
                    "type": "PRIMARY KEY",
                    "def": "PRIMARY KEY (taphonomictypeid)",
                    "table": "ndb.taphonomictypes",
                    "referenced_table": "",
                    "columns": [
                        "taphonomictypeid"
                    ]
                }
            ],
            "triggers": [
                {
                    "name": "tr_sites_modifydate",
                    "def": "CREATE TRIGGER tr_sites_modifydate BEFORE INSERT OR UPDATE ON ndb.taphonomictypes FOR EACH ROW EXECUTE FUNCTION ndb.update_recdatemodified()"
                }
            ]
        },
        {
            "name": "ndb.taxaalthierarchy",
            "type": "BASE TABLE",
            "columns": [
                {
                    "name": "taxaalthierarchytypeid",
                    "type": "integer",
                    "nullable": false
                },
                {
                    "name": "taxonid",
                    "type": "integer",
                    "nullable": false
                },
                {
                    "name": "highertaxonid",
                    "type": "integer",
                    "nullable": false
                }
            ],
            "indexes": [
                {
                    "name": "taxaalthierarchy_pkey",
                    "def": "CREATE UNIQUE INDEX taxaalthierarchy_pkey ON ndb.taxaalthierarchy USING btree (taxaalthierarchytypeid, taxonid)",
                    "table": "ndb.taxaalthierarchy",
                    "columns": [
                        "taxaalthierarchytypeid",
                        "taxonid"
                    ]
                }
            ],
            "constraints": [
                {
                    "name": "fk_taxaalthierarchy_taxa",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (taxonid) REFERENCES ndb.taxa(taxonid) ON UPDATE CASCADE ON DELETE CASCADE",
                    "table": "ndb.taxaalthierarchy",
                    "referenced_table": "taxa",
                    "columns": [
                        "taxonid"
                    ],
                    "referenced_columns": [
                        "taxonid"
                    ]
                },
                {
                    "name": "fk_taxaalthierarchy_taxa1",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (highertaxonid) REFERENCES ndb.taxa(taxonid)",
                    "table": "ndb.taxaalthierarchy",
                    "referenced_table": "taxa",
                    "columns": [
                        "highertaxonid"
                    ],
                    "referenced_columns": [
                        "taxonid"
                    ]
                },
                {
                    "name": "taxaalthierarchy_pkey",
                    "type": "PRIMARY KEY",
                    "def": "PRIMARY KEY (taxaalthierarchytypeid, taxonid)",
                    "table": "ndb.taxaalthierarchy",
                    "referenced_table": "",
                    "columns": [
                        "taxaalthierarchytypeid",
                        "taxonid"
                    ]
                },
                {
                    "name": "fk_taxaalthierarchy_taxaalthierarchytypes",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (taxaalthierarchytypeid) REFERENCES ndb.taxaalthierarchytypes(taxaalthierarchytypeid) ON UPDATE CASCADE ON DELETE CASCADE",
                    "table": "ndb.taxaalthierarchy",
                    "referenced_table": "taxaalthierarchytypes",
                    "columns": [
                        "taxaalthierarchytypeid"
                    ],
                    "referenced_columns": [
                        "taxaalthierarchytypeid"
                    ]
                }
            ]
        },
        {
            "name": "ndb.taxaalthierarchytypes",
            "type": "BASE TABLE",
            "columns": [
                {
                    "name": "taxaalthierarchytypeid",
                    "type": "integer",
                    "nullable": false,
                    "default": "nextval('ndb.seq_taxaalthierarchytypes_taxaalthierarchytypeid'::regclass)"
                },
                {
                    "name": "taxaalthierarchyname",
                    "type": "varchar(50)",
                    "nullable": false
                },
                {
                    "name": "taxaalthierarchydescript",
                    "type": "text",
                    "nullable": true
                }
            ],
            "indexes": [
                {
                    "name": "taxaalthierarchytypes_pkey",
                    "def": "CREATE UNIQUE INDEX taxaalthierarchytypes_pkey ON ndb.taxaalthierarchytypes USING btree (taxaalthierarchytypeid)",
                    "table": "ndb.taxaalthierarchytypes",
                    "columns": [
                        "taxaalthierarchytypeid"
                    ]
                }
            ],
            "constraints": [
                {
                    "name": "taxaalthierarchytypes_pkey",
                    "type": "PRIMARY KEY",
                    "def": "PRIMARY KEY (taxaalthierarchytypeid)",
                    "table": "ndb.taxaalthierarchytypes",
                    "referenced_table": "",
                    "columns": [
                        "taxaalthierarchytypeid"
                    ]
                }
            ]
        },
        {
            "name": "ndb.taxagrouptypes",
            "type": "BASE TABLE",
            "comment": "Lookup table for Taxa Group Types. This table is referenced by the Taxa table.",
            "columns": [
                {
                    "name": "taxagroupid",
                    "type": "varchar(3)",
                    "nullable": false,
                    "comment": "A three-letter Taxa Group code."
                },
                {
                    "name": "taxagroup",
                    "type": "varchar(64)",
                    "nullable": false,
                    "comment": "The taxa group. Below are some examples:\nTaxaGroupID\nTaxaGroup\nAVE\nBirds\nBIM\nBiometric variables\nBRY\nBryophytes\nBTL\nBeetles\nFSH\nFish\nHRP\nReptiles and amphibians\nLAB\nLaboratory analyses\nMAM\nMammals\nMOL\nMolluscs\nPHY\nPhysical variables\nTES\nTestate amoebae\nVPL\nVascular plants"
                },
                {
                    "name": "recdatecreated",
                    "type": "timestamp(0) without time zone",
                    "nullable": false,
                    "default": "timezone('UTC'::text, now())"
                },
                {
                    "name": "recdatemodified",
                    "type": "timestamp(0) without time zone",
                    "nullable": false
                }
            ],
            "indexes": [
                {
                    "name": "taxagrouptypes_pkey",
                    "def": "CREATE UNIQUE INDEX taxagrouptypes_pkey ON ndb.taxagrouptypes USING btree (taxagroupid)",
                    "table": "ndb.taxagrouptypes",
                    "columns": [
                        "taxagroupid"
                    ]
                }
            ],
            "constraints": [
                {
                    "name": "taxagrouptypes_pkey",
                    "type": "PRIMARY KEY",
                    "def": "PRIMARY KEY (taxagroupid)",
                    "table": "ndb.taxagrouptypes",
                    "referenced_table": "",
                    "columns": [
                        "taxagroupid"
                    ]
                }
            ],
            "triggers": [
                {
                    "name": "tr_sites_modifydate",
                    "def": "CREATE TRIGGER tr_sites_modifydate BEFORE INSERT OR UPDATE ON ndb.taxagrouptypes FOR EACH ROW EXECUTE FUNCTION ndb.update_recdatemodified()"
                }
            ]
        },
        {
            "name": "ndb.taxonpaths",
            "type": "BASE TABLE",
            "columns": [
                {
                    "name": "taxonout",
                    "type": "integer[]",
                    "nullable": false
                },
                {
                    "name": "taxonid",
                    "type": "bigint",
                    "nullable": false
                }
            ],
            "indexes": [
                {
                    "name": "taxonpaths_pkey",
                    "def": "CREATE UNIQUE INDEX taxonpaths_pkey ON ndb.taxonpaths USING btree (taxonout, taxonid)",
                    "table": "ndb.taxonpaths",
                    "columns": [
                        "taxonout",
                        "taxonid"
                    ]
                }
            ],
            "constraints": [
                {
                    "name": "taxonpaths_taxonid_fkey",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (taxonid) REFERENCES ndb.taxa(taxonid) ON DELETE CASCADE",
                    "table": "ndb.taxonpaths",
                    "referenced_table": "taxa",
                    "columns": [
                        "taxonid"
                    ],
                    "referenced_columns": [
                        "taxonid"
                    ]
                },
                {
                    "name": "taxonpaths_pkey",
                    "type": "PRIMARY KEY",
                    "def": "PRIMARY KEY (taxonout, taxonid)",
                    "table": "ndb.taxonpaths",
                    "referenced_table": "",
                    "columns": [
                        "taxonout",
                        "taxonid"
                    ]
                }
            ]
        },
        {
            "name": "ndb.tephras",
            "type": "BASE TABLE",
            "comment": "Tephras lookup table. This table stores recognized tephras with established ages. Referenced by the Tephrachronology table.",
            "columns": [
                {
                    "name": "tephraid",
                    "type": "integer",
                    "nullable": false,
                    "default": "nextval('ndb.seq_tephras_tephraid'::regclass)",
                    "comment": "An arbitrary Tephra identification number."
                },
                {
                    "name": "eventid",
                    "type": "integer",
                    "nullable": false
                },
                {
                    "name": "analysisunitid",
                    "type": "integer",
                    "nullable": false
                },
                {
                    "name": "notes",
                    "type": "text",
                    "nullable": true,
                    "comment": "Free form notes or comments about the tephra."
                },
                {
                    "name": "recdatecreated",
                    "type": "timestamp(0) without time zone",
                    "nullable": false,
                    "default": "timezone('UTC'::text, now())"
                },
                {
                    "name": "recdatemodified",
                    "type": "timestamp(0) without time zone",
                    "nullable": false
                }
            ],
            "indexes": [
                {
                    "name": "tephras_pkey",
                    "def": "CREATE UNIQUE INDEX tephras_pkey ON ndb.tephras USING btree (tephraid)",
                    "table": "ndb.tephras",
                    "columns": [
                        "tephraid"
                    ]
                }
            ],
            "constraints": [
                {
                    "name": "fk_tephras_analysisunits",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (analysisunitid) REFERENCES ndb.analysisunits(analysisunitid) ON UPDATE CASCADE ON DELETE CASCADE",
                    "table": "ndb.tephras",
                    "referenced_table": "analysisunits",
                    "columns": [
                        "analysisunitid"
                    ],
                    "referenced_columns": [
                        "analysisunitid"
                    ]
                },
                {
                    "name": "fk_tephras_events",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (eventid) REFERENCES ndb.events(eventid) ON UPDATE CASCADE ON DELETE CASCADE",
                    "table": "ndb.tephras",
                    "referenced_table": "events",
                    "columns": [
                        "eventid"
                    ],
                    "referenced_columns": [
                        "eventid"
                    ]
                },
                {
                    "name": "tephras_pkey",
                    "type": "PRIMARY KEY",
                    "def": "PRIMARY KEY (tephraid)",
                    "table": "ndb.tephras",
                    "referenced_table": "",
                    "columns": [
                        "tephraid"
                    ]
                }
            ],
            "triggers": [
                {
                    "name": "tr_sites_modifydate",
                    "def": "CREATE TRIGGER tr_sites_modifydate BEFORE INSERT OR UPDATE ON ndb.tephras FOR EACH ROW EXECUTE FUNCTION ndb.update_recdatemodified()"
                }
            ]
        },
        {
            "name": "ndb.variablecontexts",
            "type": "BASE TABLE",
            "comment": "Variable Contexts lookup table. Table is referenced by the Variables table.",
            "columns": [
                {
                    "name": "variablecontextid",
                    "type": "integer",
                    "nullable": false,
                    "default": "nextval('ndb.seq_variablecontexts_variablecontextid'::regclass)",
                    "comment": "An arbitrary Variable Context identification number."
                },
                {
                    "name": "variablecontext",
                    "type": "varchar(64)",
                    "nullable": false,
                    "comment": "Depositional context. Examples are:\n*anachronic – specimen older than the primary deposit, e.g. a Paleozoic spore in a Holocene deposit; may be redeposited from the catchment or may be derived from long distance, e.g. Tertiary pollen grains in Quaternary sediments with no local Tertiary source. A Pleistocene specimen in a Holocene archaeological deposit, possibly resulting from aboriginal fossil collecting, would also be anachronic.\n*intrusive – specimen generally younger younger than the primary deposit, e.g. a domestic pig in an otherwise Pleistocene deposit in North America.\n*redeposited – specimen older than the primary deposit and assumed to have been redeposited from a local source by natural causes.\n*articulated – articulated skeleton\n*clump – clump, esp. of pollen grains\n"
                },
                {
                    "name": "recdatecreated",
                    "type": "timestamp(0) without time zone",
                    "nullable": false,
                    "default": "timezone('UTC'::text, now())"
                },
                {
                    "name": "recdatemodified",
                    "type": "timestamp(0) without time zone",
                    "nullable": false
                }
            ],
            "indexes": [
                {
                    "name": "variablecontexts_pkey",
                    "def": "CREATE UNIQUE INDEX variablecontexts_pkey ON ndb.variablecontexts USING btree (variablecontextid)",
                    "table": "ndb.variablecontexts",
                    "columns": [
                        "variablecontextid"
                    ]
                }
            ],
            "constraints": [
                {
                    "name": "variablecontexts_pkey",
                    "type": "PRIMARY KEY",
                    "def": "PRIMARY KEY (variablecontextid)",
                    "table": "ndb.variablecontexts",
                    "referenced_table": "",
                    "columns": [
                        "variablecontextid"
                    ]
                }
            ],
            "triggers": [
                {
                    "name": "tr_sites_modifydate",
                    "def": "CREATE TRIGGER tr_sites_modifydate BEFORE INSERT OR UPDATE ON ndb.variablecontexts FOR EACH ROW EXECUTE FUNCTION ndb.update_recdatemodified()"
                }
            ]
        },
        {
            "name": "ndb.variableelements",
            "type": "BASE TABLE",
            "comment": "Lookup table of Variable Elements. Table is referenced by the Variables table.",
            "columns": [
                {
                    "name": "variableelementid",
                    "type": "integer",
                    "nullable": false,
                    "default": "nextval('ndb.seq_variableelements_variableelementid'::regclass)",
                    "comment": "An arbitrary Variable Element identification number."
                },
                {
                    "name": "variableelement",
                    "type": "varchar(255)",
                    "nullable": true,
                    "comment": "The element, part, or organ of the taxon identified. For plants, these include pollen, spores, and various macrofossil organs, such as «seed», «twig», «cone», and «cone bract». Thus, Betula pollen and Betula seeds are two different Variables. For mammals, Elements include the bone or tooth identified, e.g. «tibia». «tibia, distal, left», «M2, lower, left». Some more unusual elements are Neotoma fecal pellets and Erethizon dorsata quills. If no element is indicated for mammalian fauna, then the genric element «bone/tooth» is assigned. Elements were not assigned in FAUNMAP, so all Variables ingested from FAUNMAP were assigned the «bone/tooth» element. Physical Variables may also have elements. For example, the Loss-on-ignition Variables have «Loss-on-ignition» as a Taxon, and temperature of analysis as an element, e.g. «500°C», «900°C». Charcoal Variables have the size fragments as elements, e.g. «75-100 µm», «100-125 µm»."
                },
                {
                    "name": "elementtypeid",
                    "type": "integer",
                    "nullable": true
                },
                {
                    "name": "symmetryid",
                    "type": "integer",
                    "nullable": true
                },
                {
                    "name": "portionid",
                    "type": "integer",
                    "nullable": true
                },
                {
                    "name": "maturityid",
                    "type": "integer",
                    "nullable": true
                },
                {
                    "name": "recdatecreated",
                    "type": "timestamp(0) without time zone",
                    "nullable": false,
                    "default": "timezone('UTC'::text, now())"
                },
                {
                    "name": "recdatemodified",
                    "type": "timestamp(0) without time zone",
                    "nullable": false
                }
            ],
            "indexes": [
                {
                    "name": "variableelements_pkey",
                    "def": "CREATE UNIQUE INDEX variableelements_pkey ON ndb.variableelements USING btree (variableelementid)",
                    "table": "ndb.variableelements",
                    "columns": [
                        "variableelementid"
                    ]
                }
            ],
            "constraints": [
                {
                    "name": "fk_variableelements_elementmaturities",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (maturityid) REFERENCES ndb.elementmaturities(maturityid) ON UPDATE CASCADE ON DELETE CASCADE",
                    "table": "ndb.variableelements",
                    "referenced_table": "elementmaturities",
                    "columns": [
                        "maturityid"
                    ],
                    "referenced_columns": [
                        "maturityid"
                    ]
                },
                {
                    "name": "fk_variableelements_elementportions",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (portionid) REFERENCES ndb.elementportions(portionid) ON UPDATE CASCADE ON DELETE CASCADE",
                    "table": "ndb.variableelements",
                    "referenced_table": "elementportions",
                    "columns": [
                        "portionid"
                    ],
                    "referenced_columns": [
                        "portionid"
                    ]
                },
                {
                    "name": "fk_variableelements_elementsymmetries",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (symmetryid) REFERENCES ndb.elementsymmetries(symmetryid) ON UPDATE CASCADE ON DELETE CASCADE",
                    "table": "ndb.variableelements",
                    "referenced_table": "elementsymmetries",
                    "columns": [
                        "symmetryid"
                    ],
                    "referenced_columns": [
                        "symmetryid"
                    ]
                },
                {
                    "name": "fk_variableelements_elementtypes",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (elementtypeid) REFERENCES ndb.elementtypes(elementtypeid)",
                    "table": "ndb.variableelements",
                    "referenced_table": "elementtypes",
                    "columns": [
                        "elementtypeid"
                    ],
                    "referenced_columns": [
                        "elementtypeid"
                    ]
                },
                {
                    "name": "variableelements_pkey",
                    "type": "PRIMARY KEY",
                    "def": "PRIMARY KEY (variableelementid)",
                    "table": "ndb.variableelements",
                    "referenced_table": "",
                    "columns": [
                        "variableelementid"
                    ]
                }
            ],
            "triggers": [
                {
                    "name": "tr_sites_modifydate",
                    "def": "CREATE TRIGGER tr_sites_modifydate BEFORE INSERT OR UPDATE ON ndb.variableelements FOR EACH ROW EXECUTE FUNCTION ndb.update_recdatemodified()"
                }
            ]
        },
        {
            "name": "ti.dslinks",
            "type": "VIEW",
            "columns": [
                {
                    "name": "siteid",
                    "type": "integer",
                    "nullable": true
                },
                {
                    "name": "collectionunitid",
                    "type": "integer",
                    "nullable": true
                },
                {
                    "name": "datasetid",
                    "type": "integer",
                    "nullable": true
                }
            ],
            "def": "CREATE VIEW dslinks AS (\n SELECT sites.siteid,\n    collectionunits.collectionunitid,\n    datasets.datasetid\n   FROM ((ndb.sites\n     JOIN ndb.collectionunits ON ((sites.siteid = collectionunits.siteid)))\n     JOIN ndb.datasets ON ((collectionunits.collectionunitid = datasets.collectionunitid)))\n)",
            "referenced_tables": [
                "ndb.sites",
                "ndb.collectionunits",
                "ndb.datasets"
            ]
        },
        {
            "name": "ti.geopol1",
            "type": "VIEW",
            "columns": [
                {
                    "name": "siteid",
                    "type": "integer",
                    "nullable": true
                },
                {
                    "name": "geopolname1",
                    "type": "varchar(255)",
                    "nullable": true
                }
            ],
            "def": "CREATE VIEW geopol1 AS (\n SELECT sites.siteid,\n    geopoliticalunits.geopoliticalname AS geopolname1\n   FROM (ndb.sites\n     JOIN (ndb.geopoliticalunits\n     JOIN ndb.sitegeopolitical ON ((geopoliticalunits.geopoliticalid = sitegeopolitical.geopoliticalid))) ON ((sites.siteid = sitegeopolitical.siteid)))\n  WHERE (geopoliticalunits.rank = 1)\n)",
            "referenced_tables": [
                "ndb.sites",
                "ndb.geopoliticalunits",
                "ndb.sitegeopolitical"
            ]
        },
        {
            "name": "ti.geopol2",
            "type": "VIEW",
            "columns": [
                {
                    "name": "siteid",
                    "type": "integer",
                    "nullable": true
                },
                {
                    "name": "geopolname2",
                    "type": "varchar(255)",
                    "nullable": true
                }
            ],
            "def": "CREATE VIEW geopol2 AS (\n SELECT sites.siteid,\n    geopoliticalunits.geopoliticalname AS geopolname2\n   FROM (ndb.sites\n     JOIN (ndb.geopoliticalunits\n     JOIN ndb.sitegeopolitical ON ((geopoliticalunits.geopoliticalid = sitegeopolitical.geopoliticalid))) ON ((sites.siteid = sitegeopolitical.siteid)))\n  WHERE (geopoliticalunits.rank = 2)\n)",
            "referenced_tables": [
                "ndb.sites",
                "ndb.geopoliticalunits",
                "ndb.sitegeopolitical"
            ]
        },
        {
            "name": "ti.geopol3",
            "type": "VIEW",
            "columns": [
                {
                    "name": "siteid",
                    "type": "integer",
                    "nullable": true
                },
                {
                    "name": "geopolname3",
                    "type": "varchar(255)",
                    "nullable": true
                }
            ],
            "def": "CREATE VIEW geopol3 AS (\n SELECT sites.siteid,\n    geopoliticalunits.geopoliticalname AS geopolname3\n   FROM (ndb.sites\n     JOIN (ndb.geopoliticalunits\n     JOIN ndb.sitegeopolitical ON ((geopoliticalunits.geopoliticalid = sitegeopolitical.geopoliticalid))) ON ((sites.siteid = sitegeopolitical.siteid)))\n  WHERE (geopoliticalunits.rank = 3)\n)",
            "referenced_tables": [
                "ndb.sites",
                "ndb.geopoliticalunits",
                "ndb.sitegeopolitical"
            ]
        },
        {
            "name": "ti.geopol4",
            "type": "VIEW",
            "columns": [
                {
                    "name": "siteid",
                    "type": "integer",
                    "nullable": true
                },
                {
                    "name": "geopolname4",
                    "type": "varchar(255)",
                    "nullable": true
                }
            ],
            "def": "CREATE VIEW geopol4 AS (\n SELECT sites.siteid,\n    geopoliticalunits.geopoliticalname AS geopolname4\n   FROM (ndb.sites\n     JOIN (ndb.geopoliticalunits\n     JOIN ndb.sitegeopolitical ON ((geopoliticalunits.geopoliticalid = sitegeopolitical.geopoliticalid))) ON ((sites.siteid = sitegeopolitical.siteid)))\n  WHERE (geopoliticalunits.rank = 4)\n)",
            "referenced_tables": [
                "ndb.sites",
                "ndb.geopoliticalunits",
                "ndb.sitegeopolitical"
            ]
        },
        {
            "name": "ti.stewarddatabases",
            "type": "BASE TABLE",
            "columns": [
                {
                    "name": "stewardid",
                    "type": "integer",
                    "nullable": false
                },
                {
                    "name": "databaseid",
                    "type": "integer",
                    "nullable": false
                }
            ],
            "indexes": [
                {
                    "name": "stewarddatabases_pkey",
                    "def": "CREATE UNIQUE INDEX stewarddatabases_pkey ON ti.stewarddatabases USING btree (stewardid, databaseid)",
                    "table": "ti.stewarddatabases",
                    "columns": [
                        "stewardid",
                        "databaseid"
                    ]
                }
            ],
            "constraints": [
                {
                    "name": "fk_stewarddatabases_constituentdatabases",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (databaseid) REFERENCES ndb.constituentdatabases(databaseid) ON UPDATE CASCADE ON DELETE CASCADE",
                    "table": "ti.stewarddatabases",
                    "referenced_table": "constituentdatabases",
                    "columns": [
                        "databaseid"
                    ],
                    "referenced_columns": [
                        "databaseid"
                    ]
                },
                {
                    "name": "stewarddatabases_pkey",
                    "type": "PRIMARY KEY",
                    "def": "PRIMARY KEY (stewardid, databaseid)",
                    "table": "ti.stewarddatabases",
                    "referenced_table": "",
                    "columns": [
                        "stewardid",
                        "databaseid"
                    ]
                },
                {
                    "name": "fk_stewarddatabases_stewards",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (stewardid) REFERENCES ti.stewards(stewardid) ON UPDATE CASCADE ON DELETE CASCADE",
                    "table": "ti.stewarddatabases",
                    "referenced_table": "stewards",
                    "columns": [
                        "stewardid"
                    ],
                    "referenced_columns": [
                        "stewardid"
                    ]
                }
            ]
        },
        {
            "name": "ti.stewards",
            "type": "BASE TABLE",
            "columns": [
                {
                    "name": "stewardid",
                    "type": "integer",
                    "nullable": false,
                    "default": "nextval('ti.stewardid_seq'::regclass)"
                },
                {
                    "name": "contactid",
                    "type": "integer",
                    "nullable": false
                },
                {
                    "name": "username",
                    "type": "varchar(15)",
                    "nullable": false
                },
                {
                    "name": "pwd",
                    "type": "varchar(15)",
                    "nullable": false
                },
                {
                    "name": "taxonomyexpert",
                    "type": "boolean",
                    "nullable": false
                },
                {
                    "name": "recdatecreated",
                    "type": "timestamp(0) without time zone",
                    "nullable": true
                },
                {
                    "name": "recdatemodified",
                    "type": "timestamp(0) without time zone",
                    "nullable": true
                }
            ],
            "indexes": [
                {
                    "name": "stewards_pkey",
                    "def": "CREATE UNIQUE INDEX stewards_pkey ON ti.stewards USING btree (stewardid)",
                    "table": "ti.stewards",
                    "columns": [
                        "stewardid"
                    ]
                }
            ],
            "constraints": [
                {
                    "name": "fk_stewards_contacts",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (contactid) REFERENCES ndb.contacts(contactid) ON UPDATE CASCADE",
                    "table": "ti.stewards",
                    "referenced_table": "contacts",
                    "columns": [
                        "contactid"
                    ],
                    "referenced_columns": [
                        "contactid"
                    ]
                },
                {
                    "name": "stewards_pkey",
                    "type": "PRIMARY KEY",
                    "def": "PRIMARY KEY (stewardid)",
                    "table": "ti.stewards",
                    "referenced_table": "",
                    "columns": [
                        "stewardid"
                    ]
                }
            ],
            "triggers": [
                {
                    "name": "record_update",
                    "def": "CREATE TRIGGER record_update BEFORE INSERT OR UPDATE ON ti.stewards FOR EACH ROW EXECUTE FUNCTION ti.update_recdatemodified()"
                },
                {
                    "name": "recordcreated",
                    "def": "CREATE TRIGGER recordcreated BEFORE INSERT ON ti.stewards FOR EACH ROW EXECUTE FUNCTION ti.reccreate()"
                }
            ]
        },
        {
            "name": "ti.stewardupdates",
            "type": "BASE TABLE",
            "columns": [
                {
                    "name": "updateid",
                    "type": "integer",
                    "nullable": false
                },
                {
                    "name": "contactid",
                    "type": "integer",
                    "nullable": false
                },
                {
                    "name": "tablename",
                    "type": "varchar(64)",
                    "nullable": false
                },
                {
                    "name": "pk1",
                    "type": "integer",
                    "nullable": true
                },
                {
                    "name": "pk2",
                    "type": "integer",
                    "nullable": true
                },
                {
                    "name": "pk3",
                    "type": "varchar(24)",
                    "nullable": true
                },
                {
                    "name": "operation",
                    "type": "varchar(24)",
                    "nullable": false
                },
                {
                    "name": "columnname",
                    "type": "varchar(64)",
                    "nullable": true
                },
                {
                    "name": "dateupdated",
                    "type": "timestamp(0) without time zone",
                    "nullable": false
                }
            ],
            "indexes": [
                {
                    "name": "stewardupdates_pkey",
                    "def": "CREATE UNIQUE INDEX stewardupdates_pkey ON ti.stewardupdates USING btree (updateid)",
                    "table": "ti.stewardupdates",
                    "columns": [
                        "updateid"
                    ]
                }
            ],
            "constraints": [
                {
                    "name": "fk_stewardupdates_contacts",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (contactid) REFERENCES ndb.contacts(contactid)",
                    "table": "ti.stewardupdates",
                    "referenced_table": "contacts",
                    "columns": [
                        "contactid"
                    ],
                    "referenced_columns": [
                        "contactid"
                    ]
                },
                {
                    "name": "stewardupdates_pkey",
                    "type": "PRIMARY KEY",
                    "def": "PRIMARY KEY (updateid)",
                    "table": "ti.stewardupdates",
                    "referenced_table": "",
                    "columns": [
                        "updateid"
                    ]
                }
            ],
            "triggers": [
                {
                    "name": "record_update",
                    "def": "CREATE TRIGGER record_update BEFORE INSERT OR UPDATE ON ti.stewardupdates FOR EACH ROW EXECUTE FUNCTION ti.update_recdatemodified()"
                }
            ]
        },
        {
            "name": "ts.stewardauthorization",
            "type": "VIEW",
            "columns": [
                {
                    "name": "stewardid",
                    "type": "integer",
                    "nullable": true
                },
                {
                    "name": "firstname",
                    "type": "varchar(80)",
                    "nullable": true
                },
                {
                    "name": "lastname",
                    "type": "varchar(80)",
                    "nullable": true
                },
                {
                    "name": "username",
                    "type": "varchar(15)",
                    "nullable": true
                },
                {
                    "name": "pwd",
                    "type": "varchar(15)",
                    "nullable": true
                },
                {
                    "name": "authorized",
                    "type": "integer",
                    "nullable": true
                }
            ],
            "def": "CREATE VIEW stewardauthorization AS (\n SELECT stewards.stewardid,\n    contacts.givennames AS firstname,\n    contacts.familyname AS lastname,\n    stewards.username,\n    stewards.pwd,\n    stewarddatabases.databaseid AS authorized\n   FROM ((ti.stewards\n     JOIN ndb.contacts ON ((stewards.contactid = contacts.contactid)))\n     JOIN ti.stewarddatabases ON ((stewards.stewardid = stewarddatabases.stewardid)))\n)",
            "referenced_tables": [
                "ti.stewards",
                "ndb.contacts",
                "ti.stewarddatabases"
            ]
        },
        {
            "name": "ndb.uncertaintybases",
            "type": "BASE TABLE",
            "columns": [
                {
                    "name": "uncertaintybasisid",
                    "type": "integer",
                    "nullable": false,
                    "default": "nextval('ndb.uncertaintybases_uncertaintybasisid_seq'::regclass)"
                },
                {
                    "name": "uncertaintybasis",
                    "type": "text",
                    "nullable": true
                }
            ],
            "indexes": [
                {
                    "name": "uncertaintybases_pkey",
                    "def": "CREATE UNIQUE INDEX uncertaintybases_pkey ON ndb.uncertaintybases USING btree (uncertaintybasisid)",
                    "table": "ndb.uncertaintybases",
                    "columns": [
                        "uncertaintybasisid"
                    ]
                },
                {
                    "name": "uniquebasis",
                    "def": "CREATE UNIQUE INDEX uniquebasis ON ndb.uncertaintybases USING btree (uncertaintybasis)",
                    "table": "ndb.uncertaintybases",
                    "columns": [
                        "uncertaintybasis"
                    ]
                }
            ],
            "constraints": [
                {
                    "name": "uncertaintybases_pkey",
                    "type": "PRIMARY KEY",
                    "def": "PRIMARY KEY (uncertaintybasisid)",
                    "table": "ndb.uncertaintybases",
                    "referenced_table": "",
                    "columns": [
                        "uncertaintybasisid"
                    ]
                },
                {
                    "name": "uniquebasis",
                    "type": "UNIQUE",
                    "def": "UNIQUE (uncertaintybasis)",
                    "table": "ndb.uncertaintybases",
                    "referenced_table": "",
                    "columns": [
                        "uncertaintybasis"
                    ]
                }
            ]
        },
        {
            "name": "ndb.datauncertainties",
            "type": "BASE TABLE",
            "columns": [
                {
                    "name": "dataid",
                    "type": "integer",
                    "nullable": true
                },
                {
                    "name": "uncertaintyvalue",
                    "type": "double precision",
                    "nullable": true
                },
                {
                    "name": "uncertaintyunitid",
                    "type": "integer",
                    "nullable": true
                },
                {
                    "name": "uncertaintybasisid",
                    "type": "integer",
                    "nullable": true
                },
                {
                    "name": "notes",
                    "type": "text",
                    "nullable": true
                }
            ],
            "indexes": [
                {
                    "name": "uniqueentryvalue",
                    "def": "CREATE UNIQUE INDEX uniqueentryvalue ON ndb.datauncertainties USING btree (dataid, uncertaintyunitid, uncertaintybasisid)",
                    "table": "ndb.datauncertainties",
                    "columns": [
                        "dataid",
                        "uncertaintyunitid",
                        "uncertaintybasisid"
                    ]
                }
            ],
            "constraints": [
                {
                    "name": "datauncertainties_dataid_fkey",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (dataid) REFERENCES ndb.data(dataid) ON DELETE CASCADE",
                    "table": "ndb.datauncertainties",
                    "referenced_table": "data",
                    "columns": [
                        "dataid"
                    ],
                    "referenced_columns": [
                        "dataid"
                    ]
                },
                {
                    "name": "datauncertainties_uncertaintyunitid_fkey",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (uncertaintyunitid) REFERENCES ndb.variableunits(variableunitsid)",
                    "table": "ndb.datauncertainties",
                    "referenced_table": "variableunits",
                    "columns": [
                        "uncertaintyunitid"
                    ],
                    "referenced_columns": [
                        "variableunitsid"
                    ]
                },
                {
                    "name": "datauncertainties_uncertaintybasisid_fkey",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (uncertaintybasisid) REFERENCES ndb.uncertaintybases(uncertaintybasisid)",
                    "table": "ndb.datauncertainties",
                    "referenced_table": "uncertaintybases",
                    "columns": [
                        "uncertaintybasisid"
                    ],
                    "referenced_columns": [
                        "uncertaintybasisid"
                    ]
                },
                {
                    "name": "uniqueentryvalue",
                    "type": "UNIQUE",
                    "def": "UNIQUE (dataid, uncertaintyunitid, uncertaintybasisid)",
                    "table": "ndb.datauncertainties",
                    "referenced_table": "",
                    "columns": [
                        "dataid",
                        "uncertaintyunitid",
                        "uncertaintybasisid"
                    ]
                }
            ]
        },
        {
            "name": "ap.gadm",
            "type": "BASE TABLE",
            "columns": [
                {
                    "name": "objectid",
                    "type": "integer",
                    "nullable": false,
                    "default": "nextval('ap.gadm_objectid_seq'::regclass)"
                },
                {
                    "name": "uid",
                    "type": "integer",
                    "nullable": true
                },
                {
                    "name": "gid_0",
                    "type": "varchar(3)",
                    "nullable": true
                },
                {
                    "name": "name_0",
                    "type": "varchar(44)",
                    "nullable": true
                },
                {
                    "name": "varname_0",
                    "type": "varchar(29)",
                    "nullable": true
                },
                {
                    "name": "gid_1",
                    "type": "varchar(8)",
                    "nullable": true
                },
                {
                    "name": "name_1",
                    "type": "varchar(50)",
                    "nullable": true
                },
                {
                    "name": "varname_1",
                    "type": "varchar(129)",
                    "nullable": true
                },
                {
                    "name": "nl_name_1",
                    "type": "varchar(87)",
                    "nullable": true
                },
                {
                    "name": "iso_1",
                    "type": "varchar(8)",
                    "nullable": true
                },
                {
                    "name": "hasc_1",
                    "type": "varchar(10)",
                    "nullable": true
                },
                {
                    "name": "cc_1",
                    "type": "varchar(9)",
                    "nullable": true
                },
                {
                    "name": "type_1",
                    "type": "varchar(37)",
                    "nullable": true
                },
                {
                    "name": "engtype_1",
                    "type": "varchar(37)",
                    "nullable": true
                },
                {
                    "name": "validfr_1",
                    "type": "varchar(15)",
                    "nullable": true
                },
                {
                    "name": "gid_2",
                    "type": "varchar(12)",
                    "nullable": true
                },
                {
                    "name": "name_2",
                    "type": "varchar(51)",
                    "nullable": true
                },
                {
                    "name": "varname_2",
                    "type": "varchar(116)",
                    "nullable": true
                },
                {
                    "name": "nl_name_2",
                    "type": "varchar(75)",
                    "nullable": true
                },
                {
                    "name": "hasc_2",
                    "type": "varchar(15)",
                    "nullable": true
                },
                {
                    "name": "cc_2",
                    "type": "varchar(12)",
                    "nullable": true
                },
                {
                    "name": "type_2",
                    "type": "varchar(43)",
                    "nullable": true
                },
                {
                    "name": "engtype_2",
                    "type": "varchar(34)",
                    "nullable": true
                },
                {
                    "name": "validfr_2",
                    "type": "varchar(15)",
                    "nullable": true
                },
                {
                    "name": "gid_3",
                    "type": "varchar(15)",
                    "nullable": true
                },
                {
                    "name": "name_3",
                    "type": "varchar(64)",
                    "nullable": true
                },
                {
                    "name": "varname_3",
                    "type": "varchar(54)",
                    "nullable": true
                },
                {
                    "name": "nl_name_3",
                    "type": "varchar(56)",
                    "nullable": true
                },
                {
                    "name": "hasc_3",
                    "type": "varchar(27)",
                    "nullable": true
                },
                {
                    "name": "cc_3",
                    "type": "varchar(9)",
                    "nullable": true
                },
                {
                    "name": "type_3",
                    "type": "varchar(34)",
                    "nullable": true
                },
                {
                    "name": "engtype_3",
                    "type": "varchar(34)",
                    "nullable": true
                },
                {
                    "name": "validfr_3",
                    "type": "varchar(10)",
                    "nullable": true
                },
                {
                    "name": "gid_4",
                    "type": "varchar(18)",
                    "nullable": true
                },
                {
                    "name": "name_4",
                    "type": "varchar(98)",
                    "nullable": true
                },
                {
                    "name": "varname_4",
                    "type": "varchar(54)",
                    "nullable": true
                },
                {
                    "name": "cc_4",
                    "type": "varchar(12)",
                    "nullable": true
                },
                {
                    "name": "type_4",
                    "type": "varchar(29)",
                    "nullable": true
                },
                {
                    "name": "engtype_4",
                    "type": "varchar(29)",
                    "nullable": true
                },
                {
                    "name": "validfr_4",
                    "type": "varchar(7)",
                    "nullable": true
                },
                {
                    "name": "gid_5",
                    "type": "varchar(19)",
                    "nullable": true
                },
                {
                    "name": "name_5",
                    "type": "varchar(45)",
                    "nullable": true
                },
                {
                    "name": "cc_5",
                    "type": "varchar(15)",
                    "nullable": true
                },
                {
                    "name": "type_5",
                    "type": "varchar(22)",
                    "nullable": true
                },
                {
                    "name": "engtype_5",
                    "type": "varchar(255)",
                    "nullable": true
                },
                {
                    "name": "governedby",
                    "type": "varchar(17)",
                    "nullable": true
                },
                {
                    "name": "sovereign",
                    "type": "varchar(32)",
                    "nullable": true
                },
                {
                    "name": "disputedby",
                    "type": "varchar(57)",
                    "nullable": true
                },
                {
                    "name": "region",
                    "type": "varchar(36)",
                    "nullable": true
                },
                {
                    "name": "varregion",
                    "type": "varchar(56)",
                    "nullable": true
                },
                {
                    "name": "country",
                    "type": "varchar(60)",
                    "nullable": true
                },
                {
                    "name": "continent",
                    "type": "varchar(15)",
                    "nullable": true
                },
                {
                    "name": "subcont",
                    "type": "varchar(25)",
                    "nullable": true
                },
                {
                    "name": "shape_length",
                    "type": "double precision",
                    "nullable": true
                },
                {
                    "name": "shape_area",
                    "type": "double precision",
                    "nullable": true
                },
                {
                    "name": "shape",
                    "type": "geometry(MultiPolygon,4326)",
                    "nullable": true
                }
            ],
            "indexes": [
                {
                    "name": "gadm_pkey",
                    "def": "CREATE UNIQUE INDEX gadm_pkey ON ap.gadm USING btree (objectid)",
                    "table": "ap.gadm",
                    "columns": [
                        "objectid"
                    ]
                },
                {
                    "name": "gadm_shape_geom_idx",
                    "def": "CREATE INDEX gadm_shape_geom_idx ON ap.gadm USING gist (shape)",
                    "table": "ap.gadm",
                    "columns": [
                        "shape"
                    ]
                }
            ],
            "constraints": [
                {
                    "name": "gadm_pkey",
                    "type": "PRIMARY KEY",
                    "def": "PRIMARY KEY (objectid)",
                    "table": "ap.gadm",
                    "referenced_table": "",
                    "columns": [
                        "objectid"
                    ]
                }
            ]
        },
        {
            "name": "ap.hydrolakes",
            "type": "BASE TABLE",
            "columns": [
                {
                    "name": "objectid",
                    "type": "integer",
                    "nullable": false,
                    "default": "nextval('ap.hydrolakes_objectid_seq'::regclass)"
                },
                {
                    "name": "hylak_id",
                    "type": "integer",
                    "nullable": true
                },
                {
                    "name": "lake_name",
                    "type": "varchar(40)",
                    "nullable": true
                },
                {
                    "name": "country",
                    "type": "varchar(35)",
                    "nullable": true
                },
                {
                    "name": "continent",
                    "type": "varchar(15)",
                    "nullable": true
                },
                {
                    "name": "poly_src",
                    "type": "varchar(10)",
                    "nullable": true
                },
                {
                    "name": "lake_type",
                    "type": "smallint",
                    "nullable": true
                },
                {
                    "name": "grand_id",
                    "type": "smallint",
                    "nullable": true
                },
                {
                    "name": "lake_area",
                    "type": "real",
                    "nullable": true
                },
                {
                    "name": "shore_len",
                    "type": "real",
                    "nullable": true
                },
                {
                    "name": "shore_dev",
                    "type": "real",
                    "nullable": true
                },
                {
                    "name": "vol_total",
                    "type": "real",
                    "nullable": true
                },
                {
                    "name": "vol_res",
                    "type": "real",
                    "nullable": true
                },
                {
                    "name": "vol_src",
                    "type": "smallint",
                    "nullable": true
                },
                {
                    "name": "depth_avg",
                    "type": "real",
                    "nullable": true
                },
                {
                    "name": "dis_avg",
                    "type": "real",
                    "nullable": true
                },
                {
                    "name": "res_time",
                    "type": "real",
                    "nullable": true
                },
                {
                    "name": "elevation",
                    "type": "smallint",
                    "nullable": true
                },
                {
                    "name": "slope_100",
                    "type": "real",
                    "nullable": true
                },
                {
                    "name": "wshd_area",
                    "type": "real",
                    "nullable": true
                },
                {
                    "name": "pour_long",
                    "type": "double precision",
                    "nullable": true
                },
                {
                    "name": "pour_lat",
                    "type": "double precision",
                    "nullable": true
                },
                {
                    "name": "shape_length",
                    "type": "double precision",
                    "nullable": true
                },
                {
                    "name": "shape_area",
                    "type": "double precision",
                    "nullable": true
                },
                {
                    "name": "shape",
                    "type": "geometry(MultiPolygon,4326)",
                    "nullable": true
                }
            ],
            "indexes": [
                {
                    "name": "hydrolakes_pkey",
                    "def": "CREATE UNIQUE INDEX hydrolakes_pkey ON ap.hydrolakes USING btree (objectid)",
                    "table": "ap.hydrolakes",
                    "columns": [
                        "objectid"
                    ]
                },
                {
                    "name": "hydrolakes_shape_geom_idx",
                    "def": "CREATE INDEX hydrolakes_shape_geom_idx ON ap.hydrolakes USING gist (shape)",
                    "table": "ap.hydrolakes",
                    "columns": [
                        "shape"
                    ]
                },
                {
                    "name": "gist_lakes_2geog",
                    "def": "CREATE INDEX gist_lakes_2geog ON ap.hydrolakes USING gist (((shape)::geography))",
                    "table": "ap.hydrolakes",
                    "columns": [
                        "shape"
                    ]
                }
            ],
            "constraints": [
                {
                    "name": "hydrolakes_pkey",
                    "type": "PRIMARY KEY",
                    "def": "PRIMARY KEY (objectid)",
                    "table": "ap.hydrolakes",
                    "referenced_table": "",
                    "columns": [
                        "objectid"
                    ]
                }
            ]
        },
        {
            "name": "ap.globalmammals",
            "type": "BASE TABLE",
            "columns": [
                {
                    "name": "fid",
                    "type": "integer",
                    "nullable": false,
                    "default": "nextval('ap.globalmammals_fid_seq'::regclass)"
                },
                {
                    "name": "sciname",
                    "type": "varchar",
                    "nullable": true
                },
                {
                    "name": "order",
                    "type": "varchar",
                    "nullable": true
                },
                {
                    "name": "family",
                    "type": "varchar",
                    "nullable": true
                },
                {
                    "name": "author",
                    "type": "varchar",
                    "nullable": true
                },
                {
                    "name": "year",
                    "type": "double precision",
                    "nullable": true
                },
                {
                    "name": "citation",
                    "type": "varchar",
                    "nullable": true
                },
                {
                    "name": "rec_source",
                    "type": "varchar",
                    "nullable": true
                },
                {
                    "name": "geom",
                    "type": "geometry(MultiPolygon,4326)",
                    "nullable": true
                }
            ],
            "indexes": [
                {
                    "name": "globalmammals_pkey",
                    "def": "CREATE UNIQUE INDEX globalmammals_pkey ON ap.globalmammals USING btree (fid)",
                    "table": "ap.globalmammals",
                    "columns": [
                        "fid"
                    ]
                },
                {
                    "name": "globalmammals_geom_geom_idx",
                    "def": "CREATE INDEX globalmammals_geom_geom_idx ON ap.globalmammals USING gist (geom)",
                    "table": "ap.globalmammals",
                    "columns": [
                        "geom"
                    ]
                }
            ],
            "constraints": [
                {
                    "name": "globalmammals_pkey",
                    "type": "PRIMARY KEY",
                    "def": "PRIMARY KEY (fid)",
                    "table": "ap.globalmammals",
                    "referenced_table": "",
                    "columns": [
                        "fid"
                    ]
                }
            ]
        },
        {
            "name": "ndb.leadmodels",
            "type": "BASE TABLE",
            "columns": [
                {
                    "name": "pbbasisid",
                    "type": "integer",
                    "nullable": true
                },
                {
                    "name": "analysisunitid",
                    "type": "integer",
                    "nullable": true
                },
                {
                    "name": "cumulativeinventory",
                    "type": "numeric",
                    "nullable": true
                }
            ],
            "constraints": [
                {
                    "name": "leadmodels_cumulativeinventory_check",
                    "type": "CHECK",
                    "def": "CHECK ((cumulativeinventory > (0)::numeric))",
                    "table": "ndb.leadmodels",
                    "referenced_table": "",
                    "columns": [
                        "cumulativeinventory"
                    ]
                },
                {
                    "name": "leadmodels_analysisunitid_fkey",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (analysisunitid) REFERENCES ndb.analysisunits(analysisunitid)",
                    "table": "ndb.leadmodels",
                    "referenced_table": "analysisunits",
                    "columns": [
                        "analysisunitid"
                    ],
                    "referenced_columns": [
                        "analysisunitid"
                    ]
                },
                {
                    "name": "leadmodels_pbbasisid_fkey",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (pbbasisid) REFERENCES ndb.leadmodelbasis(pbbasisid)",
                    "table": "ndb.leadmodels",
                    "referenced_table": "leadmodelbasis",
                    "columns": [
                        "pbbasisid"
                    ],
                    "referenced_columns": [
                        "pbbasisid"
                    ]
                }
            ]
        },
        {
            "name": "ndb.speleothemtypes",
            "type": "BASE TABLE",
            "columns": [
                {
                    "name": "speleothemtypeid",
                    "type": "integer",
                    "nullable": false,
                    "default": "nextval('ndb.speleothemtypes_speleothemtypeid_seq'::regclass)"
                },
                {
                    "name": "speleothemtype",
                    "type": "varchar(50)",
                    "nullable": true
                },
                {
                    "name": "speleothemtypenotes",
                    "type": "text",
                    "nullable": true
                },
                {
                    "name": "speleothemtypepublicationid",
                    "type": "integer",
                    "nullable": true
                }
            ],
            "indexes": [
                {
                    "name": "speleothemtypes_pkey",
                    "def": "CREATE UNIQUE INDEX speleothemtypes_pkey ON ndb.speleothemtypes USING btree (speleothemtypeid)",
                    "table": "ndb.speleothemtypes",
                    "columns": [
                        "speleothemtypeid"
                    ]
                }
            ],
            "constraints": [
                {
                    "name": "speleothemtypes_speleothemtypepublicationid_fkey",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (speleothemtypepublicationid) REFERENCES ndb.publications(publicationid)",
                    "table": "ndb.speleothemtypes",
                    "referenced_table": "publications",
                    "columns": [
                        "speleothemtypepublicationid"
                    ],
                    "referenced_columns": [
                        "publicationid"
                    ]
                },
                {
                    "name": "speleothemtypes_pkey",
                    "type": "PRIMARY KEY",
                    "def": "PRIMARY KEY (speleothemtypeid)",
                    "table": "ndb.speleothemtypes",
                    "referenced_table": "",
                    "columns": [
                        "speleothemtypeid"
                    ]
                }
            ]
        },
        {
            "name": "ndb.speleothemdriptypes",
            "type": "BASE TABLE",
            "columns": [
                {
                    "name": "speleothemdriptypeid",
                    "type": "integer",
                    "nullable": false,
                    "default": "nextval('ndb.speleothemdriptypes_speleothemdriptypeid_seq'::regclass)"
                },
                {
                    "name": "speleothemdriptype",
                    "type": "varchar(50)",
                    "nullable": true
                },
                {
                    "name": "speleothemdriptypenotes",
                    "type": "text",
                    "nullable": true
                },
                {
                    "name": "speleothemdriptypepublicationid",
                    "type": "integer",
                    "nullable": true
                }
            ],
            "indexes": [
                {
                    "name": "speleothemdriptypes_pkey",
                    "def": "CREATE UNIQUE INDEX speleothemdriptypes_pkey ON ndb.speleothemdriptypes USING btree (speleothemdriptypeid)",
                    "table": "ndb.speleothemdriptypes",
                    "columns": [
                        "speleothemdriptypeid"
                    ]
                }
            ],
            "constraints": [
                {
                    "name": "speleothemdriptypes_speleothemdriptypepublicationid_fkey",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (speleothemdriptypepublicationid) REFERENCES ndb.publications(publicationid)",
                    "table": "ndb.speleothemdriptypes",
                    "referenced_table": "publications",
                    "columns": [
                        "speleothemdriptypepublicationid"
                    ],
                    "referenced_columns": [
                        "publicationid"
                    ]
                },
                {
                    "name": "speleothemdriptypes_pkey",
                    "type": "PRIMARY KEY",
                    "def": "PRIMARY KEY (speleothemdriptypeid)",
                    "table": "ndb.speleothemdriptypes",
                    "referenced_table": "",
                    "columns": [
                        "speleothemdriptypeid"
                    ]
                }
            ]
        },
        {
            "name": "ndb.vegetationcovertypes",
            "type": "BASE TABLE",
            "columns": [
                {
                    "name": "vegetationcovertypeid",
                    "type": "integer",
                    "nullable": false,
                    "default": "nextval('ndb.vegetationcovertypes_vegetationcovertypeid_seq'::regclass)"
                },
                {
                    "name": "vegetationcovertype",
                    "type": "varchar(128)",
                    "nullable": true
                },
                {
                    "name": "vegetationcovernotes",
                    "type": "text",
                    "nullable": true
                },
                {
                    "name": "vegetationpublicationid",
                    "type": "integer",
                    "nullable": true
                }
            ],
            "indexes": [
                {
                    "name": "vegetationcovertypes_pkey",
                    "def": "CREATE UNIQUE INDEX vegetationcovertypes_pkey ON ndb.vegetationcovertypes USING btree (vegetationcovertypeid)",
                    "table": "ndb.vegetationcovertypes",
                    "columns": [
                        "vegetationcovertypeid"
                    ]
                },
                {
                    "name": "vegetationcovertypes_vegetationcovertype_key",
                    "def": "CREATE UNIQUE INDEX vegetationcovertypes_vegetationcovertype_key ON ndb.vegetationcovertypes USING btree (vegetationcovertype)",
                    "table": "ndb.vegetationcovertypes",
                    "columns": [
                        "vegetationcovertype"
                    ]
                }
            ],
            "constraints": [
                {
                    "name": "vegetationcovertypes_vegetationpublicationid_fkey",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (vegetationpublicationid) REFERENCES ndb.publications(publicationid)",
                    "table": "ndb.vegetationcovertypes",
                    "referenced_table": "publications",
                    "columns": [
                        "vegetationpublicationid"
                    ],
                    "referenced_columns": [
                        "publicationid"
                    ]
                },
                {
                    "name": "vegetationcovertypes_pkey",
                    "type": "PRIMARY KEY",
                    "def": "PRIMARY KEY (vegetationcovertypeid)",
                    "table": "ndb.vegetationcovertypes",
                    "referenced_table": "",
                    "columns": [
                        "vegetationcovertypeid"
                    ]
                },
                {
                    "name": "vegetationcovertypes_vegetationcovertype_key",
                    "type": "UNIQUE",
                    "def": "UNIQUE (vegetationcovertype)",
                    "table": "ndb.vegetationcovertypes",
                    "referenced_table": "",
                    "columns": [
                        "vegetationcovertype"
                    ]
                }
            ]
        },
        {
            "name": "ndb.sitevegetationcover",
            "type": "BASE TABLE",
            "columns": [
                {
                    "name": "siteid",
                    "type": "integer",
                    "nullable": true
                },
                {
                    "name": "vegetationcovertypeid",
                    "type": "integer",
                    "nullable": true
                },
                {
                    "name": "vegetationcoverpercent",
                    "type": "integer",
                    "nullable": true
                },
                {
                    "name": "vegetationcovernotes",
                    "type": "text",
                    "nullable": true
                }
            ],
            "constraints": [
                {
                    "name": "sitevegetationcover_siteid_fkey",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (siteid) REFERENCES ndb.sites(siteid) ON DELETE CASCADE",
                    "table": "ndb.sitevegetationcover",
                    "referenced_table": "sites",
                    "columns": [
                        "siteid"
                    ],
                    "referenced_columns": [
                        "siteid"
                    ]
                },
                {
                    "name": "sitevegetationcover_vegetationcovertypeid_fkey",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (vegetationcovertypeid) REFERENCES ndb.vegetationcovertypes(vegetationcovertypeid) ON DELETE CASCADE",
                    "table": "ndb.sitevegetationcover",
                    "referenced_table": "vegetationcovertypes",
                    "columns": [
                        "vegetationcovertypeid"
                    ],
                    "referenced_columns": [
                        "vegetationcovertypeid"
                    ]
                }
            ]
        },
        {
            "name": "ndb.landusetypes",
            "type": "BASE TABLE",
            "columns": [
                {
                    "name": "landusecovertypeid",
                    "type": "integer",
                    "nullable": false,
                    "default": "nextval('ndb.landusetypes_landusecovertypeid_seq'::regclass)"
                },
                {
                    "name": "landusecovertype",
                    "type": "varchar(128)",
                    "nullable": true
                },
                {
                    "name": "landusecovernotes",
                    "type": "text",
                    "nullable": true
                },
                {
                    "name": "publicationid",
                    "type": "integer",
                    "nullable": true
                }
            ],
            "indexes": [
                {
                    "name": "landusetypes_pkey",
                    "def": "CREATE UNIQUE INDEX landusetypes_pkey ON ndb.landusetypes USING btree (landusecovertypeid)",
                    "table": "ndb.landusetypes",
                    "columns": [
                        "landusecovertypeid"
                    ]
                },
                {
                    "name": "landusetypes_landusecovertype_key",
                    "def": "CREATE UNIQUE INDEX landusetypes_landusecovertype_key ON ndb.landusetypes USING btree (landusecovertype)",
                    "table": "ndb.landusetypes",
                    "columns": [
                        "landusecovertype"
                    ]
                }
            ],
            "constraints": [
                {
                    "name": "landusetypes_landuseclasspublicationid_fkey",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (publicationid) REFERENCES ndb.publications(publicationid)",
                    "table": "ndb.landusetypes",
                    "referenced_table": "publications",
                    "columns": [
                        "publicationid"
                    ],
                    "referenced_columns": [
                        "publicationid"
                    ]
                },
                {
                    "name": "landusetypes_pkey",
                    "type": "PRIMARY KEY",
                    "def": "PRIMARY KEY (landusecovertypeid)",
                    "table": "ndb.landusetypes",
                    "referenced_table": "",
                    "columns": [
                        "landusecovertypeid"
                    ]
                },
                {
                    "name": "landusetypes_landusecovertype_key",
                    "type": "UNIQUE",
                    "def": "UNIQUE (landusecovertype)",
                    "table": "ndb.landusetypes",
                    "referenced_table": "",
                    "columns": [
                        "landusecovertype"
                    ]
                }
            ]
        },
        {
            "name": "ndb.sitelandusecover",
            "type": "BASE TABLE",
            "columns": [
                {
                    "name": "siteid",
                    "type": "integer",
                    "nullable": true
                },
                {
                    "name": "landusecovertypeid",
                    "type": "integer",
                    "nullable": true
                },
                {
                    "name": "landusecoverpercent",
                    "type": "integer",
                    "nullable": true
                },
                {
                    "name": "landusecovernotes",
                    "type": "text",
                    "nullable": true
                }
            ],
            "constraints": [
                {
                    "name": "sitelandusecover_siteid_fkey",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (siteid) REFERENCES ndb.sites(siteid) ON DELETE CASCADE",
                    "table": "ndb.sitelandusecover",
                    "referenced_table": "sites",
                    "columns": [
                        "siteid"
                    ],
                    "referenced_columns": [
                        "siteid"
                    ]
                },
                {
                    "name": "sitelandusecover_landusecovertypeid_fkey",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (landusecovertypeid) REFERENCES ndb.vegetationcovertypes(vegetationcovertypeid) ON DELETE CASCADE",
                    "table": "ndb.sitelandusecover",
                    "referenced_table": "vegetationcovertypes",
                    "columns": [
                        "landusecovertypeid"
                    ],
                    "referenced_columns": [
                        "vegetationcovertypeid"
                    ]
                }
            ]
        },
        {
            "name": "ndb.entitycovertypes",
            "type": "BASE TABLE",
            "columns": [
                {
                    "name": "entitycoverid",
                    "type": "integer",
                    "nullable": false,
                    "default": "nextval('ndb.entitycovertypes_entitycoverid_seq'::regclass)"
                },
                {
                    "name": "entitycovertype",
                    "type": "varchar(50)",
                    "nullable": true
                },
                {
                    "name": "entitycovernotes",
                    "type": "text",
                    "nullable": true
                }
            ],
            "indexes": [
                {
                    "name": "entitycovertypes_pkey",
                    "def": "CREATE UNIQUE INDEX entitycovertypes_pkey ON ndb.entitycovertypes USING btree (entitycoverid)",
                    "table": "ndb.entitycovertypes",
                    "columns": [
                        "entitycoverid"
                    ]
                }
            ],
            "constraints": [
                {
                    "name": "entitycovertypes_pkey",
                    "type": "PRIMARY KEY",
                    "def": "PRIMARY KEY (entitycoverid)",
                    "table": "ndb.entitycovertypes",
                    "referenced_table": "",
                    "columns": [
                        "entitycoverid"
                    ]
                }
            ]
        },
        {
            "name": "ndb.speleothementitystatuses",
            "type": "BASE TABLE",
            "columns": [
                {
                    "name": "entitystatusid",
                    "type": "integer",
                    "nullable": false,
                    "default": "nextval('ndb.speleothementitystatuses_entitystatusid_seq'::regclass)"
                },
                {
                    "name": "entitystatus",
                    "type": "text",
                    "nullable": true
                }
            ],
            "indexes": [
                {
                    "name": "speleothementitystatuses_pkey",
                    "def": "CREATE UNIQUE INDEX speleothementitystatuses_pkey ON ndb.speleothementitystatuses USING btree (entitystatusid)",
                    "table": "ndb.speleothementitystatuses",
                    "columns": [
                        "entitystatusid"
                    ]
                }
            ],
            "constraints": [
                {
                    "name": "speleothementitystatuses_pkey",
                    "type": "PRIMARY KEY",
                    "def": "PRIMARY KEY (entitystatusid)",
                    "table": "ndb.speleothementitystatuses",
                    "referenced_table": "",
                    "columns": [
                        "entitystatusid"
                    ]
                }
            ]
        },
        {
            "name": "ndb.depthreferencesystem",
            "type": "BASE TABLE",
            "columns": [
                {
                    "name": "depthreferencesystemid",
                    "type": "integer",
                    "nullable": false,
                    "default": "nextval('ndb.depthreferencesystem_depthreferencesystemid_seq'::regclass)"
                },
                {
                    "name": "depthreference",
                    "type": "text",
                    "nullable": true
                },
                {
                    "name": "depthreferencenotes",
                    "type": "text",
                    "nullable": true
                },
                {
                    "name": "depthreferencepublicationid",
                    "type": "integer",
                    "nullable": true
                }
            ],
            "indexes": [
                {
                    "name": "depthreferencesystem_pkey",
                    "def": "CREATE UNIQUE INDEX depthreferencesystem_pkey ON ndb.depthreferencesystem USING btree (depthreferencesystemid)",
                    "table": "ndb.depthreferencesystem",
                    "columns": [
                        "depthreferencesystemid"
                    ]
                }
            ],
            "constraints": [
                {
                    "name": "depthreferencesystem_depthreferencepublicationid_fkey",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (depthreferencepublicationid) REFERENCES ndb.publications(publicationid)",
                    "table": "ndb.depthreferencesystem",
                    "referenced_table": "publications",
                    "columns": [
                        "depthreferencepublicationid"
                    ],
                    "referenced_columns": [
                        "publicationid"
                    ]
                },
                {
                    "name": "depthreferencesystem_pkey",
                    "type": "PRIMARY KEY",
                    "def": "PRIMARY KEY (depthreferencesystemid)",
                    "table": "ndb.depthreferencesystem",
                    "referenced_table": "",
                    "columns": [
                        "depthreferencesystemid"
                    ]
                }
            ]
        },
        {
            "name": "ndb.speleothementitygeology",
            "type": "BASE TABLE",
            "columns": [
                {
                    "name": "speleothemgeologyid",
                    "type": "integer",
                    "nullable": false,
                    "default": "nextval('ndb.speleothementitygeology_speleothemgeologyid_seq'::regclass)"
                },
                {
                    "name": "speleothemgeology",
                    "type": "text",
                    "nullable": true
                },
                {
                    "name": "speleothemgeologynotes",
                    "type": "text",
                    "nullable": true
                },
                {
                    "name": "speleothemgeologypublicationid",
                    "type": "integer",
                    "nullable": true
                }
            ],
            "indexes": [
                {
                    "name": "speleothementitygeology_pkey",
                    "def": "CREATE UNIQUE INDEX speleothementitygeology_pkey ON ndb.speleothementitygeology USING btree (speleothemgeologyid)",
                    "table": "ndb.speleothementitygeology",
                    "columns": [
                        "speleothemgeologyid"
                    ]
                }
            ],
            "constraints": [
                {
                    "name": "speleothementitygeology_speleothemgeologypublicationid_fkey",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (speleothemgeologypublicationid) REFERENCES ndb.publications(publicationid)",
                    "table": "ndb.speleothementitygeology",
                    "referenced_table": "publications",
                    "columns": [
                        "speleothemgeologypublicationid"
                    ],
                    "referenced_columns": [
                        "publicationid"
                    ]
                },
                {
                    "name": "speleothementitygeology_pkey",
                    "type": "PRIMARY KEY",
                    "def": "PRIMARY KEY (speleothemgeologyid)",
                    "table": "ndb.speleothementitygeology",
                    "referenced_table": "",
                    "columns": [
                        "speleothemgeologyid"
                    ]
                }
            ]
        },
        {
            "name": "ndb.speleothems",
            "type": "BASE TABLE",
            "columns": [
                {
                    "name": "siteid",
                    "type": "integer",
                    "nullable": true
                },
                {
                    "name": "entityid",
                    "type": "integer",
                    "nullable": false,
                    "default": "nextval('ndb.speleothems_entityid_seq'::regclass)"
                },
                {
                    "name": "entityname",
                    "type": "text",
                    "nullable": true
                },
                {
                    "name": "monitoring",
                    "type": "boolean",
                    "nullable": true
                },
                {
                    "name": "rockageid",
                    "type": "integer",
                    "nullable": true
                },
                {
                    "name": "entrancedistance",
                    "type": "real",
                    "nullable": true
                },
                {
                    "name": "entrancedistanceunits",
                    "type": "integer",
                    "nullable": true
                },
                {
                    "name": "speleothemtypeid",
                    "type": "integer",
                    "nullable": true
                }
            ],
            "indexes": [
                {
                    "name": "speleothems_pkey",
                    "def": "CREATE UNIQUE INDEX speleothems_pkey ON ndb.speleothems USING btree (entityid)",
                    "table": "ndb.speleothems",
                    "columns": [
                        "entityid"
                    ]
                }
            ],
            "constraints": [
                {
                    "name": "speleothems_rockageid_fkey",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (rockageid) REFERENCES ndb.relativeages(relativeageid)",
                    "table": "ndb.speleothems",
                    "referenced_table": "relativeages",
                    "columns": [
                        "rockageid"
                    ],
                    "referenced_columns": [
                        "relativeageid"
                    ]
                },
                {
                    "name": "speleothems_siteid_fkey",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (siteid) REFERENCES ndb.sites(siteid) ON DELETE CASCADE",
                    "table": "ndb.speleothems",
                    "referenced_table": "sites",
                    "columns": [
                        "siteid"
                    ],
                    "referenced_columns": [
                        "siteid"
                    ]
                },
                {
                    "name": "speleothems_entrancedistanceunits_fkey",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (entrancedistanceunits) REFERENCES ndb.variableunits(variableunitsid)",
                    "table": "ndb.speleothems",
                    "referenced_table": "variableunits",
                    "columns": [
                        "entrancedistanceunits"
                    ],
                    "referenced_columns": [
                        "variableunitsid"
                    ]
                },
                {
                    "name": "speleothems_speleothemtypeid_fkey",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (speleothemtypeid) REFERENCES ndb.speleothemtypes(speleothemtypeid)",
                    "table": "ndb.speleothems",
                    "referenced_table": "speleothemtypes",
                    "columns": [
                        "speleothemtypeid"
                    ],
                    "referenced_columns": [
                        "speleothemtypeid"
                    ]
                },
                {
                    "name": "speleothems_pkey",
                    "type": "PRIMARY KEY",
                    "def": "PRIMARY KEY (entityid)",
                    "table": "ndb.speleothems",
                    "referenced_table": "",
                    "columns": [
                        "entityid"
                    ]
                }
            ]
        },
        {
            "name": "ndb.entityrelationship",
            "type": "BASE TABLE",
            "columns": [
                {
                    "name": "entityid",
                    "type": "integer",
                    "nullable": true
                },
                {
                    "name": "entitystatusid",
                    "type": "integer",
                    "nullable": true
                },
                {
                    "name": "referenceentityid",
                    "type": "integer",
                    "nullable": true
                }
            ],
            "constraints": [
                {
                    "name": "entityrelationship_entitystatusid_fkey",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (entitystatusid) REFERENCES ndb.speleothementitystatuses(entitystatusid)",
                    "table": "ndb.entityrelationship",
                    "referenced_table": "speleothementitystatuses",
                    "columns": [
                        "entitystatusid"
                    ],
                    "referenced_columns": [
                        "entitystatusid"
                    ]
                },
                {
                    "name": "entityrelationship_entityid_fkey",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (entityid) REFERENCES ndb.speleothems(entityid)",
                    "table": "ndb.entityrelationship",
                    "referenced_table": "speleothems",
                    "columns": [
                        "entityid"
                    ],
                    "referenced_columns": [
                        "entityid"
                    ]
                },
                {
                    "name": "entityrelationship_referenceentityid_fkey",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (referenceentityid) REFERENCES ndb.speleothems(entityid)",
                    "table": "ndb.entityrelationship",
                    "referenced_table": "speleothems",
                    "columns": [
                        "referenceentityid"
                    ],
                    "referenced_columns": [
                        "entityid"
                    ]
                }
            ]
        },
        {
            "name": "ndb.entitydripheight",
            "type": "BASE TABLE",
            "columns": [
                {
                    "name": "entityid",
                    "type": "integer",
                    "nullable": true
                },
                {
                    "name": "speleothemdriptypeid",
                    "type": "integer",
                    "nullable": true
                },
                {
                    "name": "entitydripheight",
                    "type": "real",
                    "nullable": true
                },
                {
                    "name": "entitydripheightunit",
                    "type": "integer",
                    "nullable": true
                }
            ],
            "constraints": [
                {
                    "name": "entitydripheight_entitydripheightunit_fkey",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (entitydripheightunit) REFERENCES ndb.variableunits(variableunitsid)",
                    "table": "ndb.entitydripheight",
                    "referenced_table": "variableunits",
                    "columns": [
                        "entitydripheightunit"
                    ],
                    "referenced_columns": [
                        "variableunitsid"
                    ]
                },
                {
                    "name": "entitydripheight_speleothemdriptypeid_fkey",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (speleothemdriptypeid) REFERENCES ndb.speleothemdriptypes(speleothemdriptypeid)",
                    "table": "ndb.entitydripheight",
                    "referenced_table": "speleothemdriptypes",
                    "columns": [
                        "speleothemdriptypeid"
                    ],
                    "referenced_columns": [
                        "speleothemdriptypeid"
                    ]
                },
                {
                    "name": "entitydripheight_entityid_fkey",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (entityid) REFERENCES ndb.speleothems(entityid) ON DELETE CASCADE",
                    "table": "ndb.entitydripheight",
                    "referenced_table": "speleothems",
                    "columns": [
                        "entityid"
                    ],
                    "referenced_columns": [
                        "entityid"
                    ]
                }
            ]
        },
        {
            "name": "ndb.entityvegetationcover",
            "type": "BASE TABLE",
            "columns": [
                {
                    "name": "entityid",
                    "type": "integer",
                    "nullable": true
                },
                {
                    "name": "vegetationcovertypeid",
                    "type": "integer",
                    "nullable": true
                },
                {
                    "name": "vegetationcoverpercent",
                    "type": "integer",
                    "nullable": true
                },
                {
                    "name": "vegetationcovernotes",
                    "type": "text",
                    "nullable": true
                }
            ],
            "constraints": [
                {
                    "name": "entityvegetationcover_vegetationcovertypeid_fkey",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (vegetationcovertypeid) REFERENCES ndb.vegetationcovertypes(vegetationcovertypeid) ON DELETE CASCADE",
                    "table": "ndb.entityvegetationcover",
                    "referenced_table": "vegetationcovertypes",
                    "columns": [
                        "vegetationcovertypeid"
                    ],
                    "referenced_columns": [
                        "vegetationcovertypeid"
                    ]
                },
                {
                    "name": "entityvegetationcover_entityid_fkey",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (entityid) REFERENCES ndb.speleothems(entityid) ON DELETE CASCADE",
                    "table": "ndb.entityvegetationcover",
                    "referenced_table": "speleothems",
                    "columns": [
                        "entityid"
                    ],
                    "referenced_columns": [
                        "entityid"
                    ]
                }
            ]
        },
        {
            "name": "ndb.entitylandusecover",
            "type": "BASE TABLE",
            "columns": [
                {
                    "name": "entityid",
                    "type": "integer",
                    "nullable": true
                },
                {
                    "name": "landusecovertypeid",
                    "type": "integer",
                    "nullable": true
                },
                {
                    "name": "landusecoverpercent",
                    "type": "integer",
                    "nullable": true
                },
                {
                    "name": "landusecovernotes",
                    "type": "text",
                    "nullable": true
                }
            ],
            "constraints": [
                {
                    "name": "entitylandusecover_landusecovertypeid_fkey",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (landusecovertypeid) REFERENCES ndb.vegetationcovertypes(vegetationcovertypeid) ON DELETE CASCADE",
                    "table": "ndb.entitylandusecover",
                    "referenced_table": "vegetationcovertypes",
                    "columns": [
                        "landusecovertypeid"
                    ],
                    "referenced_columns": [
                        "vegetationcovertypeid"
                    ]
                },
                {
                    "name": "entitylandusecover_entityid_fkey",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (entityid) REFERENCES ndb.speleothems(entityid) ON DELETE CASCADE",
                    "table": "ndb.entitylandusecover",
                    "referenced_table": "speleothems",
                    "columns": [
                        "entityid"
                    ],
                    "referenced_columns": [
                        "entityid"
                    ]
                }
            ]
        },
        {
            "name": "ndb.entitycovers",
            "type": "BASE TABLE",
            "columns": [
                {
                    "name": "entityid",
                    "type": "integer",
                    "nullable": true
                },
                {
                    "name": "entitycoverid",
                    "type": "integer",
                    "nullable": true
                },
                {
                    "name": "entitycoverthickness",
                    "type": "real",
                    "nullable": true
                },
                {
                    "name": "entitycoverunits",
                    "type": "integer",
                    "nullable": true
                }
            ],
            "constraints": [
                {
                    "name": "entitycovers_entitycoverunits_fkey",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (entitycoverunits) REFERENCES ndb.variableunits(variableunitsid)",
                    "table": "ndb.entitycovers",
                    "referenced_table": "variableunits",
                    "columns": [
                        "entitycoverunits"
                    ],
                    "referenced_columns": [
                        "variableunitsid"
                    ]
                },
                {
                    "name": "entitycovers_entitycoverid_fkey",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (entitycoverid) REFERENCES ndb.entitycovertypes(entitycoverid)",
                    "table": "ndb.entitycovers",
                    "referenced_table": "entitycovertypes",
                    "columns": [
                        "entitycoverid"
                    ],
                    "referenced_columns": [
                        "entitycoverid"
                    ]
                },
                {
                    "name": "entitycovers_entityid_fkey",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (entityid) REFERENCES ndb.speleothems(entityid) ON DELETE CASCADE",
                    "table": "ndb.entitycovers",
                    "referenced_table": "speleothems",
                    "columns": [
                        "entityid"
                    ],
                    "referenced_columns": [
                        "entityid"
                    ]
                }
            ]
        },
        {
            "name": "ndb.externalspeleothemdata",
            "type": "BASE TABLE",
            "columns": [
                {
                    "name": "entityid",
                    "type": "integer",
                    "nullable": true
                },
                {
                    "name": "externalid",
                    "type": "text",
                    "nullable": true
                },
                {
                    "name": "extdatabaseid",
                    "type": "integer",
                    "nullable": true
                },
                {
                    "name": "externaldescription",
                    "type": "text",
                    "nullable": true
                }
            ],
            "constraints": [
                {
                    "name": "externalspeleothemdata_extdatabaseid_fkey",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (extdatabaseid) REFERENCES ndb.externaldatabases(extdatabaseid)",
                    "table": "ndb.externalspeleothemdata",
                    "referenced_table": "externaldatabases",
                    "columns": [
                        "extdatabaseid"
                    ],
                    "referenced_columns": [
                        "extdatabaseid"
                    ]
                },
                {
                    "name": "externalspeleothemdata_entityid_fkey",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (entityid) REFERENCES ndb.speleothems(entityid) ON DELETE CASCADE",
                    "table": "ndb.externalspeleothemdata",
                    "referenced_table": "speleothems",
                    "columns": [
                        "entityid"
                    ],
                    "referenced_columns": [
                        "entityid"
                    ]
                }
            ]
        },
        {
            "name": "ndb.externalcontacts",
            "type": "BASE TABLE",
            "columns": [
                {
                    "name": "contactid",
                    "type": "integer",
                    "nullable": true
                },
                {
                    "name": "identifier",
                    "type": "text",
                    "nullable": true
                },
                {
                    "name": "extdatabaseid",
                    "type": "integer",
                    "nullable": true
                }
            ],
            "indexes": [
                {
                    "name": "externalcontacts_contactid_identifier_extdatabaseid_key",
                    "def": "CREATE UNIQUE INDEX externalcontacts_contactid_identifier_extdatabaseid_key ON ndb.externalcontacts USING btree (contactid, identifier, extdatabaseid)",
                    "table": "ndb.externalcontacts",
                    "columns": [
                        "contactid",
                        "identifier",
                        "extdatabaseid"
                    ]
                }
            ],
            "constraints": [
                {
                    "name": "externalcontacts_contactid_fkey",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (contactid) REFERENCES ndb.contacts(contactid)",
                    "table": "ndb.externalcontacts",
                    "referenced_table": "contacts",
                    "columns": [
                        "contactid"
                    ],
                    "referenced_columns": [
                        "contactid"
                    ]
                },
                {
                    "name": "externalcontacts_extdatabaseid_fkey",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (extdatabaseid) REFERENCES ndb.externaldatabases(extdatabaseid)",
                    "table": "ndb.externalcontacts",
                    "referenced_table": "externaldatabases",
                    "columns": [
                        "extdatabaseid"
                    ],
                    "referenced_columns": [
                        "extdatabaseid"
                    ]
                },
                {
                    "name": "externalcontacts_contactid_identifier_extdatabaseid_key",
                    "type": "UNIQUE",
                    "def": "UNIQUE (contactid, identifier, extdatabaseid)",
                    "table": "ndb.externalcontacts",
                    "referenced_table": "",
                    "columns": [
                        "contactid",
                        "identifier",
                        "extdatabaseid"
                    ]
                }
            ]
        },
        {
            "name": "ndb.speleothemcollectionunit",
            "type": "BASE TABLE",
            "columns": [
                {
                    "name": "entityid",
                    "type": "integer",
                    "nullable": true
                },
                {
                    "name": "collectionunitid",
                    "type": "integer",
                    "nullable": true
                }
            ],
            "constraints": [
                {
                    "name": "speleothemcollectionunit_collectionunitid_fkey",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (collectionunitid) REFERENCES ndb.collectionunits(collectionunitid) ON DELETE CASCADE",
                    "table": "ndb.speleothemcollectionunit",
                    "referenced_table": "collectionunits",
                    "columns": [
                        "collectionunitid"
                    ],
                    "referenced_columns": [
                        "collectionunitid"
                    ]
                },
                {
                    "name": "speleothemcollectionunit_entityid_fkey",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (entityid) REFERENCES ndb.speleothems(entityid) ON DELETE CASCADE",
                    "table": "ndb.speleothemcollectionunit",
                    "referenced_table": "speleothems",
                    "columns": [
                        "entityid"
                    ],
                    "referenced_columns": [
                        "entityid"
                    ]
                }
            ]
        },
        {
            "name": "ndb.entitygeology",
            "type": "BASE TABLE",
            "columns": [
                {
                    "name": "entityid",
                    "type": "integer",
                    "nullable": true
                },
                {
                    "name": "speleothemgeologyid",
                    "type": "integer",
                    "nullable": true
                },
                {
                    "name": "notes",
                    "type": "text",
                    "nullable": true
                }
            ],
            "constraints": [
                {
                    "name": "entitygeology_speleothemgeologyid_fkey",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (speleothemgeologyid) REFERENCES ndb.speleothementitygeology(speleothemgeologyid)",
                    "table": "ndb.entitygeology",
                    "referenced_table": "speleothementitygeology",
                    "columns": [
                        "speleothemgeologyid"
                    ],
                    "referenced_columns": [
                        "speleothemgeologyid"
                    ]
                },
                {
                    "name": "entitygeology_entityid_fkey",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (entityid) REFERENCES ndb.speleothems(entityid) ON DELETE CASCADE",
                    "table": "ndb.entitygeology",
                    "referenced_table": "speleothems",
                    "columns": [
                        "entityid"
                    ],
                    "referenced_columns": [
                        "entityid"
                    ]
                }
            ]
        },
        {
            "name": "ndb.hiatuses",
            "type": "BASE TABLE",
            "columns": [
                {
                    "name": "hiatusid",
                    "type": "integer",
                    "nullable": false,
                    "default": "nextval('ndb.hiatuses_hiatusid_seq'::regclass)"
                },
                {
                    "name": "analysisunitstart",
                    "type": "integer",
                    "nullable": true
                },
                {
                    "name": "analysisunitend",
                    "type": "integer",
                    "nullable": true
                },
                {
                    "name": "notes",
                    "type": "text",
                    "nullable": true
                }
            ],
            "indexes": [
                {
                    "name": "hiatuses_pkey",
                    "def": "CREATE UNIQUE INDEX hiatuses_pkey ON ndb.hiatuses USING btree (hiatusid)",
                    "table": "ndb.hiatuses",
                    "columns": [
                        "hiatusid"
                    ]
                },
                {
                    "name": "hiatuses_hiatusid_analysisunitstart_analysisunitend_key",
                    "def": "CREATE UNIQUE INDEX hiatuses_hiatusid_analysisunitstart_analysisunitend_key ON ndb.hiatuses USING btree (hiatusid, analysisunitstart, analysisunitend)",
                    "table": "ndb.hiatuses",
                    "columns": [
                        "hiatusid",
                        "analysisunitstart",
                        "analysisunitend"
                    ]
                }
            ],
            "constraints": [
                {
                    "name": "hiatuses_analysisunitend_fkey",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (analysisunitend) REFERENCES ndb.analysisunits(analysisunitid)",
                    "table": "ndb.hiatuses",
                    "referenced_table": "analysisunits",
                    "columns": [
                        "analysisunitend"
                    ],
                    "referenced_columns": [
                        "analysisunitid"
                    ]
                },
                {
                    "name": "hiatuses_analysisunitstart_fkey",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (analysisunitstart) REFERENCES ndb.analysisunits(analysisunitid)",
                    "table": "ndb.hiatuses",
                    "referenced_table": "analysisunits",
                    "columns": [
                        "analysisunitstart"
                    ],
                    "referenced_columns": [
                        "analysisunitid"
                    ]
                },
                {
                    "name": "hiatuses_pkey",
                    "type": "PRIMARY KEY",
                    "def": "PRIMARY KEY (hiatusid)",
                    "table": "ndb.hiatuses",
                    "referenced_table": "",
                    "columns": [
                        "hiatusid"
                    ]
                },
                {
                    "name": "hiatuses_hiatusid_analysisunitstart_analysisunitend_key",
                    "type": "UNIQUE",
                    "def": "UNIQUE (hiatusid, analysisunitstart, analysisunitend)",
                    "table": "ndb.hiatuses",
                    "referenced_table": "",
                    "columns": [
                        "hiatusid",
                        "analysisunitstart",
                        "analysisunitend"
                    ]
                }
            ]
        },
        {
            "name": "ndb.hiatuschronology",
            "type": "BASE TABLE",
            "columns": [
                {
                    "name": "hiatusid",
                    "type": "integer",
                    "nullable": true
                },
                {
                    "name": "chronologyid",
                    "type": "integer",
                    "nullable": true
                },
                {
                    "name": "hiatuslength",
                    "type": "integer",
                    "nullable": true
                },
                {
                    "name": "hiatusuncertainty",
                    "type": "integer",
                    "nullable": true
                }
            ],
            "indexes": [
                {
                    "name": "hiatuschronology_hiatusid_chronologyid_key",
                    "def": "CREATE UNIQUE INDEX hiatuschronology_hiatusid_chronologyid_key ON ndb.hiatuschronology USING btree (hiatusid, chronologyid)",
                    "table": "ndb.hiatuschronology",
                    "columns": [
                        "hiatusid",
                        "chronologyid"
                    ]
                }
            ],
            "constraints": [
                {
                    "name": "hiatuschronology_hiatuslength_check",
                    "type": "CHECK",
                    "def": "CHECK ((hiatuslength >= 0))",
                    "table": "ndb.hiatuschronology",
                    "referenced_table": "",
                    "columns": [
                        "hiatuslength"
                    ]
                },
                {
                    "name": "hiatuschronology_chronologyid_fkey",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (chronologyid) REFERENCES ndb.chronologies(chronologyid)",
                    "table": "ndb.hiatuschronology",
                    "referenced_table": "chronologies",
                    "columns": [
                        "chronologyid"
                    ],
                    "referenced_columns": [
                        "chronologyid"
                    ]
                },
                {
                    "name": "hiatuschronology_hiatusid_fkey",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (hiatusid) REFERENCES ndb.hiatuses(hiatusid)",
                    "table": "ndb.hiatuschronology",
                    "referenced_table": "hiatuses",
                    "columns": [
                        "hiatusid"
                    ],
                    "referenced_columns": [
                        "hiatusid"
                    ]
                },
                {
                    "name": "hiatuschronology_hiatusid_chronologyid_key",
                    "type": "UNIQUE",
                    "def": "UNIQUE (hiatusid, chronologyid)",
                    "table": "ndb.hiatuschronology",
                    "referenced_table": "",
                    "columns": [
                        "hiatusid",
                        "chronologyid"
                    ]
                }
            ]
        },
        {
            "name": "ndb.externalgeochronology",
            "type": "BASE TABLE",
            "columns": [
                {
                    "name": "geochronid",
                    "type": "integer",
                    "nullable": true
                },
                {
                    "name": "extdatabaseid",
                    "type": "integer",
                    "nullable": true
                },
                {
                    "name": "identifier",
                    "type": "text",
                    "nullable": true
                }
            ],
            "indexes": [
                {
                    "name": "uniqueid",
                    "def": "CREATE UNIQUE INDEX uniqueid ON ndb.externalgeochronology USING btree (geochronid, extdatabaseid, identifier)",
                    "table": "ndb.externalgeochronology",
                    "columns": [
                        "geochronid",
                        "extdatabaseid",
                        "identifier"
                    ]
                }
            ],
            "constraints": [
                {
                    "name": "externalgeochronology_extdatabaseid_fkey",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (extdatabaseid) REFERENCES ndb.externaldatabases(extdatabaseid)",
                    "table": "ndb.externalgeochronology",
                    "referenced_table": "externaldatabases",
                    "columns": [
                        "extdatabaseid"
                    ],
                    "referenced_columns": [
                        "extdatabaseid"
                    ]
                },
                {
                    "name": "externalgeochronology_geochronid_fkey",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (geochronid) REFERENCES ndb.geochronology(geochronid)",
                    "table": "ndb.externalgeochronology",
                    "referenced_table": "geochronology",
                    "columns": [
                        "geochronid"
                    ],
                    "referenced_columns": [
                        "geochronid"
                    ]
                },
                {
                    "name": "uniqueid",
                    "type": "UNIQUE",
                    "def": "UNIQUE (geochronid, extdatabaseid, identifier)",
                    "table": "ndb.externalgeochronology",
                    "referenced_table": "",
                    "columns": [
                        "geochronid",
                        "extdatabaseid",
                        "identifier"
                    ]
                }
            ]
        },
        {
            "name": "ndb.decayconstants",
            "type": "BASE TABLE",
            "columns": [
                {
                    "name": "decayconstantid",
                    "type": "integer",
                    "nullable": false,
                    "default": "nextval('ndb.decayconstants_decayconstantid_seq'::regclass)"
                },
                {
                    "name": "decayconstant",
                    "type": "text",
                    "nullable": true
                },
                {
                    "name": "publicationid",
                    "type": "integer",
                    "nullable": true
                },
                {
                    "name": "notes",
                    "type": "text",
                    "nullable": true
                }
            ],
            "indexes": [
                {
                    "name": "decayconstants_pkey",
                    "def": "CREATE UNIQUE INDEX decayconstants_pkey ON ndb.decayconstants USING btree (decayconstantid)",
                    "table": "ndb.decayconstants",
                    "columns": [
                        "decayconstantid"
                    ]
                }
            ],
            "constraints": [
                {
                    "name": "decayconstants_publicationid_fkey",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (publicationid) REFERENCES ndb.publications(publicationid)",
                    "table": "ndb.decayconstants",
                    "referenced_table": "publications",
                    "columns": [
                        "publicationid"
                    ],
                    "referenced_columns": [
                        "publicationid"
                    ]
                },
                {
                    "name": "decayconstants_pkey",
                    "type": "PRIMARY KEY",
                    "def": "PRIMARY KEY (decayconstantid)",
                    "table": "ndb.decayconstants",
                    "referenced_table": "",
                    "columns": [
                        "decayconstantid"
                    ]
                }
            ]
        },
        {
            "name": "ndb.uraniumseries",
            "type": "BASE TABLE",
            "columns": [
                {
                    "name": "geochronid",
                    "type": "integer",
                    "nullable": true
                },
                {
                    "name": "decayconstantid",
                    "type": "integer",
                    "nullable": true
                },
                {
                    "name": "ratio230th232th",
                    "type": "numeric",
                    "nullable": true
                },
                {
                    "name": "ratiouncertainty230th232th",
                    "type": "numeric",
                    "nullable": true
                },
                {
                    "name": "activity230th238u",
                    "type": "numeric",
                    "nullable": true
                },
                {
                    "name": "activityuncertainty230th238u",
                    "type": "numeric",
                    "nullable": true
                },
                {
                    "name": "activity234u238u",
                    "type": "numeric",
                    "nullable": true
                },
                {
                    "name": "activityuncertainty234u238u",
                    "type": "numeric",
                    "nullable": true
                },
                {
                    "name": "iniratio230th232th",
                    "type": "numeric",
                    "nullable": true
                },
                {
                    "name": "iniratiouncertainty230th232th",
                    "type": "numeric",
                    "nullable": true
                }
            ],
            "constraints": [
                {
                    "name": "uraniumseries_geochronid_fkey",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (geochronid) REFERENCES ndb.geochronology(geochronid)",
                    "table": "ndb.uraniumseries",
                    "referenced_table": "geochronology",
                    "columns": [
                        "geochronid"
                    ],
                    "referenced_columns": [
                        "geochronid"
                    ]
                },
                {
                    "name": "uraniumseries_decayconstantid_fkey",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (decayconstantid) REFERENCES ndb.decayconstants(decayconstantid)",
                    "table": "ndb.uraniumseries",
                    "referenced_table": "decayconstants",
                    "columns": [
                        "decayconstantid"
                    ],
                    "referenced_columns": [
                        "decayconstantid"
                    ]
                }
            ]
        },
        {
            "name": "ndb.uraniumseriesdata",
            "type": "BASE TABLE",
            "columns": [
                {
                    "name": "geochronid",
                    "type": "integer",
                    "nullable": true
                },
                {
                    "name": "dataid",
                    "type": "integer",
                    "nullable": true
                }
            ],
            "constraints": [
                {
                    "name": "uraniumseriesdata_dataid_fkey",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (dataid) REFERENCES ndb.data(dataid)",
                    "table": "ndb.uraniumseriesdata",
                    "referenced_table": "data",
                    "columns": [
                        "dataid"
                    ],
                    "referenced_columns": [
                        "dataid"
                    ]
                },
                {
                    "name": "uraniumseriesdata_geochronid_fkey",
                    "type": "FOREIGN KEY",
                    "def": "FOREIGN KEY (geochronid) REFERENCES ndb.geochronology(geochronid)",
                    "table": "ndb.uraniumseriesdata",
                    "referenced_table": "geochronology",
                    "columns": [
                        "geochronid"
                    ],
                    "referenced_columns": [
                        "geochronid"
                    ]
                }
            ]
        }
    ],
    "relations": [
        {
            "table": "ndb.publications",
            "columns": [
                "pubtypeid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.publicationtypes",
            "parent_columns": [
                "pubtypeid"
            ],
            "parent_cardinality": "zero_or_one",
            "def": "FOREIGN KEY (pubtypeid) REFERENCES ndb.publicationtypes(pubtypeid)"
        },
        {
            "table": "ndb.unitsdatasettypes",
            "columns": [
                "datasettypeid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.datasettypes",
            "parent_columns": [
                "datasettypeid"
            ],
            "parent_cardinality": "exactly_one",
            "def": "FOREIGN KEY (datasettypeid) REFERENCES ndb.datasettypes(datasettypeid) ON UPDATE CASCADE ON DELETE CASCADE"
        },
        {
            "table": "ndb.unitsdatasettypes",
            "columns": [
                "variableunitsid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.variableunits",
            "parent_columns": [
                "variableunitsid"
            ],
            "parent_cardinality": "exactly_one",
            "def": "FOREIGN KEY (variableunitsid) REFERENCES ndb.variableunits(variableunitsid) ON UPDATE CASCADE ON DELETE CASCADE"
        },
        {
            "table": "ndb.variables",
            "columns": [
                "taxonid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.taxa",
            "parent_columns": [
                "taxonid"
            ],
            "parent_cardinality": "exactly_one",
            "def": "FOREIGN KEY (taxonid) REFERENCES ndb.taxa(taxonid) ON UPDATE CASCADE ON DELETE CASCADE"
        },
        {
            "table": "ndb.variables",
            "columns": [
                "variablecontextid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.variablecontexts",
            "parent_columns": [
                "variablecontextid"
            ],
            "parent_cardinality": "zero_or_one",
            "def": "FOREIGN KEY (variablecontextid) REFERENCES ndb.variablecontexts(variablecontextid) ON UPDATE CASCADE ON DELETE CASCADE"
        },
        {
            "table": "ndb.variables",
            "columns": [
                "variableelementid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.variableelements",
            "parent_columns": [
                "variableelementid"
            ],
            "parent_cardinality": "zero_or_one",
            "def": "FOREIGN KEY (variableelementid) REFERENCES ndb.variableelements(variableelementid) ON UPDATE CASCADE ON DELETE CASCADE"
        },
        {
            "table": "ndb.variables",
            "columns": [
                "variableunitsid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.variableunits",
            "parent_columns": [
                "variableunitsid"
            ],
            "parent_cardinality": "zero_or_one",
            "def": "FOREIGN KEY (variableunitsid) REFERENCES ndb.variableunits(variableunitsid) ON UPDATE CASCADE ON DELETE CASCADE"
        },
        {
            "table": "ndb.samplekeywords",
            "columns": [
                "keywordid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.keywords",
            "parent_columns": [
                "keywordid"
            ],
            "parent_cardinality": "exactly_one",
            "def": "FOREIGN KEY (keywordid) REFERENCES ndb.keywords(keywordid)"
        },
        {
            "table": "ndb.samplekeywords",
            "columns": [
                "sampleid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.samples",
            "parent_columns": [
                "sampleid"
            ],
            "parent_cardinality": "exactly_one",
            "def": "FOREIGN KEY (sampleid) REFERENCES ndb.samples(sampleid) ON UPDATE CASCADE ON DELETE CASCADE"
        },
        {
            "table": "ndb.samples",
            "columns": [
                "analysisunitid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.analysisunits",
            "parent_columns": [
                "analysisunitid"
            ],
            "parent_cardinality": "exactly_one",
            "def": "FOREIGN KEY (analysisunitid) REFERENCES ndb.analysisunits(analysisunitid) ON UPDATE CASCADE ON DELETE CASCADE"
        },
        {
            "table": "ndb.samples",
            "columns": [
                "datasetid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.datasets",
            "parent_columns": [
                "datasetid"
            ],
            "parent_cardinality": "exactly_one",
            "def": "FOREIGN KEY (datasetid) REFERENCES ndb.datasets(datasetid) ON UPDATE CASCADE ON DELETE CASCADE"
        },
        {
            "table": "ndb.samples",
            "columns": [
                "taxonid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.taxa",
            "parent_columns": [
                "taxonid"
            ],
            "parent_cardinality": "zero_or_one",
            "def": "FOREIGN KEY (taxonid) REFERENCES ndb.taxa(taxonid)"
        },
        {
            "table": "ndb.datasetpis",
            "columns": [
                "contactid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.contacts",
            "parent_columns": [
                "contactid"
            ],
            "parent_cardinality": "exactly_one",
            "def": "FOREIGN KEY (contactid) REFERENCES ndb.contacts(contactid) ON UPDATE CASCADE"
        },
        {
            "table": "ndb.datasetpis",
            "columns": [
                "datasetid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.datasets",
            "parent_columns": [
                "datasetid"
            ],
            "parent_cardinality": "exactly_one",
            "def": "FOREIGN KEY (datasetid) REFERENCES ndb.datasets(datasetid) ON UPDATE CASCADE ON DELETE CASCADE"
        },
        {
            "table": "ndb.datasetpublications",
            "columns": [
                "datasetid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.datasets",
            "parent_columns": [
                "datasetid"
            ],
            "parent_cardinality": "exactly_one",
            "def": "FOREIGN KEY (datasetid) REFERENCES ndb.datasets(datasetid) ON UPDATE CASCADE ON DELETE CASCADE"
        },
        {
            "table": "ndb.datasetpublications",
            "columns": [
                "publicationid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.publications",
            "parent_columns": [
                "publicationid"
            ],
            "parent_cardinality": "exactly_one",
            "def": "FOREIGN KEY (publicationid) REFERENCES ndb.publications(publicationid)"
        },
        {
            "table": "ndb.publicationauthors",
            "columns": [
                "contactid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.contacts",
            "parent_columns": [
                "contactid"
            ],
            "parent_cardinality": "zero_or_one",
            "def": "FOREIGN KEY (contactid) REFERENCES ndb.contacts(contactid) ON UPDATE CASCADE"
        },
        {
            "table": "ndb.publicationauthors",
            "columns": [
                "publicationid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.publications",
            "parent_columns": [
                "publicationid"
            ],
            "parent_cardinality": "exactly_one",
            "def": "FOREIGN KEY (publicationid) REFERENCES ndb.publications(publicationid) ON UPDATE CASCADE ON DELETE CASCADE"
        },
        {
            "table": "ndb.datasettaxagrouptypes",
            "columns": [
                "datasettypeid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.datasettypes",
            "parent_columns": [
                "datasettypeid"
            ],
            "parent_cardinality": "exactly_one",
            "def": "FOREIGN KEY (datasettypeid) REFERENCES ndb.datasettypes(datasettypeid) ON UPDATE CASCADE ON DELETE CASCADE"
        },
        {
            "table": "ndb.datasettaxagrouptypes",
            "columns": [
                "taxagroupid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.taxagrouptypes",
            "parent_columns": [
                "taxagroupid"
            ],
            "parent_cardinality": "exactly_one",
            "def": "FOREIGN KEY (taxagroupid) REFERENCES ndb.taxagrouptypes(taxagroupid) ON UPDATE CASCADE ON DELETE CASCADE"
        },
        {
            "table": "ndb.taxa",
            "columns": [
                "validatorid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.contacts",
            "parent_columns": [
                "contactid"
            ],
            "parent_cardinality": "zero_or_one",
            "def": "FOREIGN KEY (validatorid) REFERENCES ndb.contacts(contactid)"
        },
        {
            "table": "ndb.taxa",
            "columns": [
                "publicationid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.publications",
            "parent_columns": [
                "publicationid"
            ],
            "parent_cardinality": "zero_or_one",
            "def": "FOREIGN KEY (publicationid) REFERENCES ndb.publications(publicationid)"
        },
        {
            "table": "ndb.taxa",
            "columns": [
                "highertaxonid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.taxa",
            "parent_columns": [
                "taxonid"
            ],
            "parent_cardinality": "zero_or_one",
            "def": "FOREIGN KEY (highertaxonid) REFERENCES ndb.taxa(taxonid)"
        },
        {
            "table": "ndb.taxa",
            "columns": [
                "taxagroupid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.taxagrouptypes",
            "parent_columns": [
                "taxagroupid"
            ],
            "parent_cardinality": "exactly_one",
            "def": "FOREIGN KEY (taxagroupid) REFERENCES ndb.taxagrouptypes(taxagroupid)"
        },
        {
            "table": "ndb.contacts",
            "columns": [
                "contactstatusid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.contactstatuses",
            "parent_columns": [
                "contactstatusid"
            ],
            "parent_cardinality": "zero_or_one",
            "def": "FOREIGN KEY (contactstatusid) REFERENCES ndb.contactstatuses(contactstatusid) ON UPDATE CASCADE ON DELETE SET NULL"
        },
        {
            "table": "ndb.data",
            "columns": [
                "sampleid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.samples",
            "parent_columns": [
                "sampleid"
            ],
            "parent_cardinality": "exactly_one",
            "def": "FOREIGN KEY (sampleid) REFERENCES ndb.samples(sampleid) ON UPDATE CASCADE ON DELETE CASCADE"
        },
        {
            "table": "ndb.data",
            "columns": [
                "variableid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.variables",
            "parent_columns": [
                "variableid"
            ],
            "parent_cardinality": "exactly_one",
            "def": "FOREIGN KEY (variableid) REFERENCES ndb.variables(variableid) ON UPDATE CASCADE ON DELETE CASCADE"
        },
        {
            "table": "ndb.chronologies",
            "columns": [
                "agetypeid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.agetypes",
            "parent_columns": [
                "agetypeid"
            ],
            "parent_cardinality": "exactly_one",
            "def": "FOREIGN KEY (agetypeid) REFERENCES ndb.agetypes(agetypeid) ON UPDATE CASCADE ON DELETE CASCADE"
        },
        {
            "table": "ndb.chronologies",
            "columns": [
                "collectionunitid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.collectionunits",
            "parent_columns": [
                "collectionunitid"
            ],
            "parent_cardinality": "exactly_one",
            "def": "FOREIGN KEY (collectionunitid) REFERENCES ndb.collectionunits(collectionunitid) ON UPDATE CASCADE ON DELETE CASCADE"
        },
        {
            "table": "ndb.chronologies",
            "columns": [
                "contactid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.contacts",
            "parent_columns": [
                "contactid"
            ],
            "parent_cardinality": "zero_or_one",
            "def": "FOREIGN KEY (contactid) REFERENCES ndb.contacts(contactid) ON UPDATE CASCADE"
        },
        {
            "table": "ndb.sampleages",
            "columns": [
                "chronologyid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.chronologies",
            "parent_columns": [
                "chronologyid"
            ],
            "parent_cardinality": "exactly_one",
            "def": "FOREIGN KEY (chronologyid) REFERENCES ndb.chronologies(chronologyid) ON UPDATE CASCADE ON DELETE CASCADE"
        },
        {
            "table": "ndb.sampleages",
            "columns": [
                "sampleid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.samples",
            "parent_columns": [
                "sampleid"
            ],
            "parent_cardinality": "exactly_one",
            "def": "FOREIGN KEY (sampleid) REFERENCES ndb.samples(sampleid) ON UPDATE CASCADE ON DELETE CASCADE"
        },
        {
            "table": "ndb.collectionunits",
            "columns": [
                "colltypeid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.collectiontypes",
            "parent_columns": [
                "colltypeid"
            ],
            "parent_cardinality": "zero_or_one",
            "def": "FOREIGN KEY (colltypeid) REFERENCES ndb.collectiontypes(colltypeid) ON UPDATE CASCADE ON DELETE CASCADE"
        },
        {
            "table": "ndb.collectionunits",
            "columns": [
                "depenvtid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.depenvttypes",
            "parent_columns": [
                "depenvtid"
            ],
            "parent_cardinality": "zero_or_one",
            "def": "FOREIGN KEY (depenvtid) REFERENCES ndb.depenvttypes(depenvtid) ON UPDATE CASCADE ON DELETE CASCADE"
        },
        {
            "table": "ndb.collectionunits",
            "columns": [
                "substrateid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.rocktypes",
            "parent_columns": [
                "rocktypeid"
            ],
            "parent_cardinality": "zero_or_one",
            "def": "FOREIGN KEY (substrateid) REFERENCES ndb.rocktypes(rocktypeid) ON UPDATE CASCADE ON DELETE CASCADE"
        },
        {
            "table": "ndb.collectionunits",
            "columns": [
                "siteid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.sites",
            "parent_columns": [
                "siteid"
            ],
            "parent_cardinality": "exactly_one",
            "def": "FOREIGN KEY (siteid) REFERENCES ndb.sites(siteid) ON UPDATE CASCADE ON DELETE CASCADE"
        },
        {
            "table": "ndb.constituentdatabases",
            "columns": [
                "contactid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.contacts",
            "parent_columns": [
                "contactid"
            ],
            "parent_cardinality": "zero_or_one",
            "def": "FOREIGN KEY (contactid) REFERENCES ndb.contacts(contactid)"
        },
        {
            "table": "ndb.datasetdatabases",
            "columns": [
                "databaseid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.constituentdatabases",
            "parent_columns": [
                "databaseid"
            ],
            "parent_cardinality": "exactly_one",
            "def": "FOREIGN KEY (databaseid) REFERENCES ndb.constituentdatabases(databaseid) ON UPDATE CASCADE ON DELETE CASCADE"
        },
        {
            "table": "ndb.datasetdatabases",
            "columns": [
                "datasetid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.datasets",
            "parent_columns": [
                "datasetid"
            ],
            "parent_cardinality": "exactly_one",
            "def": "FOREIGN KEY (datasetid) REFERENCES ndb.datasets(datasetid) ON UPDATE CASCADE ON DELETE CASCADE"
        },
        {
            "table": "ndb.datasets",
            "columns": [
                "collectionunitid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.collectionunits",
            "parent_columns": [
                "collectionunitid"
            ],
            "parent_cardinality": "exactly_one",
            "def": "FOREIGN KEY (collectionunitid) REFERENCES ndb.collectionunits(collectionunitid) ON UPDATE CASCADE ON DELETE CASCADE"
        },
        {
            "table": "ndb.datasets",
            "columns": [
                "datasettypeid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.datasettypes",
            "parent_columns": [
                "datasettypeid"
            ],
            "parent_cardinality": "exactly_one",
            "def": "FOREIGN KEY (datasettypeid) REFERENCES ndb.datasettypes(datasettypeid) ON UPDATE CASCADE ON DELETE CASCADE"
        },
        {
            "table": "ndb.datasets",
            "columns": [
                "embargoid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.embargo",
            "parent_columns": [
                "embargoid"
            ],
            "parent_cardinality": "zero_or_one",
            "def": "FOREIGN KEY (embargoid) REFERENCES ndb.embargo(embargoid) ON UPDATE CASCADE ON DELETE CASCADE"
        },
        {
            "table": "ndb.sitegeopolitical",
            "columns": [
                "geopoliticalid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.geopoliticalunits",
            "parent_columns": [
                "geopoliticalid"
            ],
            "parent_cardinality": "exactly_one",
            "def": "FOREIGN KEY (geopoliticalid) REFERENCES ndb.geopoliticalunits(geopoliticalid)"
        },
        {
            "table": "ndb.sitegeopolitical",
            "columns": [
                "siteid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.sites",
            "parent_columns": [
                "siteid"
            ],
            "parent_cardinality": "exactly_one",
            "def": "FOREIGN KEY (siteid) REFERENCES ndb.sites(siteid) ON UPDATE CASCADE ON DELETE CASCADE"
        },
        {
            "table": "ndb.sitegeopolitical",
            "columns": [
                "objectid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ap.gadm",
            "parent_columns": [
                "objectid"
            ],
            "parent_cardinality": "zero_or_one",
            "def": "FOREIGN KEY (objectid) REFERENCES ap.gadm(objectid)"
        },
        {
            "table": "ndb.accumulationrates",
            "columns": [
                "analysisunitid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.analysisunits",
            "parent_columns": [
                "analysisunitid"
            ],
            "parent_cardinality": "exactly_one",
            "def": "FOREIGN KEY (analysisunitid) REFERENCES ndb.analysisunits(analysisunitid) ON UPDATE CASCADE ON DELETE CASCADE"
        },
        {
            "table": "ndb.accumulationrates",
            "columns": [
                "chronologyid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.chronologies",
            "parent_columns": [
                "chronologyid"
            ],
            "parent_cardinality": "exactly_one",
            "def": "FOREIGN KEY (chronologyid) REFERENCES ndb.chronologies(chronologyid)"
        },
        {
            "table": "ndb.accumulationrates",
            "columns": [
                "variableunitsid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.variableunits",
            "parent_columns": [
                "variableunitsid"
            ],
            "parent_cardinality": "exactly_one",
            "def": "FOREIGN KEY (variableunitsid) REFERENCES ndb.variableunits(variableunitsid) ON UPDATE CASCADE ON DELETE CASCADE"
        },
        {
            "table": "ndb.aggregatechronologies",
            "columns": [
                "agetypeid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.agetypes",
            "parent_columns": [
                "agetypeid"
            ],
            "parent_cardinality": "exactly_one",
            "def": "FOREIGN KEY (agetypeid) REFERENCES ndb.agetypes(agetypeid) ON UPDATE CASCADE ON DELETE CASCADE"
        },
        {
            "table": "ndb.aggregatechronologies",
            "columns": [
                "aggregatedatasetid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.aggregatedatasets",
            "parent_columns": [
                "aggregatedatasetid"
            ],
            "parent_cardinality": "exactly_one",
            "def": "FOREIGN KEY (aggregatedatasetid) REFERENCES ndb.aggregatedatasets(aggregatedatasetid) ON UPDATE CASCADE ON DELETE CASCADE"
        },
        {
            "table": "ndb.aggregatedatasets",
            "columns": [
                "aggregateordertypeid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.aggregateordertypes",
            "parent_columns": [
                "aggregateordertypeid"
            ],
            "parent_cardinality": "exactly_one",
            "def": "FOREIGN KEY (aggregateordertypeid) REFERENCES ndb.aggregateordertypes(aggregateordertypeid) ON UPDATE CASCADE ON DELETE CASCADE"
        },
        {
            "table": "ndb.aggregatesampleages",
            "columns": [
                "aggregatechronid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.aggregatechronologies",
            "parent_columns": [
                "aggregatechronid"
            ],
            "parent_cardinality": "exactly_one",
            "def": "FOREIGN KEY (aggregatechronid) REFERENCES ndb.aggregatechronologies(aggregatechronid)"
        },
        {
            "table": "ndb.aggregatesampleages",
            "columns": [
                "aggregatedatasetid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.aggregatedatasets",
            "parent_columns": [
                "aggregatedatasetid"
            ],
            "parent_cardinality": "exactly_one",
            "def": "FOREIGN KEY (aggregatedatasetid) REFERENCES ndb.aggregatedatasets(aggregatedatasetid) ON UPDATE CASCADE ON DELETE CASCADE"
        },
        {
            "table": "ndb.aggregatesampleages",
            "columns": [
                "sampleageid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.sampleages",
            "parent_columns": [
                "sampleageid"
            ],
            "parent_cardinality": "exactly_one",
            "def": "FOREIGN KEY (sampleageid) REFERENCES ndb.sampleages(sampleageid) ON UPDATE CASCADE ON DELETE CASCADE"
        },
        {
            "table": "ndb.aggregatesamples",
            "columns": [
                "aggregatedatasetid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.aggregatedatasets",
            "parent_columns": [
                "aggregatedatasetid"
            ],
            "parent_cardinality": "exactly_one",
            "def": "FOREIGN KEY (aggregatedatasetid) REFERENCES ndb.aggregatedatasets(aggregatedatasetid) ON UPDATE CASCADE ON DELETE CASCADE"
        },
        {
            "table": "ndb.aggregatesamples",
            "columns": [
                "sampleid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.samples",
            "parent_columns": [
                "sampleid"
            ],
            "parent_cardinality": "exactly_one",
            "def": "FOREIGN KEY (sampleid) REFERENCES ndb.samples(sampleid) ON UPDATE CASCADE ON DELETE CASCADE"
        },
        {
            "table": "ndb.analysisunitaltdepths",
            "columns": [
                "altdepthscaleid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.analysisunitaltdepthscales",
            "parent_columns": [
                "altdepthscaleid"
            ],
            "parent_cardinality": "exactly_one",
            "def": "FOREIGN KEY (altdepthscaleid) REFERENCES ndb.analysisunitaltdepthscales(altdepthscaleid) ON UPDATE CASCADE ON DELETE CASCADE"
        },
        {
            "table": "ndb.analysisunitaltdepths",
            "columns": [
                "analysisunitid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.analysisunits",
            "parent_columns": [
                "analysisunitid"
            ],
            "parent_cardinality": "exactly_one",
            "def": "FOREIGN KEY (analysisunitid) REFERENCES ndb.analysisunits(analysisunitid) ON UPDATE CASCADE ON DELETE CASCADE"
        },
        {
            "table": "ndb.analysisunitaltdepthscales",
            "columns": [
                "variableunitsid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.variableunits",
            "parent_columns": [
                "variableunitsid"
            ],
            "parent_cardinality": "exactly_one",
            "def": "FOREIGN KEY (variableunitsid) REFERENCES ndb.variableunits(variableunitsid) ON UPDATE CASCADE ON DELETE CASCADE"
        },
        {
            "table": "ndb.analysisunitlithostrat",
            "columns": [
                "analysisunitid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.analysisunits",
            "parent_columns": [
                "analysisunitid"
            ],
            "parent_cardinality": "exactly_one",
            "def": "FOREIGN KEY (analysisunitid) REFERENCES ndb.analysisunits(analysisunitid) ON UPDATE CASCADE ON DELETE CASCADE"
        },
        {
            "table": "ndb.analysisunitlithostrat",
            "columns": [
                "lithostratid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.lithostrat",
            "parent_columns": [
                "lithostratid"
            ],
            "parent_cardinality": "exactly_one",
            "def": "FOREIGN KEY (lithostratid) REFERENCES ndb.lithostrat(lithostratid) ON UPDATE CASCADE ON DELETE CASCADE"
        },
        {
            "table": "ndb.analysisunits",
            "columns": [
                "collectionunitid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.collectionunits",
            "parent_columns": [
                "collectionunitid"
            ],
            "parent_cardinality": "exactly_one",
            "def": "FOREIGN KEY (collectionunitid) REFERENCES ndb.collectionunits(collectionunitid) ON UPDATE CASCADE ON DELETE CASCADE"
        },
        {
            "table": "ndb.analysisunits",
            "columns": [
                "faciesid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.faciestypes",
            "parent_columns": [
                "faciesid"
            ],
            "parent_cardinality": "zero_or_one",
            "def": "FOREIGN KEY (faciesid) REFERENCES ndb.faciestypes(faciesid) ON UPDATE CASCADE ON DELETE CASCADE"
        },
        {
            "table": "ndb.calibrationcurves",
            "columns": [
                "publicationid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.publications",
            "parent_columns": [
                "publicationid"
            ],
            "parent_cardinality": "exactly_one",
            "def": "FOREIGN KEY (publicationid) REFERENCES ndb.publications(publicationid) ON UPDATE CASCADE ON DELETE CASCADE"
        },
        {
            "table": "ndb.chroncontrolranks",
            "columns": [
                "accuracydirectionid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.chroncontrolaccuracydirections",
            "parent_columns": [
                "accuracydirectionid"
            ],
            "parent_cardinality": "zero_or_one",
            "def": "FOREIGN KEY (accuracydirectionid) REFERENCES ndb.chroncontrolaccuracydirections(accuracydirectionid) ON UPDATE CASCADE ON DELETE CASCADE"
        },
        {
            "table": "ndb.chroncontrolranks",
            "columns": [
                "accuracydistributionid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.chroncontrolaccuracydistributions",
            "parent_columns": [
                "accuracydistributionid"
            ],
            "parent_cardinality": "zero_or_one",
            "def": "FOREIGN KEY (accuracydistributionid) REFERENCES ndb.chroncontrolaccuracydistributions(accuracydistributionid) ON UPDATE CASCADE ON DELETE CASCADE"
        },
        {
            "table": "ndb.chroncontrolranks",
            "columns": [
                "accuracyrankid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.chroncontrolaccuracyranks",
            "parent_columns": [
                "accuracyrankid"
            ],
            "parent_cardinality": "zero_or_one",
            "def": "FOREIGN KEY (accuracyrankid) REFERENCES ndb.chroncontrolaccuracyranks(accuracyrankid) ON UPDATE CASCADE ON DELETE CASCADE"
        },
        {
            "table": "ndb.chroncontrolranks",
            "columns": [
                "precisionrankid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.chroncontrolprecisionranks",
            "parent_columns": [
                "precisionrankid"
            ],
            "parent_cardinality": "zero_or_one",
            "def": "FOREIGN KEY (precisionrankid) REFERENCES ndb.chroncontrolprecisionranks(precisionrankid) ON UPDATE CASCADE ON DELETE CASCADE"
        },
        {
            "table": "ndb.chroncontrolranks",
            "columns": [
                "chroncontrolid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.chroncontrols",
            "parent_columns": [
                "chroncontrolid"
            ],
            "parent_cardinality": "zero_or_one",
            "def": "FOREIGN KEY (chroncontrolid) REFERENCES ndb.chroncontrols(chroncontrolid) ON UPDATE CASCADE ON DELETE CASCADE"
        },
        {
            "table": "ndb.chroncontrols",
            "columns": [
                "agetypeid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.agetypes",
            "parent_columns": [
                "agetypeid"
            ],
            "parent_cardinality": "zero_or_one",
            "def": "FOREIGN KEY (agetypeid) REFERENCES ndb.agetypes(agetypeid)"
        },
        {
            "table": "ndb.chroncontrols",
            "columns": [
                "analysisunitid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.analysisunits",
            "parent_columns": [
                "analysisunitid"
            ],
            "parent_cardinality": "zero_or_one",
            "def": "FOREIGN KEY (analysisunitid) REFERENCES ndb.analysisunits(analysisunitid) ON UPDATE CASCADE ON DELETE CASCADE"
        },
        {
            "table": "ndb.chroncontrols",
            "columns": [
                "chroncontroltypeid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.chroncontroltypes",
            "parent_columns": [
                "chroncontroltypeid"
            ],
            "parent_cardinality": "zero_or_one",
            "def": "FOREIGN KEY (chroncontroltypeid) REFERENCES ndb.chroncontroltypes(chroncontroltypeid) ON UPDATE CASCADE ON DELETE CASCADE"
        },
        {
            "table": "ndb.chroncontrols",
            "columns": [
                "chronologyid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.chronologies",
            "parent_columns": [
                "chronologyid"
            ],
            "parent_cardinality": "exactly_one",
            "def": "FOREIGN KEY (chronologyid) REFERENCES ndb.chronologies(chronologyid) ON UPDATE CASCADE ON DELETE CASCADE"
        },
        {
            "table": "ndb.chroncontrolscal14c",
            "columns": [
                "calibrationcurveid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.calibrationcurves",
            "parent_columns": [
                "calibrationcurveid"
            ],
            "parent_cardinality": "exactly_one",
            "def": "FOREIGN KEY (calibrationcurveid) REFERENCES ndb.calibrationcurves(calibrationcurveid) ON UPDATE CASCADE ON DELETE CASCADE"
        },
        {
            "table": "ndb.chroncontrolscal14c",
            "columns": [
                "calibrationprogramid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.calibrationprograms",
            "parent_columns": [
                "calibrationprogramid"
            ],
            "parent_cardinality": "exactly_one",
            "def": "FOREIGN KEY (calibrationprogramid) REFERENCES ndb.calibrationprograms(calibrationprogramid) ON UPDATE CASCADE ON DELETE CASCADE"
        },
        {
            "table": "ndb.chroncontrolscal14c",
            "columns": [
                "chroncontrolid"
            ],
            "cardinality": "zero_or_one",
            "parent_table": "ndb.chroncontrols",
            "parent_columns": [
                "chroncontrolid"
            ],
            "parent_cardinality": "exactly_one",
            "def": "FOREIGN KEY (chroncontrolid) REFERENCES ndb.chroncontrols(chroncontrolid) ON UPDATE CASCADE ON DELETE CASCADE"
        },
        {
            "table": "ndb.chroncontroltypes",
            "columns": [
                "higherchroncontroltypeid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.chroncontroltypes",
            "parent_columns": [
                "chroncontroltypeid"
            ],
            "parent_cardinality": "zero_or_one",
            "def": "FOREIGN KEY (higherchroncontroltypeid) REFERENCES ndb.chroncontroltypes(chroncontroltypeid)"
        },
        {
            "table": "ndb.collectors",
            "columns": [
                "collectionunitid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.collectionunits",
            "parent_columns": [
                "collectionunitid"
            ],
            "parent_cardinality": "exactly_one",
            "def": "FOREIGN KEY (collectionunitid) REFERENCES ndb.collectionunits(collectionunitid) ON UPDATE CASCADE ON DELETE CASCADE"
        },
        {
            "table": "ndb.collectors",
            "columns": [
                "contactid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.contacts",
            "parent_columns": [
                "contactid"
            ],
            "parent_cardinality": "exactly_one",
            "def": "FOREIGN KEY (contactid) REFERENCES ndb.contacts(contactid) ON UPDATE CASCADE"
        },
        {
            "table": "ndb.contactreferences",
            "columns": [
                "contactid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.contacts",
            "parent_columns": [
                "contactid"
            ],
            "parent_cardinality": "zero_or_one",
            "def": "FOREIGN KEY (contactid) REFERENCES ndb.contacts(contactid)"
        },
        {
            "table": "ndb.contactreferences",
            "columns": [
                "exdatabaseid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.externaldatabases",
            "parent_columns": [
                "extdatabaseid"
            ],
            "parent_cardinality": "zero_or_one",
            "def": "FOREIGN KEY (exdatabaseid) REFERENCES ndb.externaldatabases(extdatabaseid)"
        },
        {
            "table": "ndb.contextsdatasettypes",
            "columns": [
                "datasettypeid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.datasettypes",
            "parent_columns": [
                "datasettypeid"
            ],
            "parent_cardinality": "exactly_one",
            "def": "FOREIGN KEY (datasettypeid) REFERENCES ndb.datasettypes(datasettypeid) ON UPDATE CASCADE ON DELETE CASCADE"
        },
        {
            "table": "ndb.contextsdatasettypes",
            "columns": [
                "variablecontextid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.variablecontexts",
            "parent_columns": [
                "variablecontextid"
            ],
            "parent_cardinality": "exactly_one",
            "def": "FOREIGN KEY (variablecontextid) REFERENCES ndb.variablecontexts(variablecontextid) ON UPDATE CASCADE ON DELETE CASCADE"
        },
        {
            "table": "ndb.dataprocessors",
            "columns": [
                "contactid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.contacts",
            "parent_columns": [
                "contactid"
            ],
            "parent_cardinality": "exactly_one",
            "def": "FOREIGN KEY (contactid) REFERENCES ndb.contacts(contactid) ON UPDATE CASCADE"
        },
        {
            "table": "ndb.dataprocessors",
            "columns": [
                "datasetid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.datasets",
            "parent_columns": [
                "datasetid"
            ],
            "parent_cardinality": "exactly_one",
            "def": "FOREIGN KEY (datasetid) REFERENCES ndb.datasets(datasetid) ON UPDATE CASCADE ON DELETE CASCADE"
        },
        {
            "table": "ndb.datasetsubmissions",
            "columns": [
                "databaseid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.constituentdatabases",
            "parent_columns": [
                "databaseid"
            ],
            "parent_cardinality": "zero_or_one",
            "def": "FOREIGN KEY (databaseid) REFERENCES ndb.constituentdatabases(databaseid) ON UPDATE CASCADE ON DELETE CASCADE"
        },
        {
            "table": "ndb.datasetsubmissions",
            "columns": [
                "contactid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.contacts",
            "parent_columns": [
                "contactid"
            ],
            "parent_cardinality": "zero_or_one",
            "def": "FOREIGN KEY (contactid) REFERENCES ndb.contacts(contactid) ON UPDATE CASCADE"
        },
        {
            "table": "ndb.datasetsubmissions",
            "columns": [
                "datasetid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.datasets",
            "parent_columns": [
                "datasetid"
            ],
            "parent_cardinality": "exactly_one",
            "def": "FOREIGN KEY (datasetid) REFERENCES ndb.datasets(datasetid) ON UPDATE CASCADE ON DELETE CASCADE"
        },
        {
            "table": "ndb.datasetsubmissions",
            "columns": [
                "submissiontypeid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.datasetsubmissiontypes",
            "parent_columns": [
                "submissiontypeid"
            ],
            "parent_cardinality": "zero_or_one",
            "def": "FOREIGN KEY (submissiontypeid) REFERENCES ndb.datasetsubmissiontypes(submissiontypeid) ON UPDATE CASCADE ON DELETE CASCADE"
        },
        {
            "table": "ndb.datasettaxonnotes",
            "columns": [
                "contactid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.contacts",
            "parent_columns": [
                "contactid"
            ],
            "parent_cardinality": "exactly_one",
            "def": "FOREIGN KEY (contactid) REFERENCES ndb.contacts(contactid)"
        },
        {
            "table": "ndb.datasettaxonnotes",
            "columns": [
                "datasetid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.datasets",
            "parent_columns": [
                "datasetid"
            ],
            "parent_cardinality": "exactly_one",
            "def": "FOREIGN KEY (datasetid) REFERENCES ndb.datasets(datasetid) ON UPDATE CASCADE ON DELETE CASCADE"
        },
        {
            "table": "ndb.datasettaxonnotes",
            "columns": [
                "taxonid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.taxa",
            "parent_columns": [
                "taxonid"
            ],
            "parent_cardinality": "exactly_one",
            "def": "FOREIGN KEY (taxonid) REFERENCES ndb.taxa(taxonid) ON UPDATE CASCADE ON DELETE CASCADE"
        },
        {
            "table": "ndb.datasetvariables",
            "columns": [
                "datasetid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.datasets",
            "parent_columns": [
                "datasetid"
            ],
            "parent_cardinality": "exactly_one",
            "def": "FOREIGN KEY (datasetid) REFERENCES ndb.datasets(datasetid) ON UPDATE CASCADE ON DELETE CASCADE"
        },
        {
            "table": "ndb.datasetvariables",
            "columns": [
                "variableid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.variables",
            "parent_columns": [
                "variableid"
            ],
            "parent_cardinality": "exactly_one",
            "def": "FOREIGN KEY (variableid) REFERENCES ndb.variables(variableid) ON UPDATE CASCADE ON DELETE CASCADE"
        },
        {
            "table": "ndb.datataxonnotes",
            "columns": [
                "contactid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.contacts",
            "parent_columns": [
                "contactid"
            ],
            "parent_cardinality": "exactly_one",
            "def": "FOREIGN KEY (contactid) REFERENCES ndb.contacts(contactid)"
        },
        {
            "table": "ndb.datataxonnotes",
            "columns": [
                "dataid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.data",
            "parent_columns": [
                "dataid"
            ],
            "parent_cardinality": "exactly_one",
            "def": "FOREIGN KEY (dataid) REFERENCES ndb.data(dataid) ON UPDATE CASCADE ON DELETE CASCADE"
        },
        {
            "table": "ndb.depagents",
            "columns": [
                "analysisunitid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.analysisunits",
            "parent_columns": [
                "analysisunitid"
            ],
            "parent_cardinality": "exactly_one",
            "def": "FOREIGN KEY (analysisunitid) REFERENCES ndb.analysisunits(analysisunitid) ON UPDATE CASCADE ON DELETE CASCADE"
        },
        {
            "table": "ndb.depagents",
            "columns": [
                "depagentid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.depagenttypes",
            "parent_columns": [
                "depagentid"
            ],
            "parent_cardinality": "exactly_one",
            "def": "FOREIGN KEY (depagentid) REFERENCES ndb.depagenttypes(depagentid) ON UPDATE CASCADE ON DELETE CASCADE"
        },
        {
            "table": "ndb.depenvttypes",
            "columns": [
                "depenvthigherid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.depenvttypes",
            "parent_columns": [
                "depenvtid"
            ],
            "parent_cardinality": "exactly_one",
            "def": "FOREIGN KEY (depenvthigherid) REFERENCES ndb.depenvttypes(depenvtid)"
        },
        {
            "table": "ndb.ecolgroups",
            "columns": [
                "ecolgroupid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.ecolgrouptypes",
            "parent_columns": [
                "ecolgroupid"
            ],
            "parent_cardinality": "exactly_one",
            "def": "FOREIGN KEY (ecolgroupid) REFERENCES ndb.ecolgrouptypes(ecolgroupid) ON UPDATE CASCADE ON DELETE CASCADE"
        },
        {
            "table": "ndb.ecolgroups",
            "columns": [
                "ecolsetid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.ecolsettypes",
            "parent_columns": [
                "ecolsetid"
            ],
            "parent_cardinality": "exactly_one",
            "def": "FOREIGN KEY (ecolsetid) REFERENCES ndb.ecolsettypes(ecolsetid) ON UPDATE CASCADE ON DELETE CASCADE"
        },
        {
            "table": "ndb.ecolgroups",
            "columns": [
                "taxonid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.taxa",
            "parent_columns": [
                "taxonid"
            ],
            "parent_cardinality": "exactly_one",
            "def": "FOREIGN KEY (taxonid) REFERENCES ndb.taxa(taxonid) ON UPDATE CASCADE ON DELETE CASCADE"
        },
        {
            "table": "ndb.elementdatasettaxagroups",
            "columns": [
                "datasettypeid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.datasettypes",
            "parent_columns": [
                "datasettypeid"
            ],
            "parent_cardinality": "exactly_one",
            "def": "FOREIGN KEY (datasettypeid) REFERENCES ndb.datasettypes(datasettypeid)"
        },
        {
            "table": "ndb.elementdatasettaxagroups",
            "columns": [
                "taxagroupid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.taxagrouptypes",
            "parent_columns": [
                "taxagroupid"
            ],
            "parent_cardinality": "exactly_one",
            "def": "FOREIGN KEY (taxagroupid) REFERENCES ndb.taxagrouptypes(taxagroupid)"
        },
        {
            "table": "ndb.elementtaxagroupmaturities",
            "columns": [
                "maturityid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.elementmaturities",
            "parent_columns": [
                "maturityid"
            ],
            "parent_cardinality": "exactly_one",
            "def": "FOREIGN KEY (maturityid) REFERENCES ndb.elementmaturities(maturityid) ON UPDATE CASCADE ON DELETE CASCADE"
        },
        {
            "table": "ndb.elementtaxagroupmaturities",
            "columns": [
                "elementtaxagroupid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.elementtaxagroups",
            "parent_columns": [
                "elementtaxagroupid"
            ],
            "parent_cardinality": "exactly_one",
            "def": "FOREIGN KEY (elementtaxagroupid) REFERENCES ndb.elementtaxagroups(elementtaxagroupid) ON UPDATE CASCADE ON DELETE CASCADE"
        },
        {
            "table": "ndb.elementtaxagroupportions",
            "columns": [
                "portionid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.elementportions",
            "parent_columns": [
                "portionid"
            ],
            "parent_cardinality": "exactly_one",
            "def": "FOREIGN KEY (portionid) REFERENCES ndb.elementportions(portionid) ON UPDATE CASCADE ON DELETE CASCADE"
        },
        {
            "table": "ndb.elementtaxagroupportions",
            "columns": [
                "elementtaxagroupid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.elementtaxagroups",
            "parent_columns": [
                "elementtaxagroupid"
            ],
            "parent_cardinality": "exactly_one",
            "def": "FOREIGN KEY (elementtaxagroupid) REFERENCES ndb.elementtaxagroups(elementtaxagroupid) ON UPDATE CASCADE ON DELETE CASCADE"
        },
        {
            "table": "ndb.elementtaxagroups",
            "columns": [
                "elementtypeid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.elementtypes",
            "parent_columns": [
                "elementtypeid"
            ],
            "parent_cardinality": "exactly_one",
            "def": "FOREIGN KEY (elementtypeid) REFERENCES ndb.elementtypes(elementtypeid) ON UPDATE CASCADE ON DELETE CASCADE"
        },
        {
            "table": "ndb.elementtaxagroups",
            "columns": [
                "taxagroupid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.taxagrouptypes",
            "parent_columns": [
                "taxagroupid"
            ],
            "parent_cardinality": "exactly_one",
            "def": "FOREIGN KEY (taxagroupid) REFERENCES ndb.taxagrouptypes(taxagroupid) ON UPDATE CASCADE ON DELETE CASCADE"
        },
        {
            "table": "ndb.elementtaxagroupsymmetries",
            "columns": [
                "symmetryid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.elementsymmetries",
            "parent_columns": [
                "symmetryid"
            ],
            "parent_cardinality": "exactly_one",
            "def": "FOREIGN KEY (symmetryid) REFERENCES ndb.elementsymmetries(symmetryid) ON UPDATE CASCADE ON DELETE CASCADE"
        },
        {
            "table": "ndb.elementtaxagroupsymmetries",
            "columns": [
                "elementtaxagroupid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.elementtaxagroups",
            "parent_columns": [
                "elementtaxagroupid"
            ],
            "parent_cardinality": "exactly_one",
            "def": "FOREIGN KEY (elementtaxagroupid) REFERENCES ndb.elementtaxagroups(elementtaxagroupid) ON UPDATE CASCADE ON DELETE CASCADE"
        },
        {
            "table": "ndb.eventchronology",
            "columns": [
                "analysisunitid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.analysisunits",
            "parent_columns": [
                "analysisunitid"
            ],
            "parent_cardinality": "zero_or_one",
            "def": "FOREIGN KEY (analysisunitid) REFERENCES ndb.analysisunits(analysisunitid)"
        },
        {
            "table": "ndb.eventchronology",
            "columns": [
                "chroncontrolid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.chroncontrols",
            "parent_columns": [
                "chroncontrolid"
            ],
            "parent_cardinality": "exactly_one",
            "def": "FOREIGN KEY (chroncontrolid) REFERENCES ndb.chroncontrols(chroncontrolid)"
        },
        {
            "table": "ndb.eventchronology",
            "columns": [
                "eventid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.events",
            "parent_columns": [
                "eventid"
            ],
            "parent_cardinality": "exactly_one",
            "def": "FOREIGN KEY (eventid) REFERENCES ndb.events(eventid)"
        },
        {
            "table": "ndb.eventpublications",
            "columns": [
                "eventid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.events",
            "parent_columns": [
                "eventid"
            ],
            "parent_cardinality": "exactly_one",
            "def": "FOREIGN KEY (eventid) REFERENCES ndb.events(eventid) ON UPDATE CASCADE ON DELETE CASCADE"
        },
        {
            "table": "ndb.eventpublications",
            "columns": [
                "publicationid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.publications",
            "parent_columns": [
                "publicationid"
            ],
            "parent_cardinality": "exactly_one",
            "def": "FOREIGN KEY (publicationid) REFERENCES ndb.publications(publicationid) ON UPDATE CASCADE ON DELETE CASCADE"
        },
        {
            "table": "ndb.events",
            "columns": [
                "eventtypeid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.eventtypes",
            "parent_columns": [
                "eventtypeid"
            ],
            "parent_cardinality": "exactly_one",
            "def": "FOREIGN KEY (eventtypeid) REFERENCES ndb.eventtypes(eventtypeid) ON UPDATE CASCADE ON DELETE CASCADE"
        },
        {
            "table": "ndb.eventtypes",
            "columns": [
                "chroncontroltypeid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.chroncontroltypes",
            "parent_columns": [
                "chroncontroltypeid"
            ],
            "parent_cardinality": "zero_or_one",
            "def": "FOREIGN KEY (chroncontroltypeid) REFERENCES ndb.chroncontroltypes(chroncontroltypeid)"
        },
        {
            "table": "ndb.externalpublications",
            "columns": [
                "extdatabaseid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.externaldatabases",
            "parent_columns": [
                "extdatabaseid"
            ],
            "parent_cardinality": "exactly_one",
            "def": "FOREIGN KEY (extdatabaseid) REFERENCES ndb.externaldatabases(extdatabaseid) ON UPDATE CASCADE ON DELETE CASCADE"
        },
        {
            "table": "ndb.externalpublications",
            "columns": [
                "publicationid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.publications",
            "parent_columns": [
                "publicationid"
            ],
            "parent_cardinality": "exactly_one",
            "def": "FOREIGN KEY (publicationid) REFERENCES ndb.publications(publicationid) ON UPDATE CASCADE ON DELETE CASCADE"
        },
        {
            "table": "ndb.externaltaxa",
            "columns": [
                "extdatabaseid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.externaldatabases",
            "parent_columns": [
                "extdatabaseid"
            ],
            "parent_cardinality": "exactly_one",
            "def": "FOREIGN KEY (extdatabaseid) REFERENCES ndb.externaldatabases(extdatabaseid) ON UPDATE CASCADE ON DELETE CASCADE"
        },
        {
            "table": "ndb.externaltaxa",
            "columns": [
                "taxonid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.taxa",
            "parent_columns": [
                "taxonid"
            ],
            "parent_cardinality": "exactly_one",
            "def": "FOREIGN KEY (taxonid) REFERENCES ndb.taxa(taxonid) ON UPDATE CASCADE ON DELETE CASCADE"
        },
        {
            "table": "ndb.formtaxa",
            "columns": [
                "publicationid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.publications",
            "parent_columns": [
                "publicationid"
            ],
            "parent_cardinality": "exactly_one",
            "def": "FOREIGN KEY (publicationid) REFERENCES ndb.publications(publicationid) ON UPDATE CASCADE ON DELETE CASCADE"
        },
        {
            "table": "ndb.formtaxa",
            "columns": [
                "taxonid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.taxa",
            "parent_columns": [
                "taxonid"
            ],
            "parent_cardinality": "exactly_one",
            "def": "FOREIGN KEY (taxonid) REFERENCES ndb.taxa(taxonid)"
        },
        {
            "table": "ndb.formtaxa",
            "columns": [
                "affinityid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.taxa",
            "parent_columns": [
                "taxonid"
            ],
            "parent_cardinality": "exactly_one",
            "def": "FOREIGN KEY (affinityid) REFERENCES ndb.taxa(taxonid) ON UPDATE CASCADE ON DELETE CASCADE"
        },
        {
            "table": "ndb.geochroncontrols",
            "columns": [
                "chroncontrolid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.chroncontrols",
            "parent_columns": [
                "chroncontrolid"
            ],
            "parent_cardinality": "exactly_one",
            "def": "FOREIGN KEY (chroncontrolid) REFERENCES ndb.chroncontrols(chroncontrolid) ON UPDATE CASCADE ON DELETE CASCADE"
        },
        {
            "table": "ndb.geochroncontrols",
            "columns": [
                "geochronid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.geochronology",
            "parent_columns": [
                "geochronid"
            ],
            "parent_cardinality": "exactly_one",
            "def": "FOREIGN KEY (geochronid) REFERENCES ndb.geochronology(geochronid) ON UPDATE CASCADE ON DELETE CASCADE"
        },
        {
            "table": "ndb.geochronology",
            "columns": [
                "agetypeid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.agetypes",
            "parent_columns": [
                "agetypeid"
            ],
            "parent_cardinality": "exactly_one",
            "def": "FOREIGN KEY (agetypeid) REFERENCES ndb.agetypes(agetypeid)"
        },
        {
            "table": "ndb.geochronology",
            "columns": [
                "geochrontypeid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.geochrontypes",
            "parent_columns": [
                "geochrontypeid"
            ],
            "parent_cardinality": "exactly_one",
            "def": "FOREIGN KEY (geochrontypeid) REFERENCES ndb.geochrontypes(geochrontypeid) ON UPDATE CASCADE ON DELETE CASCADE"
        },
        {
            "table": "ndb.geochronology",
            "columns": [
                "sampleid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.samples",
            "parent_columns": [
                "sampleid"
            ],
            "parent_cardinality": "exactly_one",
            "def": "FOREIGN KEY (sampleid) REFERENCES ndb.samples(sampleid) ON UPDATE CASCADE ON DELETE CASCADE"
        },
        {
            "table": "ndb.geochronpublications",
            "columns": [
                "geochronid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.geochronology",
            "parent_columns": [
                "geochronid"
            ],
            "parent_cardinality": "exactly_one",
            "def": "FOREIGN KEY (geochronid) REFERENCES ndb.geochronology(geochronid) ON UPDATE CASCADE ON DELETE CASCADE"
        },
        {
            "table": "ndb.geochronpublications",
            "columns": [
                "publicationid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.publications",
            "parent_columns": [
                "publicationid"
            ],
            "parent_cardinality": "exactly_one",
            "def": "FOREIGN KEY (publicationid) REFERENCES ndb.publications(publicationid) ON UPDATE CASCADE ON DELETE CASCADE"
        },
        {
            "table": "ndb.geopaths",
            "columns": [
                "geoin"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.geopoliticalunits",
            "parent_columns": [
                "geopoliticalid"
            ],
            "parent_cardinality": "exactly_one",
            "def": "FOREIGN KEY (geoin) REFERENCES ndb.geopoliticalunits(geopoliticalid)"
        },
        {
            "table": "ndb.isobiomarkerbandtypes",
            "columns": [
                "isobiomarkertypeid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.isobiomarkertypes",
            "parent_columns": [
                "isobiomarkertypeid"
            ],
            "parent_cardinality": "exactly_one",
            "def": "FOREIGN KEY (isobiomarkertypeid) REFERENCES ndb.isobiomarkertypes(isobiomarkertypeid) ON UPDATE CASCADE ON DELETE CASCADE"
        },
        {
            "table": "ndb.isoinstrumentation",
            "columns": [
                "datasetid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.datasets",
            "parent_columns": [
                "datasetid"
            ],
            "parent_cardinality": "exactly_one",
            "def": "FOREIGN KEY (datasetid) REFERENCES ndb.datasets(datasetid) ON UPDATE CASCADE ON DELETE CASCADE"
        },
        {
            "table": "ndb.isoinstrumentation",
            "columns": [
                "isoinstrumentationtypeid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.isoinstrumentationtypes",
            "parent_columns": [
                "isoinstrumentationtypeid"
            ],
            "parent_cardinality": "zero_or_one",
            "def": "FOREIGN KEY (isoinstrumentationtypeid) REFERENCES ndb.isoinstrumentationtypes(isoinstrumentationtypeid) ON UPDATE CASCADE ON DELETE CASCADE"
        },
        {
            "table": "ndb.isoinstrumentation",
            "columns": [
                "isosampleintrosystemtypeid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.isosampleintrosystemtypes",
            "parent_columns": [
                "isosampleintrosystemtypeid"
            ],
            "parent_cardinality": "zero_or_one",
            "def": "FOREIGN KEY (isosampleintrosystemtypeid) REFERENCES ndb.isosampleintrosystemtypes(isosampleintrosystemtypeid) ON UPDATE CASCADE ON DELETE CASCADE"
        },
        {
            "table": "ndb.isoinstrumentation",
            "columns": [
                "variableid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.variables",
            "parent_columns": [
                "variableid"
            ],
            "parent_cardinality": "exactly_one",
            "def": "FOREIGN KEY (variableid) REFERENCES ndb.variables(variableid) ON UPDATE CASCADE ON DELETE CASCADE"
        },
        {
            "table": "ndb.isomatanalsubstrate",
            "columns": [
                "isomatanaltypeid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.isomaterialanalyzedtypes",
            "parent_columns": [
                "isomatanaltypeid"
            ],
            "parent_cardinality": "exactly_one",
            "def": "FOREIGN KEY (isomatanaltypeid) REFERENCES ndb.isomaterialanalyzedtypes(isomatanaltypeid) ON UPDATE CASCADE ON DELETE CASCADE"
        },
        {
            "table": "ndb.isomatanalsubstrate",
            "columns": [
                "isosubstratetypeid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.isosubstratetypes",
            "parent_columns": [
                "isosubstratetypeid"
            ],
            "parent_cardinality": "exactly_one",
            "def": "FOREIGN KEY (isosubstratetypeid) REFERENCES ndb.isosubstratetypes(isosubstratetypeid) ON UPDATE CASCADE ON DELETE CASCADE"
        },
        {
            "table": "ndb.isometadata",
            "columns": [
                "analystid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.contacts",
            "parent_columns": [
                "contactid"
            ],
            "parent_cardinality": "zero_or_one",
            "def": "FOREIGN KEY (analystid) REFERENCES ndb.contacts(contactid)"
        },
        {
            "table": "ndb.isometadata",
            "columns": [
                "dataid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.data",
            "parent_columns": [
                "dataid"
            ],
            "parent_cardinality": "exactly_one",
            "def": "FOREIGN KEY (dataid) REFERENCES ndb.data(dataid) ON UPDATE CASCADE ON DELETE CASCADE"
        },
        {
            "table": "ndb.isometadata",
            "columns": [
                "isomatanaltypeid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.isomaterialanalyzedtypes",
            "parent_columns": [
                "isomatanaltypeid"
            ],
            "parent_cardinality": "zero_or_one",
            "def": "FOREIGN KEY (isomatanaltypeid) REFERENCES ndb.isomaterialanalyzedtypes(isomatanaltypeid) ON DELETE SET NULL"
        },
        {
            "table": "ndb.isometadata",
            "columns": [
                "isosubstratetypeid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.isosubstratetypes",
            "parent_columns": [
                "isosubstratetypeid"
            ],
            "parent_cardinality": "zero_or_one",
            "def": "FOREIGN KEY (isosubstratetypeid) REFERENCES ndb.isosubstratetypes(isosubstratetypeid) ON UPDATE CASCADE ON DELETE SET NULL"
        },
        {
            "table": "ndb.isosamplepretreatments",
            "columns": [
                "dataid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.data",
            "parent_columns": [
                "dataid"
            ],
            "parent_cardinality": "exactly_one",
            "def": "FOREIGN KEY (dataid) REFERENCES ndb.data(dataid) ON UPDATE CASCADE ON DELETE CASCADE"
        },
        {
            "table": "ndb.isosamplepretreatments",
            "columns": [
                "isopretreatmenttypeid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.isopretreatmenttypes",
            "parent_columns": [
                "isopretreatmenttypeid"
            ],
            "parent_cardinality": "exactly_one",
            "def": "FOREIGN KEY (isopretreatmenttypeid) REFERENCES ndb.isopretreatmenttypes(isopretreatmenttypeid) ON UPDATE CASCADE ON DELETE CASCADE"
        },
        {
            "table": "ndb.isospecimendata",
            "columns": [
                "dataid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.data",
            "parent_columns": [
                "dataid"
            ],
            "parent_cardinality": "exactly_one",
            "def": "FOREIGN KEY (dataid) REFERENCES ndb.data(dataid) ON UPDATE CASCADE ON DELETE CASCADE"
        },
        {
            "table": "ndb.isospecimendata",
            "columns": [
                "specimenid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.specimens",
            "parent_columns": [
                "specimenid"
            ],
            "parent_cardinality": "exactly_one",
            "def": "FOREIGN KEY (specimenid) REFERENCES ndb.specimens(specimenid) ON DELETE CASCADE"
        },
        {
            "table": "ndb.isosrmetadata",
            "columns": [
                "datasetid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.datasets",
            "parent_columns": [
                "datasetid"
            ],
            "parent_cardinality": "exactly_one",
            "def": "FOREIGN KEY (datasetid) REFERENCES ndb.datasets(datasetid) ON UPDATE CASCADE ON DELETE CASCADE"
        },
        {
            "table": "ndb.isosrmetadata",
            "columns": [
                "variableid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.variables",
            "parent_columns": [
                "variableid"
            ],
            "parent_cardinality": "exactly_one",
            "def": "FOREIGN KEY (variableid) REFERENCES ndb.variables(variableid) ON UPDATE CASCADE ON DELETE CASCADE"
        },
        {
            "table": "ndb.isostandards",
            "columns": [
                "datasetid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.datasets",
            "parent_columns": [
                "datasetid"
            ],
            "parent_cardinality": "exactly_one",
            "def": "FOREIGN KEY (datasetid) REFERENCES ndb.datasets(datasetid) ON UPDATE CASCADE ON DELETE CASCADE"
        },
        {
            "table": "ndb.isostandards",
            "columns": [
                "isostandardid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.isostandardtypes",
            "parent_columns": [
                "isostandardtypeid"
            ],
            "parent_cardinality": "exactly_one",
            "def": "FOREIGN KEY (isostandardid) REFERENCES ndb.isostandardtypes(isostandardtypeid) ON UPDATE CASCADE ON DELETE CASCADE"
        },
        {
            "table": "ndb.isostandards",
            "columns": [
                "variableid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.variables",
            "parent_columns": [
                "variableid"
            ],
            "parent_cardinality": "exactly_one",
            "def": "FOREIGN KEY (variableid) REFERENCES ndb.variables(variableid) ON UPDATE CASCADE ON DELETE CASCADE"
        },
        {
            "table": "ndb.isostratdata",
            "columns": [
                "dataid"
            ],
            "cardinality": "zero_or_one",
            "parent_table": "ndb.data",
            "parent_columns": [
                "dataid"
            ],
            "parent_cardinality": "exactly_one",
            "def": "FOREIGN KEY (dataid) REFERENCES ndb.data(dataid) ON UPDATE CASCADE ON DELETE CASCADE"
        },
        {
            "table": "ndb.isostratdata",
            "columns": [
                "elementtypeid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.elementtypes",
            "parent_columns": [
                "elementtypeid"
            ],
            "parent_cardinality": "zero_or_one",
            "def": "FOREIGN KEY (elementtypeid) REFERENCES ndb.elementtypes(elementtypeid) ON UPDATE CASCADE ON DELETE CASCADE"
        },
        {
            "table": "ndb.isostratdata",
            "columns": [
                "taxonid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.taxa",
            "parent_columns": [
                "taxonid"
            ],
            "parent_cardinality": "zero_or_one",
            "def": "FOREIGN KEY (taxonid) REFERENCES ndb.taxa(taxonid)"
        },
        {
            "table": "ndb.isovariablescaletypes",
            "columns": [
                "isoscaletypeid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.isoscaletypes",
            "parent_columns": [
                "isoscaletypeid"
            ],
            "parent_cardinality": "exactly_one",
            "def": "FOREIGN KEY (isoscaletypeid) REFERENCES ndb.isoscaletypes(isoscaletypeid) ON UPDATE CASCADE ON DELETE CASCADE"
        },
        {
            "table": "ndb.isovariablescaletypes",
            "columns": [
                "variableid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.variables",
            "parent_columns": [
                "variableid"
            ],
            "parent_cardinality": "exactly_one",
            "def": "FOREIGN KEY (variableid) REFERENCES ndb.variables(variableid) ON UPDATE CASCADE ON DELETE CASCADE"
        },
        {
            "table": "ndb.lakeparameters",
            "columns": [
                "lakeparameterid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.lakeparametertypes",
            "parent_columns": [
                "lakeparameterid"
            ],
            "parent_cardinality": "exactly_one",
            "def": "FOREIGN KEY (lakeparameterid) REFERENCES ndb.lakeparametertypes(lakeparameterid) ON UPDATE CASCADE ON DELETE CASCADE"
        },
        {
            "table": "ndb.lakeparameters",
            "columns": [
                "siteid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.sites",
            "parent_columns": [
                "siteid"
            ],
            "parent_cardinality": "exactly_one",
            "def": "FOREIGN KEY (siteid) REFERENCES ndb.sites(siteid) ON UPDATE CASCADE ON DELETE CASCADE"
        },
        {
            "table": "ndb.lithology",
            "columns": [
                "collectionunitid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.collectionunits",
            "parent_columns": [
                "collectionunitid"
            ],
            "parent_cardinality": "exactly_one",
            "def": "FOREIGN KEY (collectionunitid) REFERENCES ndb.collectionunits(collectionunitid) ON UPDATE CASCADE ON DELETE CASCADE"
        },
        {
            "table": "ndb.lithostrat",
            "columns": [
                "higherlithostratid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.lithostrat",
            "parent_columns": [
                "lithostratid"
            ],
            "parent_cardinality": "exactly_one",
            "def": "FOREIGN KEY (higherlithostratid) REFERENCES ndb.lithostrat(lithostratid)"
        },
        {
            "table": "ndb.lithostrat",
            "columns": [
                "lithostratunitid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.lithostratunits",
            "parent_columns": [
                "lithostratunitid"
            ],
            "parent_cardinality": "exactly_one",
            "def": "FOREIGN KEY (lithostratunitid) REFERENCES ndb.lithostratunits(lithostratunitid) ON UPDATE CASCADE ON DELETE CASCADE"
        },
        {
            "table": "ndb.publicationeditors",
            "columns": [
                "publicationid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.publications",
            "parent_columns": [
                "publicationid"
            ],
            "parent_cardinality": "exactly_one",
            "def": "FOREIGN KEY (publicationid) REFERENCES ndb.publications(publicationid) ON UPDATE CASCADE ON DELETE CASCADE"
        },
        {
            "table": "ndb.publicationtranslators",
            "columns": [
                "publicationid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.publications",
            "parent_columns": [
                "publicationid"
            ],
            "parent_cardinality": "exactly_one",
            "def": "FOREIGN KEY (publicationid) REFERENCES ndb.publications(publicationid) ON UPDATE CASCADE ON DELETE CASCADE"
        },
        {
            "table": "ndb.radiocarbon",
            "columns": [
                "geochronid"
            ],
            "cardinality": "zero_or_one",
            "parent_table": "ndb.geochronology",
            "parent_columns": [
                "geochronid"
            ],
            "parent_cardinality": "exactly_one",
            "def": "FOREIGN KEY (geochronid) REFERENCES ndb.geochronology(geochronid) ON DELETE CASCADE"
        },
        {
            "table": "ndb.radiocarbon",
            "columns": [
                "radiocarbonmethodid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.radiocarbonmethods",
            "parent_columns": [
                "radiocarbonmethodid"
            ],
            "parent_cardinality": "zero_or_one",
            "def": "FOREIGN KEY (radiocarbonmethodid) REFERENCES ndb.radiocarbonmethods(radiocarbonmethodid)"
        },
        {
            "table": "ndb.relativeagepublications",
            "columns": [
                "publicationid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.publications",
            "parent_columns": [
                "publicationid"
            ],
            "parent_cardinality": "exactly_one",
            "def": "FOREIGN KEY (publicationid) REFERENCES ndb.publications(publicationid) ON UPDATE CASCADE ON DELETE CASCADE"
        },
        {
            "table": "ndb.relativeagepublications",
            "columns": [
                "relativeageid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.relativeages",
            "parent_columns": [
                "relativeageid"
            ],
            "parent_cardinality": "exactly_one",
            "def": "FOREIGN KEY (relativeageid) REFERENCES ndb.relativeages(relativeageid) ON UPDATE CASCADE ON DELETE CASCADE"
        },
        {
            "table": "ndb.relativeages",
            "columns": [
                "relativeagescaleid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.relativeagescales",
            "parent_columns": [
                "relativeagescaleid"
            ],
            "parent_cardinality": "exactly_one",
            "def": "FOREIGN KEY (relativeagescaleid) REFERENCES ndb.relativeagescales(relativeagescaleid) ON UPDATE CASCADE ON DELETE CASCADE"
        },
        {
            "table": "ndb.relativeages",
            "columns": [
                "relativeageunitid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.relativeageunits",
            "parent_columns": [
                "relativeageunitid"
            ],
            "parent_cardinality": "exactly_one",
            "def": "FOREIGN KEY (relativeageunitid) REFERENCES ndb.relativeageunits(relativeageunitid) ON UPDATE CASCADE ON DELETE CASCADE"
        },
        {
            "table": "ndb.relativechronology",
            "columns": [
                "analysisunitid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.analysisunits",
            "parent_columns": [
                "analysisunitid"
            ],
            "parent_cardinality": "exactly_one",
            "def": "FOREIGN KEY (analysisunitid) REFERENCES ndb.analysisunits(analysisunitid) ON UPDATE CASCADE ON DELETE CASCADE"
        },
        {
            "table": "ndb.relativechronology",
            "columns": [
                "chroncontrolid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.chroncontrols",
            "parent_columns": [
                "chroncontrolid"
            ],
            "parent_cardinality": "zero_or_one",
            "def": "FOREIGN KEY (chroncontrolid) REFERENCES ndb.chroncontrols(chroncontrolid) ON UPDATE CASCADE ON DELETE CASCADE"
        },
        {
            "table": "ndb.relativechronology",
            "columns": [
                "relativeageid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.relativeages",
            "parent_columns": [
                "relativeageid"
            ],
            "parent_cardinality": "exactly_one",
            "def": "FOREIGN KEY (relativeageid) REFERENCES ndb.relativeages(relativeageid) ON UPDATE CASCADE ON DELETE CASCADE"
        },
        {
            "table": "ndb.repositoryspecimens",
            "columns": [
                "datasetid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.datasets",
            "parent_columns": [
                "datasetid"
            ],
            "parent_cardinality": "exactly_one",
            "def": "FOREIGN KEY (datasetid) REFERENCES ndb.datasets(datasetid) ON UPDATE CASCADE ON DELETE CASCADE"
        },
        {
            "table": "ndb.repositoryspecimens",
            "columns": [
                "repositoryid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.repositoryinstitutions",
            "parent_columns": [
                "repositoryid"
            ],
            "parent_cardinality": "exactly_one",
            "def": "FOREIGN KEY (repositoryid) REFERENCES ndb.repositoryinstitutions(repositoryid)"
        },
        {
            "table": "ndb.rocktypes",
            "columns": [
                "higherrocktypeid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.rocktypes",
            "parent_columns": [
                "rocktypeid"
            ],
            "parent_cardinality": "exactly_one",
            "def": "FOREIGN KEY (higherrocktypeid) REFERENCES ndb.rocktypes(rocktypeid)"
        },
        {
            "table": "ndb.sampleanalysts",
            "columns": [
                "contactid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.contacts",
            "parent_columns": [
                "contactid"
            ],
            "parent_cardinality": "exactly_one",
            "def": "FOREIGN KEY (contactid) REFERENCES ndb.contacts(contactid) ON UPDATE CASCADE"
        },
        {
            "table": "ndb.sampleanalysts",
            "columns": [
                "sampleid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.samples",
            "parent_columns": [
                "sampleid"
            ],
            "parent_cardinality": "exactly_one",
            "def": "FOREIGN KEY (sampleid) REFERENCES ndb.samples(sampleid) ON UPDATE CASCADE ON DELETE CASCADE"
        },
        {
            "table": "ndb.siteimages",
            "columns": [
                "contactid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.contacts",
            "parent_columns": [
                "contactid"
            ],
            "parent_cardinality": "zero_or_one",
            "def": "FOREIGN KEY (contactid) REFERENCES ndb.contacts(contactid) ON UPDATE CASCADE"
        },
        {
            "table": "ndb.siteimages",
            "columns": [
                "siteid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.sites",
            "parent_columns": [
                "siteid"
            ],
            "parent_cardinality": "zero_or_one",
            "def": "FOREIGN KEY (siteid) REFERENCES ndb.sites(siteid) ON UPDATE CASCADE ON DELETE CASCADE"
        },
        {
            "table": "ndb.specimendates",
            "columns": [
                "elementtypeid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.elementtypes",
            "parent_columns": [
                "elementtypeid"
            ],
            "parent_cardinality": "zero_or_one",
            "def": "FOREIGN KEY (elementtypeid) REFERENCES ndb.elementtypes(elementtypeid)"
        },
        {
            "table": "ndb.specimendates",
            "columns": [
                "fractionid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.fractiondated",
            "parent_columns": [
                "fractionid"
            ],
            "parent_cardinality": "zero_or_one",
            "def": "FOREIGN KEY (fractionid) REFERENCES ndb.fractiondated(fractionid)"
        },
        {
            "table": "ndb.specimendates",
            "columns": [
                "geochronid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.geochronology",
            "parent_columns": [
                "geochronid"
            ],
            "parent_cardinality": "exactly_one",
            "def": "FOREIGN KEY (geochronid) REFERENCES ndb.geochronology(geochronid) ON UPDATE CASCADE ON DELETE CASCADE"
        },
        {
            "table": "ndb.specimendates",
            "columns": [
                "sampleid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.samples",
            "parent_columns": [
                "sampleid"
            ],
            "parent_cardinality": "exactly_one",
            "def": "FOREIGN KEY (sampleid) REFERENCES ndb.samples(sampleid) ON UPDATE CASCADE ON DELETE CASCADE"
        },
        {
            "table": "ndb.specimendates",
            "columns": [
                "specimenid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.specimens",
            "parent_columns": [
                "specimenid"
            ],
            "parent_cardinality": "zero_or_one",
            "def": "FOREIGN KEY (specimenid) REFERENCES ndb.specimens(specimenid) ON UPDATE CASCADE ON DELETE CASCADE"
        },
        {
            "table": "ndb.specimendates",
            "columns": [
                "taxonid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.taxa",
            "parent_columns": [
                "taxonid"
            ],
            "parent_cardinality": "exactly_one",
            "def": "FOREIGN KEY (taxonid) REFERENCES ndb.taxa(taxonid)"
        },
        {
            "table": "ndb.specimendatescal",
            "columns": [
                "calibrationcurveid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.calibrationcurves",
            "parent_columns": [
                "calibrationcurveid"
            ],
            "parent_cardinality": "zero_or_one",
            "def": "FOREIGN KEY (calibrationcurveid) REFERENCES ndb.calibrationcurves(calibrationcurveid) ON UPDATE CASCADE ON DELETE CASCADE"
        },
        {
            "table": "ndb.specimendatescal",
            "columns": [
                "calibrationprogramid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.calibrationprograms",
            "parent_columns": [
                "calibrationprogramid"
            ],
            "parent_cardinality": "zero_or_one",
            "def": "FOREIGN KEY (calibrationprogramid) REFERENCES ndb.calibrationprograms(calibrationprogramid) ON UPDATE CASCADE ON DELETE CASCADE"
        },
        {
            "table": "ndb.specimendatescal",
            "columns": [
                "specimendateid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.specimendates",
            "parent_columns": [
                "specimendateid"
            ],
            "parent_cardinality": "exactly_one",
            "def": "FOREIGN KEY (specimendateid) REFERENCES ndb.specimendates(specimendateid) ON UPDATE CASCADE ON DELETE CASCADE"
        },
        {
            "table": "ndb.specimengenbank",
            "columns": [
                "specimenid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.specimens",
            "parent_columns": [
                "specimenid"
            ],
            "parent_cardinality": "exactly_one",
            "def": "FOREIGN KEY (specimenid) REFERENCES ndb.specimens(specimenid) ON UPDATE CASCADE ON DELETE CASCADE"
        },
        {
            "table": "ndb.specimens",
            "columns": [
                "dataid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.data",
            "parent_columns": [
                "dataid"
            ],
            "parent_cardinality": "exactly_one",
            "def": "FOREIGN KEY (dataid) REFERENCES ndb.data(dataid) ON UPDATE CASCADE ON DELETE CASCADE"
        },
        {
            "table": "ndb.specimens",
            "columns": [
                "maturityid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.elementmaturities",
            "parent_columns": [
                "maturityid"
            ],
            "parent_cardinality": "zero_or_one",
            "def": "FOREIGN KEY (maturityid) REFERENCES ndb.elementmaturities(maturityid)"
        },
        {
            "table": "ndb.specimens",
            "columns": [
                "portionid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.elementportions",
            "parent_columns": [
                "portionid"
            ],
            "parent_cardinality": "zero_or_one",
            "def": "FOREIGN KEY (portionid) REFERENCES ndb.elementportions(portionid)"
        },
        {
            "table": "ndb.specimens",
            "columns": [
                "symmetryid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.elementsymmetries",
            "parent_columns": [
                "symmetryid"
            ],
            "parent_cardinality": "zero_or_one",
            "def": "FOREIGN KEY (symmetryid) REFERENCES ndb.elementsymmetries(symmetryid)"
        },
        {
            "table": "ndb.specimens",
            "columns": [
                "elementtypeid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.elementtypes",
            "parent_columns": [
                "elementtypeid"
            ],
            "parent_cardinality": "zero_or_one",
            "def": "FOREIGN KEY (elementtypeid) REFERENCES ndb.elementtypes(elementtypeid) ON UPDATE CASCADE ON DELETE CASCADE"
        },
        {
            "table": "ndb.specimens",
            "columns": [
                "repositoryid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.repositoryinstitutions",
            "parent_columns": [
                "repositoryid"
            ],
            "parent_cardinality": "zero_or_one",
            "def": "FOREIGN KEY (repositoryid) REFERENCES ndb.repositoryinstitutions(repositoryid) ON UPDATE CASCADE ON DELETE CASCADE"
        },
        {
            "table": "ndb.specimens",
            "columns": [
                "domesticstatusid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.specimendomesticstatustypes",
            "parent_columns": [
                "domesticstatusid"
            ],
            "parent_cardinality": "zero_or_one",
            "def": "FOREIGN KEY (domesticstatusid) REFERENCES ndb.specimendomesticstatustypes(domesticstatusid) ON UPDATE CASCADE ON DELETE CASCADE"
        },
        {
            "table": "ndb.specimens",
            "columns": [
                "sexid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.specimensextypes",
            "parent_columns": [
                "sexid"
            ],
            "parent_cardinality": "zero_or_one",
            "def": "FOREIGN KEY (sexid) REFERENCES ndb.specimensextypes(sexid) ON UPDATE CASCADE ON DELETE CASCADE"
        },
        {
            "table": "ndb.specimentaphonomy",
            "columns": [
                "specimenid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.specimens",
            "parent_columns": [
                "specimenid"
            ],
            "parent_cardinality": "exactly_one",
            "def": "FOREIGN KEY (specimenid) REFERENCES ndb.specimens(specimenid) ON UPDATE CASCADE ON DELETE CASCADE"
        },
        {
            "table": "ndb.specimentaphonomy",
            "columns": [
                "taphonomictypeid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.taphonomictypes",
            "parent_columns": [
                "taphonomictypeid"
            ],
            "parent_cardinality": "exactly_one",
            "def": "FOREIGN KEY (taphonomictypeid) REFERENCES ndb.taphonomictypes(taphonomictypeid) ON UPDATE CASCADE ON DELETE CASCADE"
        },
        {
            "table": "ndb.summarydatataphonomy",
            "columns": [
                "dataid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.data",
            "parent_columns": [
                "dataid"
            ],
            "parent_cardinality": "exactly_one",
            "def": "FOREIGN KEY (dataid) REFERENCES ndb.data(dataid) ON UPDATE CASCADE ON DELETE CASCADE"
        },
        {
            "table": "ndb.summarydatataphonomy",
            "columns": [
                "taphonomictypeid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.taphonomictypes",
            "parent_columns": [
                "taphonomictypeid"
            ],
            "parent_cardinality": "exactly_one",
            "def": "FOREIGN KEY (taphonomictypeid) REFERENCES ndb.taphonomictypes(taphonomictypeid) ON UPDATE CASCADE ON DELETE CASCADE"
        },
        {
            "table": "ndb.synonyms",
            "columns": [
                "synonymtypeid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.synonymtypes",
            "parent_columns": [
                "synonymtypeid"
            ],
            "parent_cardinality": "zero_or_one",
            "def": "FOREIGN KEY (synonymtypeid) REFERENCES ndb.synonymtypes(synonymtypeid) ON UPDATE CASCADE ON DELETE CASCADE"
        },
        {
            "table": "ndb.synonyms",
            "columns": [
                "invalidtaxonid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.taxa",
            "parent_columns": [
                "taxonid"
            ],
            "parent_cardinality": "exactly_one",
            "def": "FOREIGN KEY (invalidtaxonid) REFERENCES ndb.taxa(taxonid) ON UPDATE CASCADE ON DELETE CASCADE"
        },
        {
            "table": "ndb.synonyms",
            "columns": [
                "validtaxonid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.taxa",
            "parent_columns": [
                "taxonid"
            ],
            "parent_cardinality": "exactly_one",
            "def": "FOREIGN KEY (validtaxonid) REFERENCES ndb.taxa(taxonid)"
        },
        {
            "table": "ndb.synonymy",
            "columns": [
                "contactid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.contacts",
            "parent_columns": [
                "contactid"
            ],
            "parent_cardinality": "zero_or_one",
            "def": "FOREIGN KEY (contactid) REFERENCES ndb.contacts(contactid)"
        },
        {
            "table": "ndb.synonymy",
            "columns": [
                "datasetid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.datasets",
            "parent_columns": [
                "datasetid"
            ],
            "parent_cardinality": "exactly_one",
            "def": "FOREIGN KEY (datasetid) REFERENCES ndb.datasets(datasetid) ON UPDATE CASCADE ON DELETE CASCADE"
        },
        {
            "table": "ndb.synonymy",
            "columns": [
                "publicationid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.publications",
            "parent_columns": [
                "publicationid"
            ],
            "parent_cardinality": "zero_or_one",
            "def": "FOREIGN KEY (publicationid) REFERENCES ndb.publications(publicationid) ON UPDATE CASCADE ON DELETE CASCADE"
        },
        {
            "table": "ndb.synonymy",
            "columns": [
                "taxonid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.taxa",
            "parent_columns": [
                "taxonid"
            ],
            "parent_cardinality": "exactly_one",
            "def": "FOREIGN KEY (taxonid) REFERENCES ndb.taxa(taxonid) ON UPDATE CASCADE ON DELETE CASCADE"
        },
        {
            "table": "ndb.synonymy",
            "columns": [
                "reftaxonid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.taxa",
            "parent_columns": [
                "taxonid"
            ],
            "parent_cardinality": "exactly_one",
            "def": "FOREIGN KEY (reftaxonid) REFERENCES ndb.taxa(taxonid)"
        },
        {
            "table": "ndb.taphonomicsystemsdatasettypes",
            "columns": [
                "datasettypeid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.datasettypes",
            "parent_columns": [
                "datasettypeid"
            ],
            "parent_cardinality": "exactly_one",
            "def": "FOREIGN KEY (datasettypeid) REFERENCES ndb.datasettypes(datasettypeid) ON UPDATE CASCADE ON DELETE CASCADE"
        },
        {
            "table": "ndb.taphonomicsystemsdatasettypes",
            "columns": [
                "taphonomicsystemid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.taphonomicsystems",
            "parent_columns": [
                "taphonomicsystemid"
            ],
            "parent_cardinality": "exactly_one",
            "def": "FOREIGN KEY (taphonomicsystemid) REFERENCES ndb.taphonomicsystems(taphonomicsystemid) ON UPDATE CASCADE ON DELETE CASCADE"
        },
        {
            "table": "ndb.taphonomictypes",
            "columns": [
                "taphonomicsystemid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.taphonomicsystems",
            "parent_columns": [
                "taphonomicsystemid"
            ],
            "parent_cardinality": "zero_or_one",
            "def": "FOREIGN KEY (taphonomicsystemid) REFERENCES ndb.taphonomicsystems(taphonomicsystemid) ON UPDATE CASCADE ON DELETE CASCADE"
        },
        {
            "table": "ndb.taxaalthierarchy",
            "columns": [
                "taxonid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.taxa",
            "parent_columns": [
                "taxonid"
            ],
            "parent_cardinality": "exactly_one",
            "def": "FOREIGN KEY (taxonid) REFERENCES ndb.taxa(taxonid) ON UPDATE CASCADE ON DELETE CASCADE"
        },
        {
            "table": "ndb.taxaalthierarchy",
            "columns": [
                "highertaxonid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.taxa",
            "parent_columns": [
                "taxonid"
            ],
            "parent_cardinality": "exactly_one",
            "def": "FOREIGN KEY (highertaxonid) REFERENCES ndb.taxa(taxonid)"
        },
        {
            "table": "ndb.taxaalthierarchy",
            "columns": [
                "taxaalthierarchytypeid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.taxaalthierarchytypes",
            "parent_columns": [
                "taxaalthierarchytypeid"
            ],
            "parent_cardinality": "exactly_one",
            "def": "FOREIGN KEY (taxaalthierarchytypeid) REFERENCES ndb.taxaalthierarchytypes(taxaalthierarchytypeid) ON UPDATE CASCADE ON DELETE CASCADE"
        },
        {
            "table": "ndb.taxonpaths",
            "columns": [
                "taxonid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.taxa",
            "parent_columns": [
                "taxonid"
            ],
            "parent_cardinality": "exactly_one",
            "def": "FOREIGN KEY (taxonid) REFERENCES ndb.taxa(taxonid) ON DELETE CASCADE"
        },
        {
            "table": "ndb.tephras",
            "columns": [
                "analysisunitid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.analysisunits",
            "parent_columns": [
                "analysisunitid"
            ],
            "parent_cardinality": "exactly_one",
            "def": "FOREIGN KEY (analysisunitid) REFERENCES ndb.analysisunits(analysisunitid) ON UPDATE CASCADE ON DELETE CASCADE"
        },
        {
            "table": "ndb.tephras",
            "columns": [
                "eventid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.events",
            "parent_columns": [
                "eventid"
            ],
            "parent_cardinality": "exactly_one",
            "def": "FOREIGN KEY (eventid) REFERENCES ndb.events(eventid) ON UPDATE CASCADE ON DELETE CASCADE"
        },
        {
            "table": "ndb.variableelements",
            "columns": [
                "maturityid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.elementmaturities",
            "parent_columns": [
                "maturityid"
            ],
            "parent_cardinality": "zero_or_one",
            "def": "FOREIGN KEY (maturityid) REFERENCES ndb.elementmaturities(maturityid) ON UPDATE CASCADE ON DELETE CASCADE"
        },
        {
            "table": "ndb.variableelements",
            "columns": [
                "portionid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.elementportions",
            "parent_columns": [
                "portionid"
            ],
            "parent_cardinality": "zero_or_one",
            "def": "FOREIGN KEY (portionid) REFERENCES ndb.elementportions(portionid) ON UPDATE CASCADE ON DELETE CASCADE"
        },
        {
            "table": "ndb.variableelements",
            "columns": [
                "symmetryid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.elementsymmetries",
            "parent_columns": [
                "symmetryid"
            ],
            "parent_cardinality": "zero_or_one",
            "def": "FOREIGN KEY (symmetryid) REFERENCES ndb.elementsymmetries(symmetryid) ON UPDATE CASCADE ON DELETE CASCADE"
        },
        {
            "table": "ndb.variableelements",
            "columns": [
                "elementtypeid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.elementtypes",
            "parent_columns": [
                "elementtypeid"
            ],
            "parent_cardinality": "zero_or_one",
            "def": "FOREIGN KEY (elementtypeid) REFERENCES ndb.elementtypes(elementtypeid)"
        },
        {
            "table": "ti.stewarddatabases",
            "columns": [
                "databaseid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.constituentdatabases",
            "parent_columns": [
                "databaseid"
            ],
            "parent_cardinality": "exactly_one",
            "def": "FOREIGN KEY (databaseid) REFERENCES ndb.constituentdatabases(databaseid) ON UPDATE CASCADE ON DELETE CASCADE"
        },
        {
            "table": "ti.stewarddatabases",
            "columns": [
                "stewardid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ti.stewards",
            "parent_columns": [
                "stewardid"
            ],
            "parent_cardinality": "exactly_one",
            "def": "FOREIGN KEY (stewardid) REFERENCES ti.stewards(stewardid) ON UPDATE CASCADE ON DELETE CASCADE"
        },
        {
            "table": "ti.stewards",
            "columns": [
                "contactid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.contacts",
            "parent_columns": [
                "contactid"
            ],
            "parent_cardinality": "exactly_one",
            "def": "FOREIGN KEY (contactid) REFERENCES ndb.contacts(contactid) ON UPDATE CASCADE"
        },
        {
            "table": "ti.stewardupdates",
            "columns": [
                "contactid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.contacts",
            "parent_columns": [
                "contactid"
            ],
            "parent_cardinality": "exactly_one",
            "def": "FOREIGN KEY (contactid) REFERENCES ndb.contacts(contactid)"
        },
        {
            "table": "ndb.datauncertainties",
            "columns": [
                "dataid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.data",
            "parent_columns": [
                "dataid"
            ],
            "parent_cardinality": "zero_or_one",
            "def": "FOREIGN KEY (dataid) REFERENCES ndb.data(dataid) ON DELETE CASCADE"
        },
        {
            "table": "ndb.datauncertainties",
            "columns": [
                "uncertaintyunitid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.variableunits",
            "parent_columns": [
                "variableunitsid"
            ],
            "parent_cardinality": "zero_or_one",
            "def": "FOREIGN KEY (uncertaintyunitid) REFERENCES ndb.variableunits(variableunitsid)"
        },
        {
            "table": "ndb.datauncertainties",
            "columns": [
                "uncertaintybasisid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.uncertaintybases",
            "parent_columns": [
                "uncertaintybasisid"
            ],
            "parent_cardinality": "zero_or_one",
            "def": "FOREIGN KEY (uncertaintybasisid) REFERENCES ndb.uncertaintybases(uncertaintybasisid)"
        },
        {
            "table": "ndb.leadmodels",
            "columns": [
                "analysisunitid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.analysisunits",
            "parent_columns": [
                "analysisunitid"
            ],
            "parent_cardinality": "zero_or_one",
            "def": "FOREIGN KEY (analysisunitid) REFERENCES ndb.analysisunits(analysisunitid)"
        },
        {
            "table": "ndb.leadmodels",
            "columns": [
                "pbbasisid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.leadmodelbasis",
            "parent_columns": [
                "pbbasisid"
            ],
            "parent_cardinality": "zero_or_one",
            "def": "FOREIGN KEY (pbbasisid) REFERENCES ndb.leadmodelbasis(pbbasisid)"
        },
        {
            "table": "ndb.speleothemtypes",
            "columns": [
                "speleothemtypepublicationid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.publications",
            "parent_columns": [
                "publicationid"
            ],
            "parent_cardinality": "zero_or_one",
            "def": "FOREIGN KEY (speleothemtypepublicationid) REFERENCES ndb.publications(publicationid)"
        },
        {
            "table": "ndb.speleothemdriptypes",
            "columns": [
                "speleothemdriptypepublicationid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.publications",
            "parent_columns": [
                "publicationid"
            ],
            "parent_cardinality": "zero_or_one",
            "def": "FOREIGN KEY (speleothemdriptypepublicationid) REFERENCES ndb.publications(publicationid)"
        },
        {
            "table": "ndb.vegetationcovertypes",
            "columns": [
                "vegetationpublicationid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.publications",
            "parent_columns": [
                "publicationid"
            ],
            "parent_cardinality": "zero_or_one",
            "def": "FOREIGN KEY (vegetationpublicationid) REFERENCES ndb.publications(publicationid)"
        },
        {
            "table": "ndb.sitevegetationcover",
            "columns": [
                "siteid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.sites",
            "parent_columns": [
                "siteid"
            ],
            "parent_cardinality": "zero_or_one",
            "def": "FOREIGN KEY (siteid) REFERENCES ndb.sites(siteid) ON DELETE CASCADE"
        },
        {
            "table": "ndb.sitevegetationcover",
            "columns": [
                "vegetationcovertypeid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.vegetationcovertypes",
            "parent_columns": [
                "vegetationcovertypeid"
            ],
            "parent_cardinality": "zero_or_one",
            "def": "FOREIGN KEY (vegetationcovertypeid) REFERENCES ndb.vegetationcovertypes(vegetationcovertypeid) ON DELETE CASCADE"
        },
        {
            "table": "ndb.landusetypes",
            "columns": [
                "publicationid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.publications",
            "parent_columns": [
                "publicationid"
            ],
            "parent_cardinality": "zero_or_one",
            "def": "FOREIGN KEY (publicationid) REFERENCES ndb.publications(publicationid)"
        },
        {
            "table": "ndb.sitelandusecover",
            "columns": [
                "siteid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.sites",
            "parent_columns": [
                "siteid"
            ],
            "parent_cardinality": "zero_or_one",
            "def": "FOREIGN KEY (siteid) REFERENCES ndb.sites(siteid) ON DELETE CASCADE"
        },
        {
            "table": "ndb.sitelandusecover",
            "columns": [
                "landusecovertypeid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.vegetationcovertypes",
            "parent_columns": [
                "vegetationcovertypeid"
            ],
            "parent_cardinality": "zero_or_one",
            "def": "FOREIGN KEY (landusecovertypeid) REFERENCES ndb.vegetationcovertypes(vegetationcovertypeid) ON DELETE CASCADE"
        },
        {
            "table": "ndb.depthreferencesystem",
            "columns": [
                "depthreferencepublicationid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.publications",
            "parent_columns": [
                "publicationid"
            ],
            "parent_cardinality": "zero_or_one",
            "def": "FOREIGN KEY (depthreferencepublicationid) REFERENCES ndb.publications(publicationid)"
        },
        {
            "table": "ndb.speleothementitygeology",
            "columns": [
                "speleothemgeologypublicationid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.publications",
            "parent_columns": [
                "publicationid"
            ],
            "parent_cardinality": "zero_or_one",
            "def": "FOREIGN KEY (speleothemgeologypublicationid) REFERENCES ndb.publications(publicationid)"
        },
        {
            "table": "ndb.speleothems",
            "columns": [
                "rockageid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.relativeages",
            "parent_columns": [
                "relativeageid"
            ],
            "parent_cardinality": "zero_or_one",
            "def": "FOREIGN KEY (rockageid) REFERENCES ndb.relativeages(relativeageid)"
        },
        {
            "table": "ndb.speleothems",
            "columns": [
                "siteid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.sites",
            "parent_columns": [
                "siteid"
            ],
            "parent_cardinality": "zero_or_one",
            "def": "FOREIGN KEY (siteid) REFERENCES ndb.sites(siteid) ON DELETE CASCADE"
        },
        {
            "table": "ndb.speleothems",
            "columns": [
                "entrancedistanceunits"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.variableunits",
            "parent_columns": [
                "variableunitsid"
            ],
            "parent_cardinality": "zero_or_one",
            "def": "FOREIGN KEY (entrancedistanceunits) REFERENCES ndb.variableunits(variableunitsid)"
        },
        {
            "table": "ndb.speleothems",
            "columns": [
                "speleothemtypeid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.speleothemtypes",
            "parent_columns": [
                "speleothemtypeid"
            ],
            "parent_cardinality": "zero_or_one",
            "def": "FOREIGN KEY (speleothemtypeid) REFERENCES ndb.speleothemtypes(speleothemtypeid)"
        },
        {
            "table": "ndb.entityrelationship",
            "columns": [
                "entitystatusid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.speleothementitystatuses",
            "parent_columns": [
                "entitystatusid"
            ],
            "parent_cardinality": "zero_or_one",
            "def": "FOREIGN KEY (entitystatusid) REFERENCES ndb.speleothementitystatuses(entitystatusid)"
        },
        {
            "table": "ndb.entityrelationship",
            "columns": [
                "entityid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.speleothems",
            "parent_columns": [
                "entityid"
            ],
            "parent_cardinality": "zero_or_one",
            "def": "FOREIGN KEY (entityid) REFERENCES ndb.speleothems(entityid)"
        },
        {
            "table": "ndb.entityrelationship",
            "columns": [
                "referenceentityid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.speleothems",
            "parent_columns": [
                "entityid"
            ],
            "parent_cardinality": "zero_or_one",
            "def": "FOREIGN KEY (referenceentityid) REFERENCES ndb.speleothems(entityid)"
        },
        {
            "table": "ndb.entitydripheight",
            "columns": [
                "entitydripheightunit"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.variableunits",
            "parent_columns": [
                "variableunitsid"
            ],
            "parent_cardinality": "zero_or_one",
            "def": "FOREIGN KEY (entitydripheightunit) REFERENCES ndb.variableunits(variableunitsid)"
        },
        {
            "table": "ndb.entitydripheight",
            "columns": [
                "speleothemdriptypeid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.speleothemdriptypes",
            "parent_columns": [
                "speleothemdriptypeid"
            ],
            "parent_cardinality": "zero_or_one",
            "def": "FOREIGN KEY (speleothemdriptypeid) REFERENCES ndb.speleothemdriptypes(speleothemdriptypeid)"
        },
        {
            "table": "ndb.entitydripheight",
            "columns": [
                "entityid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.speleothems",
            "parent_columns": [
                "entityid"
            ],
            "parent_cardinality": "zero_or_one",
            "def": "FOREIGN KEY (entityid) REFERENCES ndb.speleothems(entityid) ON DELETE CASCADE"
        },
        {
            "table": "ndb.entityvegetationcover",
            "columns": [
                "vegetationcovertypeid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.vegetationcovertypes",
            "parent_columns": [
                "vegetationcovertypeid"
            ],
            "parent_cardinality": "zero_or_one",
            "def": "FOREIGN KEY (vegetationcovertypeid) REFERENCES ndb.vegetationcovertypes(vegetationcovertypeid) ON DELETE CASCADE"
        },
        {
            "table": "ndb.entityvegetationcover",
            "columns": [
                "entityid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.speleothems",
            "parent_columns": [
                "entityid"
            ],
            "parent_cardinality": "zero_or_one",
            "def": "FOREIGN KEY (entityid) REFERENCES ndb.speleothems(entityid) ON DELETE CASCADE"
        },
        {
            "table": "ndb.entitylandusecover",
            "columns": [
                "landusecovertypeid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.vegetationcovertypes",
            "parent_columns": [
                "vegetationcovertypeid"
            ],
            "parent_cardinality": "zero_or_one",
            "def": "FOREIGN KEY (landusecovertypeid) REFERENCES ndb.vegetationcovertypes(vegetationcovertypeid) ON DELETE CASCADE"
        },
        {
            "table": "ndb.entitylandusecover",
            "columns": [
                "entityid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.speleothems",
            "parent_columns": [
                "entityid"
            ],
            "parent_cardinality": "zero_or_one",
            "def": "FOREIGN KEY (entityid) REFERENCES ndb.speleothems(entityid) ON DELETE CASCADE"
        },
        {
            "table": "ndb.entitycovers",
            "columns": [
                "entitycoverunits"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.variableunits",
            "parent_columns": [
                "variableunitsid"
            ],
            "parent_cardinality": "zero_or_one",
            "def": "FOREIGN KEY (entitycoverunits) REFERENCES ndb.variableunits(variableunitsid)"
        },
        {
            "table": "ndb.entitycovers",
            "columns": [
                "entitycoverid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.entitycovertypes",
            "parent_columns": [
                "entitycoverid"
            ],
            "parent_cardinality": "zero_or_one",
            "def": "FOREIGN KEY (entitycoverid) REFERENCES ndb.entitycovertypes(entitycoverid)"
        },
        {
            "table": "ndb.entitycovers",
            "columns": [
                "entityid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.speleothems",
            "parent_columns": [
                "entityid"
            ],
            "parent_cardinality": "zero_or_one",
            "def": "FOREIGN KEY (entityid) REFERENCES ndb.speleothems(entityid) ON DELETE CASCADE"
        },
        {
            "table": "ndb.externalspeleothemdata",
            "columns": [
                "extdatabaseid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.externaldatabases",
            "parent_columns": [
                "extdatabaseid"
            ],
            "parent_cardinality": "zero_or_one",
            "def": "FOREIGN KEY (extdatabaseid) REFERENCES ndb.externaldatabases(extdatabaseid)"
        },
        {
            "table": "ndb.externalspeleothemdata",
            "columns": [
                "entityid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.speleothems",
            "parent_columns": [
                "entityid"
            ],
            "parent_cardinality": "zero_or_one",
            "def": "FOREIGN KEY (entityid) REFERENCES ndb.speleothems(entityid) ON DELETE CASCADE"
        },
        {
            "table": "ndb.externalcontacts",
            "columns": [
                "contactid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.contacts",
            "parent_columns": [
                "contactid"
            ],
            "parent_cardinality": "zero_or_one",
            "def": "FOREIGN KEY (contactid) REFERENCES ndb.contacts(contactid)"
        },
        {
            "table": "ndb.externalcontacts",
            "columns": [
                "extdatabaseid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.externaldatabases",
            "parent_columns": [
                "extdatabaseid"
            ],
            "parent_cardinality": "zero_or_one",
            "def": "FOREIGN KEY (extdatabaseid) REFERENCES ndb.externaldatabases(extdatabaseid)"
        },
        {
            "table": "ndb.speleothemcollectionunit",
            "columns": [
                "collectionunitid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.collectionunits",
            "parent_columns": [
                "collectionunitid"
            ],
            "parent_cardinality": "zero_or_one",
            "def": "FOREIGN KEY (collectionunitid) REFERENCES ndb.collectionunits(collectionunitid) ON DELETE CASCADE"
        },
        {
            "table": "ndb.speleothemcollectionunit",
            "columns": [
                "entityid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.speleothems",
            "parent_columns": [
                "entityid"
            ],
            "parent_cardinality": "zero_or_one",
            "def": "FOREIGN KEY (entityid) REFERENCES ndb.speleothems(entityid) ON DELETE CASCADE"
        },
        {
            "table": "ndb.entitygeology",
            "columns": [
                "speleothemgeologyid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.speleothementitygeology",
            "parent_columns": [
                "speleothemgeologyid"
            ],
            "parent_cardinality": "zero_or_one",
            "def": "FOREIGN KEY (speleothemgeologyid) REFERENCES ndb.speleothementitygeology(speleothemgeologyid)"
        },
        {
            "table": "ndb.entitygeology",
            "columns": [
                "entityid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.speleothems",
            "parent_columns": [
                "entityid"
            ],
            "parent_cardinality": "zero_or_one",
            "def": "FOREIGN KEY (entityid) REFERENCES ndb.speleothems(entityid) ON DELETE CASCADE"
        },
        {
            "table": "ndb.hiatuses",
            "columns": [
                "analysisunitend"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.analysisunits",
            "parent_columns": [
                "analysisunitid"
            ],
            "parent_cardinality": "zero_or_one",
            "def": "FOREIGN KEY (analysisunitend) REFERENCES ndb.analysisunits(analysisunitid)"
        },
        {
            "table": "ndb.hiatuses",
            "columns": [
                "analysisunitstart"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.analysisunits",
            "parent_columns": [
                "analysisunitid"
            ],
            "parent_cardinality": "zero_or_one",
            "def": "FOREIGN KEY (analysisunitstart) REFERENCES ndb.analysisunits(analysisunitid)"
        },
        {
            "table": "ndb.hiatuschronology",
            "columns": [
                "chronologyid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.chronologies",
            "parent_columns": [
                "chronologyid"
            ],
            "parent_cardinality": "zero_or_one",
            "def": "FOREIGN KEY (chronologyid) REFERENCES ndb.chronologies(chronologyid)"
        },
        {
            "table": "ndb.hiatuschronology",
            "columns": [
                "hiatusid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.hiatuses",
            "parent_columns": [
                "hiatusid"
            ],
            "parent_cardinality": "zero_or_one",
            "def": "FOREIGN KEY (hiatusid) REFERENCES ndb.hiatuses(hiatusid)"
        },
        {
            "table": "ndb.externalgeochronology",
            "columns": [
                "extdatabaseid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.externaldatabases",
            "parent_columns": [
                "extdatabaseid"
            ],
            "parent_cardinality": "zero_or_one",
            "def": "FOREIGN KEY (extdatabaseid) REFERENCES ndb.externaldatabases(extdatabaseid)"
        },
        {
            "table": "ndb.externalgeochronology",
            "columns": [
                "geochronid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.geochronology",
            "parent_columns": [
                "geochronid"
            ],
            "parent_cardinality": "zero_or_one",
            "def": "FOREIGN KEY (geochronid) REFERENCES ndb.geochronology(geochronid)"
        },
        {
            "table": "ndb.decayconstants",
            "columns": [
                "publicationid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.publications",
            "parent_columns": [
                "publicationid"
            ],
            "parent_cardinality": "zero_or_one",
            "def": "FOREIGN KEY (publicationid) REFERENCES ndb.publications(publicationid)"
        },
        {
            "table": "ndb.uraniumseries",
            "columns": [
                "geochronid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.geochronology",
            "parent_columns": [
                "geochronid"
            ],
            "parent_cardinality": "zero_or_one",
            "def": "FOREIGN KEY (geochronid) REFERENCES ndb.geochronology(geochronid)"
        },
        {
            "table": "ndb.uraniumseries",
            "columns": [
                "decayconstantid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.decayconstants",
            "parent_columns": [
                "decayconstantid"
            ],
            "parent_cardinality": "zero_or_one",
            "def": "FOREIGN KEY (decayconstantid) REFERENCES ndb.decayconstants(decayconstantid)"
        },
        {
            "table": "ndb.uraniumseriesdata",
            "columns": [
                "dataid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.data",
            "parent_columns": [
                "dataid"
            ],
            "parent_cardinality": "zero_or_one",
            "def": "FOREIGN KEY (dataid) REFERENCES ndb.data(dataid)"
        },
        {
            "table": "ndb.uraniumseriesdata",
            "columns": [
                "geochronid"
            ],
            "cardinality": "zero_or_more",
            "parent_table": "ndb.geochronology",
            "parent_columns": [
                "geochronid"
            ],
            "parent_cardinality": "zero_or_one",
            "def": "FOREIGN KEY (geochronid) REFERENCES ndb.geochronology(geochronid)"
        }
    ],
    "functions": [
        {
            "name": "public.bqarr_in",
            "return_type": "query_int",
            "arguments": "cstring",
            "type": "FUNCTION"
        },
        {
            "name": "public.bqarr_out",
            "return_type": "cstring",
            "arguments": "query_int",
            "type": "FUNCTION"
        },
        {
            "name": "public.querytree",
            "return_type": "text",
            "arguments": "query_int",
            "type": "FUNCTION"
        },
        {
            "name": "public.boolop",
            "return_type": "bool",
            "arguments": "integer[], query_int",
            "type": "FUNCTION"
        },
        {
            "name": "public.rboolop",
            "return_type": "bool",
            "arguments": "query_int, integer[]",
            "type": "FUNCTION"
        },
        {
            "name": "public._int_matchsel",
            "return_type": "float8",
            "arguments": "internal, oid, internal, integer",
            "type": "FUNCTION"
        },
        {
            "name": "public._int_contains",
            "return_type": "bool",
            "arguments": "integer[], integer[]",
            "type": "FUNCTION"
        },
        {
            "name": "public._int_contained",
            "return_type": "bool",
            "arguments": "integer[], integer[]",
            "type": "FUNCTION"
        },
        {
            "name": "public._int_overlap",
            "return_type": "bool",
            "arguments": "integer[], integer[]",
            "type": "FUNCTION"
        },
        {
            "name": "public._int_same",
            "return_type": "bool",
            "arguments": "integer[], integer[]",
            "type": "FUNCTION"
        },
        {
            "name": "public._int_different",
            "return_type": "bool",
            "arguments": "integer[], integer[]",
            "type": "FUNCTION"
        },
        {
            "name": "public._int_union",
            "return_type": "_int4",
            "arguments": "integer[], integer[]",
            "type": "FUNCTION"
        },
        {
            "name": "public._int_inter",
            "return_type": "_int4",
            "arguments": "integer[], integer[]",
            "type": "FUNCTION"
        },
        {
            "name": "public._int_overlap_sel",
            "return_type": "float8",
            "arguments": "internal, oid, internal, integer",
            "type": "FUNCTION"
        },
        {
            "name": "public._int_contains_sel",
            "return_type": "float8",
            "arguments": "internal, oid, internal, integer",
            "type": "FUNCTION"
        },
        {
            "name": "public._int_contained_sel",
            "return_type": "float8",
            "arguments": "internal, oid, internal, integer",
            "type": "FUNCTION"
        },
        {
            "name": "public._int_overlap_joinsel",
            "return_type": "float8",
            "arguments": "internal, oid, internal, smallint, internal",
            "type": "FUNCTION"
        },
        {
            "name": "public._int_contains_joinsel",
            "return_type": "float8",
            "arguments": "internal, oid, internal, smallint, internal",
            "type": "FUNCTION"
        },
        {
            "name": "public._int_contained_joinsel",
            "return_type": "float8",
            "arguments": "internal, oid, internal, smallint, internal",
            "type": "FUNCTION"
        },
        {
            "name": "public.intset",
            "return_type": "_int4",
            "arguments": "integer",
            "type": "FUNCTION"
        },
        {
            "name": "public.icount",
            "return_type": "int4",
            "arguments": "integer[]",
            "type": "FUNCTION"
        },
        {
            "name": "public.sort",
            "return_type": "_int4",
            "arguments": "integer[], text",
            "type": "FUNCTION"
        },
        {
            "name": "public.sort",
            "return_type": "_int4",
            "arguments": "integer[]",
            "type": "FUNCTION"
        },
        {
            "name": "public.sort_asc",
            "return_type": "_int4",
            "arguments": "integer[]",
            "type": "FUNCTION"
        },
        {
            "name": "public.sort_desc",
            "return_type": "_int4",
            "arguments": "integer[]",
            "type": "FUNCTION"
        },
        {
            "name": "public.uniq",
            "return_type": "_int4",
            "arguments": "integer[]",
            "type": "FUNCTION"
        },
        {
            "name": "public.idx",
            "return_type": "int4",
            "arguments": "integer[], integer",
            "type": "FUNCTION"
        },
        {
            "name": "public.subarray",
            "return_type": "_int4",
            "arguments": "integer[], integer, integer",
            "type": "FUNCTION"
        },
        {
            "name": "public.subarray",
            "return_type": "_int4",
            "arguments": "integer[], integer",
            "type": "FUNCTION"
        },
        {
            "name": "public.intarray_push_elem",
            "return_type": "_int4",
            "arguments": "integer[], integer",
            "type": "FUNCTION"
        },
        {
            "name": "public.intarray_push_array",
            "return_type": "_int4",
            "arguments": "integer[], integer[]",
            "type": "FUNCTION"
        },
        {
            "name": "public.intarray_del_elem",
            "return_type": "_int4",
            "arguments": "integer[], integer",
            "type": "FUNCTION"
        },
        {
            "name": "public.intset_union_elem",
            "return_type": "_int4",
            "arguments": "integer[], integer",
            "type": "FUNCTION"
        },
        {
            "name": "public.intset_subtract",
            "return_type": "_int4",
            "arguments": "integer[], integer[]",
            "type": "FUNCTION"
        },
        {
            "name": "public.g_int_consistent",
            "return_type": "bool",
            "arguments": "internal, integer[], smallint, oid, internal",
            "type": "FUNCTION"
        },
        {
            "name": "public.g_int_compress",
            "return_type": "internal",
            "arguments": "internal",
            "type": "FUNCTION"
        },
        {
            "name": "public.g_int_decompress",
            "return_type": "internal",
            "arguments": "internal",
            "type": "FUNCTION"
        },
        {
            "name": "public.g_int_penalty",
            "return_type": "internal",
            "arguments": "internal, internal, internal",
            "type": "FUNCTION"
        },
        {
            "name": "public.g_int_picksplit",
            "return_type": "internal",
            "arguments": "internal, internal",
            "type": "FUNCTION"
        },
        {
            "name": "public.g_int_union",
            "return_type": "_int4",
            "arguments": "internal, internal",
            "type": "FUNCTION"
        },
        {
            "name": "public.g_int_same",
            "return_type": "internal",
            "arguments": "integer[], integer[], internal",
            "type": "FUNCTION"
        },
        {
            "name": "public._intbig_in",
            "return_type": "intbig_gkey",
            "arguments": "cstring",
            "type": "FUNCTION"
        },
        {
            "name": "public._intbig_out",
            "return_type": "cstring",
            "arguments": "intbig_gkey",
            "type": "FUNCTION"
        },
        {
            "name": "public.g_intbig_consistent",
            "return_type": "bool",
            "arguments": "internal, integer[], smallint, oid, internal",
            "type": "FUNCTION"
        },
        {
            "name": "public.g_intbig_compress",
            "return_type": "internal",
            "arguments": "internal",
            "type": "FUNCTION"
        },
        {
            "name": "public.g_intbig_decompress",
            "return_type": "internal",
            "arguments": "internal",
            "type": "FUNCTION"
        },
        {
            "name": "public.g_intbig_penalty",
            "return_type": "internal",
            "arguments": "internal, internal, internal",
            "type": "FUNCTION"
        },
        {
            "name": "public.g_intbig_picksplit",
            "return_type": "internal",
            "arguments": "internal, internal",
            "type": "FUNCTION"
        },
        {
            "name": "public.g_intbig_union",
            "return_type": "intbig_gkey",
            "arguments": "internal, internal",
            "type": "FUNCTION"
        },
        {
            "name": "public.g_intbig_same",
            "return_type": "internal",
            "arguments": "intbig_gkey, intbig_gkey, internal",
            "type": "FUNCTION"
        },
        {
            "name": "public.ginint4_queryextract",
            "return_type": "internal",
            "arguments": "integer[], internal, smallint, internal, internal, internal, internal",
            "type": "FUNCTION"
        },
        {
            "name": "public.ginint4_consistent",
            "return_type": "bool",
            "arguments": "internal, smallint, integer[], integer, internal, internal, internal, internal",
            "type": "FUNCTION"
        },
        {
            "name": "public.g_int_options",
            "return_type": "void",
            "arguments": "internal",
            "type": "FUNCTION"
        },
        {
            "name": "public.g_intbig_options",
            "return_type": "void",
            "arguments": "internal",
            "type": "FUNCTION"
        },
        {
            "name": "public.pg_stat_statements_reset",
            "return_type": "void",
            "arguments": "userid oid DEFAULT 0, dbid oid DEFAULT 0, queryid bigint DEFAULT 0",
            "type": "FUNCTION"
        },
        {
            "name": "public.pg_stat_statements_info",
            "return_type": "record",
            "arguments": "OUT dealloc bigint, OUT stats_reset timestamp with time zone",
            "type": "FUNCTION"
        },
        {
            "name": "public.pg_stat_statements",
            "return_type": "record",
            "arguments": "showtext boolean, OUT userid oid, OUT dbid oid, OUT toplevel boolean, OUT queryid bigint, OUT query text, OUT plans bigint, OUT total_plan_time double precision, OUT min_plan_time double precision, OUT max_plan_time double precision, OUT mean_plan_time double precision, OUT stddev_plan_time double precision, OUT calls bigint, OUT total_exec_time double precision, OUT min_exec_time double precision, OUT max_exec_time double precision, OUT mean_exec_time double precision, OUT stddev_exec_time double precision, OUT rows bigint, OUT shared_blks_hit bigint, OUT shared_blks_read bigint, OUT shared_blks_dirtied bigint, OUT shared_blks_written bigint, OUT local_blks_hit bigint, OUT local_blks_read bigint, OUT local_blks_dirtied bigint, OUT local_blks_written bigint, OUT temp_blks_read bigint, OUT temp_blks_written bigint, OUT blk_read_time double precision, OUT blk_write_time double precision, OUT temp_blk_read_time double precision, OUT temp_blk_write_time double precision, OUT wal_records bigint, OUT wal_fpi bigint, OUT wal_bytes numeric, OUT jit_functions bigint, OUT jit_generation_time double precision, OUT jit_inlining_count bigint, OUT jit_inlining_time double precision, OUT jit_optimization_count bigint, OUT jit_optimization_time double precision, OUT jit_emission_count bigint, OUT jit_emission_time double precision",
            "type": "FUNCTION"
        },
        {
            "name": "public.set_limit",
            "return_type": "float4",
            "arguments": "real",
            "type": "FUNCTION"
        },
        {
            "name": "public.show_limit",
            "return_type": "float4",
            "arguments": "",
            "type": "FUNCTION"
        },
        {
            "name": "public.show_trgm",
            "return_type": "_text",
            "arguments": "text",
            "type": "FUNCTION"
        },
        {
            "name": "public.similarity",
            "return_type": "float4",
            "arguments": "text, text",
            "type": "FUNCTION"
        },
        {
            "name": "public.similarity_op",
            "return_type": "bool",
            "arguments": "text, text",
            "type": "FUNCTION"
        },
        {
            "name": "public.word_similarity",
            "return_type": "float4",
            "arguments": "text, text",
            "type": "FUNCTION"
        },
        {
            "name": "public.word_similarity_op",
            "return_type": "bool",
            "arguments": "text, text",
            "type": "FUNCTION"
        },
        {
            "name": "public.word_similarity_commutator_op",
            "return_type": "bool",
            "arguments": "text, text",
            "type": "FUNCTION"
        },
        {
            "name": "public.similarity_dist",
            "return_type": "float4",
            "arguments": "text, text",
            "type": "FUNCTION"
        },
        {
            "name": "public.word_similarity_dist_op",
            "return_type": "float4",
            "arguments": "text, text",
            "type": "FUNCTION"
        },
        {
            "name": "public.word_similarity_dist_commutator_op",
            "return_type": "float4",
            "arguments": "text, text",
            "type": "FUNCTION"
        },
        {
            "name": "public.gtrgm_in",
            "return_type": "gtrgm",
            "arguments": "cstring",
            "type": "FUNCTION"
        },
        {
            "name": "public.gtrgm_out",
            "return_type": "cstring",
            "arguments": "gtrgm",
            "type": "FUNCTION"
        },
        {
            "name": "public.gtrgm_consistent",
            "return_type": "bool",
            "arguments": "internal, text, smallint, oid, internal",
            "type": "FUNCTION"
        },
        {
            "name": "public.gtrgm_distance",
            "return_type": "float8",
            "arguments": "internal, text, smallint, oid, internal",
            "type": "FUNCTION"
        },
        {
            "name": "public.gtrgm_compress",
            "return_type": "internal",
            "arguments": "internal",
            "type": "FUNCTION"
        },
        {
            "name": "public.gtrgm_decompress",
            "return_type": "internal",
            "arguments": "internal",
            "type": "FUNCTION"
        },
        {
            "name": "public.gtrgm_penalty",
            "return_type": "internal",
            "arguments": "internal, internal, internal",
            "type": "FUNCTION"
        },
        {
            "name": "public.gtrgm_picksplit",
            "return_type": "internal",
            "arguments": "internal, internal",
            "type": "FUNCTION"
        },
        {
            "name": "public.gtrgm_union",
            "return_type": "gtrgm",
            "arguments": "internal, internal",
            "type": "FUNCTION"
        },
        {
            "name": "public.gtrgm_same",
            "return_type": "internal",
            "arguments": "gtrgm, gtrgm, internal",
            "type": "FUNCTION"
        },
        {
            "name": "public.gin_extract_value_trgm",
            "return_type": "internal",
            "arguments": "text, internal",
            "type": "FUNCTION"
        },
        {
            "name": "public.gin_extract_query_trgm",
            "return_type": "internal",
            "arguments": "text, internal, smallint, internal, internal, internal, internal",
            "type": "FUNCTION"
        },
        {
            "name": "public.gin_trgm_consistent",
            "return_type": "bool",
            "arguments": "internal, smallint, text, integer, internal, internal, internal, internal",
            "type": "FUNCTION"
        },
        {
            "name": "public.gin_trgm_triconsistent",
            "return_type": "char",
            "arguments": "internal, smallint, text, integer, internal, internal, internal",
            "type": "FUNCTION"
        },
        {
            "name": "public.strict_word_similarity",
            "return_type": "float4",
            "arguments": "text, text",
            "type": "FUNCTION"
        },
        {
            "name": "public.strict_word_similarity_op",
            "return_type": "bool",
            "arguments": "text, text",
            "type": "FUNCTION"
        },
        {
            "name": "public.strict_word_similarity_commutator_op",
            "return_type": "bool",
            "arguments": "text, text",
            "type": "FUNCTION"
        },
        {
            "name": "public.strict_word_similarity_dist_op",
            "return_type": "float4",
            "arguments": "text, text",
            "type": "FUNCTION"
        },
        {
            "name": "public.strict_word_similarity_dist_commutator_op",
            "return_type": "float4",
            "arguments": "text, text",
            "type": "FUNCTION"
        },
        {
            "name": "public.gtrgm_options",
            "return_type": "void",
            "arguments": "internal",
            "type": "FUNCTION"
        },
        {
            "name": "public._postgis_deprecate",
            "return_type": "void",
            "arguments": "oldname text, newname text, version text",
            "type": "FUNCTION"
        },
        {
            "name": "public.spheroid_in",
            "return_type": "spheroid",
            "arguments": "cstring",
            "type": "FUNCTION"
        },
        {
            "name": "public.spheroid_out",
            "return_type": "cstring",
            "arguments": "spheroid",
            "type": "FUNCTION"
        },
        {
            "name": "public.geometry_in",
            "return_type": "geometry",
            "arguments": "cstring",
            "type": "FUNCTION"
        },
        {
            "name": "public.geometry_out",
            "return_type": "cstring",
            "arguments": "geometry",
            "type": "FUNCTION"
        },
        {
            "name": "public.geometry_typmod_in",
            "return_type": "int4",
            "arguments": "cstring[]",
            "type": "FUNCTION"
        },
        {
            "name": "public.geometry_typmod_out",
            "return_type": "cstring",
            "arguments": "integer",
            "type": "FUNCTION"
        },
        {
            "name": "public.geometry_analyze",
            "return_type": "bool",
            "arguments": "internal",
            "type": "FUNCTION"
        },
        {
            "name": "public.geometry_recv",
            "return_type": "geometry",
            "arguments": "internal",
            "type": "FUNCTION"
        },
        {
            "name": "public.geometry_send",
            "return_type": "bytea",
            "arguments": "geometry",
            "type": "FUNCTION"
        },
        {
            "name": "public.geometry",
            "return_type": "geometry",
            "arguments": "geometry, integer, boolean",
            "type": "FUNCTION"
        },
        {
            "name": "public.geometry",
            "return_type": "geometry",
            "arguments": "point",
            "type": "FUNCTION"
        },
        {
            "name": "public.point",
            "return_type": "point",
            "arguments": "geometry",
            "type": "FUNCTION"
        },
        {
            "name": "public.geometry",
            "return_type": "geometry",
            "arguments": "path",
            "type": "FUNCTION"
        },
        {
            "name": "public.path",
            "return_type": "path",
            "arguments": "geometry",
            "type": "FUNCTION"
        },
        {
            "name": "public.geometry",
            "return_type": "geometry",
            "arguments": "polygon",
            "type": "FUNCTION"
        },
        {
            "name": "public.polygon",
            "return_type": "polygon",
            "arguments": "geometry",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_x",
            "return_type": "float8",
            "arguments": "geometry",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_y",
            "return_type": "float8",
            "arguments": "geometry",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_z",
            "return_type": "float8",
            "arguments": "geometry",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_m",
            "return_type": "float8",
            "arguments": "geometry",
            "type": "FUNCTION"
        },
        {
            "name": "public.box3d_in",
            "return_type": "box3d",
            "arguments": "cstring",
            "type": "FUNCTION"
        },
        {
            "name": "public.box3d_out",
            "return_type": "cstring",
            "arguments": "box3d",
            "type": "FUNCTION"
        },
        {
            "name": "public.box2d_in",
            "return_type": "box2d",
            "arguments": "cstring",
            "type": "FUNCTION"
        },
        {
            "name": "public.box2d_out",
            "return_type": "cstring",
            "arguments": "box2d",
            "type": "FUNCTION"
        },
        {
            "name": "public.box2df_in",
            "return_type": "box2df",
            "arguments": "cstring",
            "type": "FUNCTION"
        },
        {
            "name": "public.box2df_out",
            "return_type": "cstring",
            "arguments": "box2df",
            "type": "FUNCTION"
        },
        {
            "name": "public.gidx_in",
            "return_type": "gidx",
            "arguments": "cstring",
            "type": "FUNCTION"
        },
        {
            "name": "public.gidx_out",
            "return_type": "cstring",
            "arguments": "gidx",
            "type": "FUNCTION"
        },
        {
            "name": "public.geometry_lt",
            "return_type": "bool",
            "arguments": "geom1 geometry, geom2 geometry",
            "type": "FUNCTION"
        },
        {
            "name": "public.geometry_le",
            "return_type": "bool",
            "arguments": "geom1 geometry, geom2 geometry",
            "type": "FUNCTION"
        },
        {
            "name": "public.geometry_gt",
            "return_type": "bool",
            "arguments": "geom1 geometry, geom2 geometry",
            "type": "FUNCTION"
        },
        {
            "name": "public.geometry_ge",
            "return_type": "bool",
            "arguments": "geom1 geometry, geom2 geometry",
            "type": "FUNCTION"
        },
        {
            "name": "public.geometry_eq",
            "return_type": "bool",
            "arguments": "geom1 geometry, geom2 geometry",
            "type": "FUNCTION"
        },
        {
            "name": "public.geometry_cmp",
            "return_type": "int4",
            "arguments": "geom1 geometry, geom2 geometry",
            "type": "FUNCTION"
        },
        {
            "name": "public.geometry_sortsupport",
            "return_type": "void",
            "arguments": "internal",
            "type": "FUNCTION"
        },
        {
            "name": "public.geometry_hash",
            "return_type": "int4",
            "arguments": "geometry",
            "type": "FUNCTION"
        },
        {
            "name": "public.geometry_gist_distance_2d",
            "return_type": "float8",
            "arguments": "internal, geometry, integer",
            "type": "FUNCTION"
        },
        {
            "name": "public.geometry_gist_consistent_2d",
            "return_type": "bool",
            "arguments": "internal, geometry, integer",
            "type": "FUNCTION"
        },
        {
            "name": "public.geometry_gist_compress_2d",
            "return_type": "internal",
            "arguments": "internal",
            "type": "FUNCTION"
        },
        {
            "name": "public.geometry_gist_penalty_2d",
            "return_type": "internal",
            "arguments": "internal, internal, internal",
            "type": "FUNCTION"
        },
        {
            "name": "public.geometry_gist_picksplit_2d",
            "return_type": "internal",
            "arguments": "internal, internal",
            "type": "FUNCTION"
        },
        {
            "name": "public.geometry_gist_union_2d",
            "return_type": "internal",
            "arguments": "bytea, internal",
            "type": "FUNCTION"
        },
        {
            "name": "public.geometry_gist_same_2d",
            "return_type": "internal",
            "arguments": "geom1 geometry, geom2 geometry, internal",
            "type": "FUNCTION"
        },
        {
            "name": "public.geometry_gist_decompress_2d",
            "return_type": "internal",
            "arguments": "internal",
            "type": "FUNCTION"
        },
        {
            "name": "public.geometry_gist_sortsupport_2d",
            "return_type": "void",
            "arguments": "internal",
            "type": "FUNCTION"
        },
        {
            "name": "public._postgis_selectivity",
            "return_type": "float8",
            "arguments": "tbl regclass, att_name text, geom geometry, mode text DEFAULT '2'::text",
            "type": "FUNCTION"
        },
        {
            "name": "public._postgis_join_selectivity",
            "return_type": "float8",
            "arguments": "regclass, text, regclass, text, text DEFAULT '2'::text",
            "type": "FUNCTION"
        },
        {
            "name": "public._postgis_stats",
            "return_type": "text",
            "arguments": "tbl regclass, att_name text, text DEFAULT '2'::text",
            "type": "FUNCTION"
        },
        {
            "name": "public._postgis_index_extent",
            "return_type": "box2d",
            "arguments": "tbl regclass, col text",
            "type": "FUNCTION"
        },
        {
            "name": "public.gserialized_gist_sel_2d",
            "return_type": "float8",
            "arguments": "internal, oid, internal, integer",
            "type": "FUNCTION"
        },
        {
            "name": "public.gserialized_gist_sel_nd",
            "return_type": "float8",
            "arguments": "internal, oid, internal, integer",
            "type": "FUNCTION"
        },
        {
            "name": "public.gserialized_gist_joinsel_2d",
            "return_type": "float8",
            "arguments": "internal, oid, internal, smallint",
            "type": "FUNCTION"
        },
        {
            "name": "public.gserialized_gist_joinsel_nd",
            "return_type": "float8",
            "arguments": "internal, oid, internal, smallint",
            "type": "FUNCTION"
        },
        {
            "name": "public.geometry_overlaps",
            "return_type": "bool",
            "arguments": "geom1 geometry, geom2 geometry",
            "type": "FUNCTION"
        },
        {
            "name": "public.geometry_same",
            "return_type": "bool",
            "arguments": "geom1 geometry, geom2 geometry",
            "type": "FUNCTION"
        },
        {
            "name": "public.geometry_distance_centroid",
            "return_type": "float8",
            "arguments": "geom1 geometry, geom2 geometry",
            "type": "FUNCTION"
        },
        {
            "name": "public.geometry_distance_box",
            "return_type": "float8",
            "arguments": "geom1 geometry, geom2 geometry",
            "type": "FUNCTION"
        },
        {
            "name": "public.geometry_contains",
            "return_type": "bool",
            "arguments": "geom1 geometry, geom2 geometry",
            "type": "FUNCTION"
        },
        {
            "name": "public.geometry_within",
            "return_type": "bool",
            "arguments": "geom1 geometry, geom2 geometry",
            "type": "FUNCTION"
        },
        {
            "name": "public.geometry_left",
            "return_type": "bool",
            "arguments": "geom1 geometry, geom2 geometry",
            "type": "FUNCTION"
        },
        {
            "name": "public.geometry_overleft",
            "return_type": "bool",
            "arguments": "geom1 geometry, geom2 geometry",
            "type": "FUNCTION"
        },
        {
            "name": "public.geometry_below",
            "return_type": "bool",
            "arguments": "geom1 geometry, geom2 geometry",
            "type": "FUNCTION"
        },
        {
            "name": "public.geometry_overbelow",
            "return_type": "bool",
            "arguments": "geom1 geometry, geom2 geometry",
            "type": "FUNCTION"
        },
        {
            "name": "public.geometry_overright",
            "return_type": "bool",
            "arguments": "geom1 geometry, geom2 geometry",
            "type": "FUNCTION"
        },
        {
            "name": "public.geometry_right",
            "return_type": "bool",
            "arguments": "geom1 geometry, geom2 geometry",
            "type": "FUNCTION"
        },
        {
            "name": "public.geometry_overabove",
            "return_type": "bool",
            "arguments": "geom1 geometry, geom2 geometry",
            "type": "FUNCTION"
        },
        {
            "name": "public.geometry_above",
            "return_type": "bool",
            "arguments": "geom1 geometry, geom2 geometry",
            "type": "FUNCTION"
        },
        {
            "name": "public.geometry_gist_consistent_nd",
            "return_type": "bool",
            "arguments": "internal, geometry, integer",
            "type": "FUNCTION"
        },
        {
            "name": "public.geometry_gist_compress_nd",
            "return_type": "internal",
            "arguments": "internal",
            "type": "FUNCTION"
        },
        {
            "name": "public.geometry_gist_penalty_nd",
            "return_type": "internal",
            "arguments": "internal, internal, internal",
            "type": "FUNCTION"
        },
        {
            "name": "public.geometry_gist_picksplit_nd",
            "return_type": "internal",
            "arguments": "internal, internal",
            "type": "FUNCTION"
        },
        {
            "name": "public.geometry_gist_union_nd",
            "return_type": "internal",
            "arguments": "bytea, internal",
            "type": "FUNCTION"
        },
        {
            "name": "public.geometry_gist_same_nd",
            "return_type": "internal",
            "arguments": "geometry, geometry, internal",
            "type": "FUNCTION"
        },
        {
            "name": "public.geometry_gist_decompress_nd",
            "return_type": "internal",
            "arguments": "internal",
            "type": "FUNCTION"
        },
        {
            "name": "public.geometry_overlaps_nd",
            "return_type": "bool",
            "arguments": "geometry, geometry",
            "type": "FUNCTION"
        },
        {
            "name": "public.geometry_contains_nd",
            "return_type": "bool",
            "arguments": "geometry, geometry",
            "type": "FUNCTION"
        },
        {
            "name": "public.geometry_within_nd",
            "return_type": "bool",
            "arguments": "geometry, geometry",
            "type": "FUNCTION"
        },
        {
            "name": "public.geometry_same_nd",
            "return_type": "bool",
            "arguments": "geometry, geometry",
            "type": "FUNCTION"
        },
        {
            "name": "public.geometry_distance_centroid_nd",
            "return_type": "float8",
            "arguments": "geometry, geometry",
            "type": "FUNCTION"
        },
        {
            "name": "public.geometry_distance_cpa",
            "return_type": "float8",
            "arguments": "geometry, geometry",
            "type": "FUNCTION"
        },
        {
            "name": "public.geometry_gist_distance_nd",
            "return_type": "float8",
            "arguments": "internal, geometry, integer",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_shiftlongitude",
            "return_type": "geometry",
            "arguments": "geometry",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_wrapx",
            "return_type": "geometry",
            "arguments": "geom geometry, wrap double precision, move double precision",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_xmin",
            "return_type": "float8",
            "arguments": "box3d",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_ymin",
            "return_type": "float8",
            "arguments": "box3d",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_zmin",
            "return_type": "float8",
            "arguments": "box3d",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_xmax",
            "return_type": "float8",
            "arguments": "box3d",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_ymax",
            "return_type": "float8",
            "arguments": "box3d",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_zmax",
            "return_type": "float8",
            "arguments": "box3d",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_expand",
            "return_type": "box2d",
            "arguments": "box2d, double precision",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_expand",
            "return_type": "box2d",
            "arguments": "box box2d, dx double precision, dy double precision",
            "type": "FUNCTION"
        },
        {
            "name": "public.postgis_getbbox",
            "return_type": "box2d",
            "arguments": "geometry",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_makebox2d",
            "return_type": "box2d",
            "arguments": "geom1 geometry, geom2 geometry",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_estimatedextent",
            "return_type": "box2d",
            "arguments": "text, text, text, boolean",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_estimatedextent",
            "return_type": "box2d",
            "arguments": "text, text, text",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_estimatedextent",
            "return_type": "box2d",
            "arguments": "text, text",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_findextent",
            "return_type": "box2d",
            "arguments": "text, text, text",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_findextent",
            "return_type": "box2d",
            "arguments": "text, text",
            "type": "FUNCTION"
        },
        {
            "name": "public.postgis_addbbox",
            "return_type": "geometry",
            "arguments": "geometry",
            "type": "FUNCTION"
        },
        {
            "name": "public.postgis_dropbbox",
            "return_type": "geometry",
            "arguments": "geometry",
            "type": "FUNCTION"
        },
        {
            "name": "public.postgis_hasbbox",
            "return_type": "bool",
            "arguments": "geometry",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_quantizecoordinates",
            "return_type": "geometry",
            "arguments": "g geometry, prec_x integer, prec_y integer DEFAULT NULL::integer, prec_z integer DEFAULT NULL::integer, prec_m integer DEFAULT NULL::integer",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_memsize",
            "return_type": "int4",
            "arguments": "geometry",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_summary",
            "return_type": "text",
            "arguments": "geometry",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_npoints",
            "return_type": "int4",
            "arguments": "geometry",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_nrings",
            "return_type": "int4",
            "arguments": "geometry",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_3dlength",
            "return_type": "float8",
            "arguments": "geometry",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_length2d",
            "return_type": "float8",
            "arguments": "geometry",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_length",
            "return_type": "float8",
            "arguments": "geometry",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_lengthspheroid",
            "return_type": "float8",
            "arguments": "geometry, spheroid",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_length2dspheroid",
            "return_type": "float8",
            "arguments": "geometry, spheroid",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_3dperimeter",
            "return_type": "float8",
            "arguments": "geometry",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_perimeter2d",
            "return_type": "float8",
            "arguments": "geometry",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_perimeter",
            "return_type": "float8",
            "arguments": "geometry",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_area2d",
            "return_type": "float8",
            "arguments": "geometry",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_area",
            "return_type": "float8",
            "arguments": "geometry",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_ispolygoncw",
            "return_type": "bool",
            "arguments": "geometry",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_ispolygonccw",
            "return_type": "bool",
            "arguments": "geometry",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_distancespheroid",
            "return_type": "float8",
            "arguments": "geom1 geometry, geom2 geometry, spheroid",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_distancespheroid",
            "return_type": "float8",
            "arguments": "geom1 geometry, geom2 geometry",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_distance",
            "return_type": "float8",
            "arguments": "geom1 geometry, geom2 geometry",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_pointinsidecircle",
            "return_type": "bool",
            "arguments": "geometry, double precision, double precision, double precision",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_azimuth",
            "return_type": "float8",
            "arguments": "geom1 geometry, geom2 geometry",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_angle",
            "return_type": "float8",
            "arguments": "pt1 geometry, pt2 geometry, pt3 geometry, pt4 geometry DEFAULT '0101000000000000000000F87F000000000000F87F'::geometry",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_force2d",
            "return_type": "geometry",
            "arguments": "geometry",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_force3dz",
            "return_type": "geometry",
            "arguments": "geom geometry, zvalue double precision DEFAULT 0.0",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_force3d",
            "return_type": "geometry",
            "arguments": "geom geometry, zvalue double precision DEFAULT 0.0",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_force3dm",
            "return_type": "geometry",
            "arguments": "geom geometry, mvalue double precision DEFAULT 0.0",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_force4d",
            "return_type": "geometry",
            "arguments": "geom geometry, zvalue double precision DEFAULT 0.0, mvalue double precision DEFAULT 0.0",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_forcecollection",
            "return_type": "geometry",
            "arguments": "geometry",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_collectionextract",
            "return_type": "geometry",
            "arguments": "geometry, integer",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_collectionextract",
            "return_type": "geometry",
            "arguments": "geometry",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_collectionhomogenize",
            "return_type": "geometry",
            "arguments": "geometry",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_multi",
            "return_type": "geometry",
            "arguments": "geometry",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_forcecurve",
            "return_type": "geometry",
            "arguments": "geometry",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_forcesfs",
            "return_type": "geometry",
            "arguments": "geometry",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_forcesfs",
            "return_type": "geometry",
            "arguments": "geometry, version text",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_expand",
            "return_type": "box3d",
            "arguments": "box3d, double precision",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_expand",
            "return_type": "box3d",
            "arguments": "box box3d, dx double precision, dy double precision, dz double precision DEFAULT 0",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_expand",
            "return_type": "geometry",
            "arguments": "geometry, double precision",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_expand",
            "return_type": "geometry",
            "arguments": "geom geometry, dx double precision, dy double precision, dz double precision DEFAULT 0, dm double precision DEFAULT 0",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_envelope",
            "return_type": "geometry",
            "arguments": "geometry",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_boundingdiagonal",
            "return_type": "geometry",
            "arguments": "geom geometry, fits boolean DEFAULT false",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_reverse",
            "return_type": "geometry",
            "arguments": "geometry",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_scroll",
            "return_type": "geometry",
            "arguments": "geometry, geometry",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_forcepolygoncw",
            "return_type": "geometry",
            "arguments": "geometry",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_forcepolygonccw",
            "return_type": "geometry",
            "arguments": "geometry",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_forcerhr",
            "return_type": "geometry",
            "arguments": "geometry",
            "type": "FUNCTION"
        },
        {
            "name": "public.postgis_noop",
            "return_type": "geometry",
            "arguments": "geometry",
            "type": "FUNCTION"
        },
        {
            "name": "public.postgis_geos_noop",
            "return_type": "geometry",
            "arguments": "geometry",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_normalize",
            "return_type": "geometry",
            "arguments": "geom geometry",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_zmflag",
            "return_type": "int2",
            "arguments": "geometry",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_ndims",
            "return_type": "int2",
            "arguments": "geometry",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_asewkt",
            "return_type": "text",
            "arguments": "geometry",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_asewkt",
            "return_type": "text",
            "arguments": "geometry, integer",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_astwkb",
            "return_type": "bytea",
            "arguments": "geom geometry, prec integer DEFAULT NULL::integer, prec_z integer DEFAULT NULL::integer, prec_m integer DEFAULT NULL::integer, with_sizes boolean DEFAULT NULL::boolean, with_boxes boolean DEFAULT NULL::boolean",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_astwkb",
            "return_type": "bytea",
            "arguments": "geom geometry[], ids bigint[], prec integer DEFAULT NULL::integer, prec_z integer DEFAULT NULL::integer, prec_m integer DEFAULT NULL::integer, with_sizes boolean DEFAULT NULL::boolean, with_boxes boolean DEFAULT NULL::boolean",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_asewkb",
            "return_type": "bytea",
            "arguments": "geometry",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_ashexewkb",
            "return_type": "text",
            "arguments": "geometry",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_ashexewkb",
            "return_type": "text",
            "arguments": "geometry, text",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_asewkb",
            "return_type": "bytea",
            "arguments": "geometry, text",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_aslatlontext",
            "return_type": "text",
            "arguments": "geom geometry, tmpl text DEFAULT ''::text",
            "type": "FUNCTION"
        },
        {
            "name": "public.geomfromewkb",
            "return_type": "geometry",
            "arguments": "bytea",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_geomfromewkb",
            "return_type": "geometry",
            "arguments": "bytea",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_geomfromtwkb",
            "return_type": "geometry",
            "arguments": "bytea",
            "type": "FUNCTION"
        },
        {
            "name": "public.geomfromewkt",
            "return_type": "geometry",
            "arguments": "text",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_geomfromewkt",
            "return_type": "geometry",
            "arguments": "text",
            "type": "FUNCTION"
        },
        {
            "name": "public.postgis_cache_bbox",
            "return_type": "trigger",
            "arguments": "",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_makepoint",
            "return_type": "geometry",
            "arguments": "double precision, double precision",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_makepoint",
            "return_type": "geometry",
            "arguments": "double precision, double precision, double precision",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_makepoint",
            "return_type": "geometry",
            "arguments": "double precision, double precision, double precision, double precision",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_makepointm",
            "return_type": "geometry",
            "arguments": "double precision, double precision, double precision",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_3dmakebox",
            "return_type": "box3d",
            "arguments": "geom1 geometry, geom2 geometry",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_makeline",
            "return_type": "geometry",
            "arguments": "geometry[]",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_linefrommultipoint",
            "return_type": "geometry",
            "arguments": "geometry",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_makeline",
            "return_type": "geometry",
            "arguments": "geom1 geometry, geom2 geometry",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_addpoint",
            "return_type": "geometry",
            "arguments": "geom1 geometry, geom2 geometry",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_addpoint",
            "return_type": "geometry",
            "arguments": "geom1 geometry, geom2 geometry, integer",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_removepoint",
            "return_type": "geometry",
            "arguments": "geometry, integer",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_setpoint",
            "return_type": "geometry",
            "arguments": "geometry, integer, geometry",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_makeenvelope",
            "return_type": "geometry",
            "arguments": "double precision, double precision, double precision, double precision, integer DEFAULT 0",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_tileenvelope",
            "return_type": "geometry",
            "arguments": "zoom integer, x integer, y integer, bounds geometry DEFAULT '0102000020110F00000200000093107C45F81B73C193107C45F81B73C193107C45F81B734193107C45F81B7341'::geometry, margin double precision DEFAULT 0.0",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_makepolygon",
            "return_type": "geometry",
            "arguments": "geometry, geometry[]",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_makepolygon",
            "return_type": "geometry",
            "arguments": "geometry",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_buildarea",
            "return_type": "geometry",
            "arguments": "geometry",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_polygonize",
            "return_type": "geometry",
            "arguments": "geometry[]",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_clusterintersecting",
            "return_type": "_geometry",
            "arguments": "geometry[]",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_clusterwithin",
            "return_type": "_geometry",
            "arguments": "geometry[], double precision",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_clusterdbscan",
            "return_type": "int4",
            "arguments": "geometry, eps double precision, minpoints integer",
            "type": "w"
        },
        {
            "name": "public.st_linemerge",
            "return_type": "geometry",
            "arguments": "geometry",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_linemerge",
            "return_type": "geometry",
            "arguments": "geometry, boolean",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_affine",
            "return_type": "geometry",
            "arguments": "geometry, double precision, double precision, double precision, double precision, double precision, double precision, double precision, double precision, double precision, double precision, double precision, double precision",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_affine",
            "return_type": "geometry",
            "arguments": "geometry, double precision, double precision, double precision, double precision, double precision, double precision",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_rotate",
            "return_type": "geometry",
            "arguments": "geometry, double precision",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_rotate",
            "return_type": "geometry",
            "arguments": "geometry, double precision, double precision, double precision",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_rotate",
            "return_type": "geometry",
            "arguments": "geometry, double precision, geometry",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_rotatez",
            "return_type": "geometry",
            "arguments": "geometry, double precision",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_rotatex",
            "return_type": "geometry",
            "arguments": "geometry, double precision",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_rotatey",
            "return_type": "geometry",
            "arguments": "geometry, double precision",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_translate",
            "return_type": "geometry",
            "arguments": "geometry, double precision, double precision, double precision",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_translate",
            "return_type": "geometry",
            "arguments": "geometry, double precision, double precision",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_scale",
            "return_type": "geometry",
            "arguments": "geometry, geometry",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_scale",
            "return_type": "geometry",
            "arguments": "geometry, geometry, origin geometry",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_scale",
            "return_type": "geometry",
            "arguments": "geometry, double precision, double precision, double precision",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_scale",
            "return_type": "geometry",
            "arguments": "geometry, double precision, double precision",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_transscale",
            "return_type": "geometry",
            "arguments": "geometry, double precision, double precision, double precision, double precision",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_dump",
            "return_type": "geometry_dump",
            "arguments": "geometry",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_dumprings",
            "return_type": "geometry_dump",
            "arguments": "geometry",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_dumppoints",
            "return_type": "geometry_dump",
            "arguments": "geometry",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_dumpsegments",
            "return_type": "geometry_dump",
            "arguments": "geometry",
            "type": "FUNCTION"
        },
        {
            "name": "public.populate_geometry_columns",
            "return_type": "text",
            "arguments": "use_typmod boolean DEFAULT true",
            "type": "FUNCTION"
        },
        {
            "name": "public.populate_geometry_columns",
            "return_type": "int4",
            "arguments": "tbl_oid oid, use_typmod boolean DEFAULT true",
            "type": "FUNCTION"
        },
        {
            "name": "public.addgeometrycolumn",
            "return_type": "text",
            "arguments": "catalog_name character varying, schema_name character varying, table_name character varying, column_name character varying, new_srid_in integer, new_type character varying, new_dim integer, use_typmod boolean DEFAULT true",
            "type": "FUNCTION"
        },
        {
            "name": "public.addgeometrycolumn",
            "return_type": "text",
            "arguments": "schema_name character varying, table_name character varying, column_name character varying, new_srid integer, new_type character varying, new_dim integer, use_typmod boolean DEFAULT true",
            "type": "FUNCTION"
        },
        {
            "name": "public.addgeometrycolumn",
            "return_type": "text",
            "arguments": "table_name character varying, column_name character varying, new_srid integer, new_type character varying, new_dim integer, use_typmod boolean DEFAULT true",
            "type": "FUNCTION"
        },
        {
            "name": "public.dropgeometrycolumn",
            "return_type": "text",
            "arguments": "catalog_name character varying, schema_name character varying, table_name character varying, column_name character varying",
            "type": "FUNCTION"
        },
        {
            "name": "public.dropgeometrycolumn",
            "return_type": "text",
            "arguments": "schema_name character varying, table_name character varying, column_name character varying",
            "type": "FUNCTION"
        },
        {
            "name": "public.dropgeometrycolumn",
            "return_type": "text",
            "arguments": "table_name character varying, column_name character varying",
            "type": "FUNCTION"
        },
        {
            "name": "public.dropgeometrytable",
            "return_type": "text",
            "arguments": "catalog_name character varying, schema_name character varying, table_name character varying",
            "type": "FUNCTION"
        },
        {
            "name": "public.dropgeometrytable",
            "return_type": "text",
            "arguments": "schema_name character varying, table_name character varying",
            "type": "FUNCTION"
        },
        {
            "name": "public.dropgeometrytable",
            "return_type": "text",
            "arguments": "table_name character varying",
            "type": "FUNCTION"
        },
        {
            "name": "public.updategeometrysrid",
            "return_type": "text",
            "arguments": "catalogn_name character varying, schema_name character varying, table_name character varying, column_name character varying, new_srid_in integer",
            "type": "FUNCTION"
        },
        {
            "name": "public.updategeometrysrid",
            "return_type": "text",
            "arguments": "character varying, character varying, character varying, integer",
            "type": "FUNCTION"
        },
        {
            "name": "public.updategeometrysrid",
            "return_type": "text",
            "arguments": "character varying, character varying, integer",
            "type": "FUNCTION"
        },
        {
            "name": "public.find_srid",
            "return_type": "int4",
            "arguments": "character varying, character varying, character varying",
            "type": "FUNCTION"
        },
        {
            "name": "public.get_proj4_from_srid",
            "return_type": "text",
            "arguments": "integer",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_setsrid",
            "return_type": "geometry",
            "arguments": "geom geometry, srid integer",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_srid",
            "return_type": "int4",
            "arguments": "geom geometry",
            "type": "FUNCTION"
        },
        {
            "name": "public.postgis_transform_geometry",
            "return_type": "geometry",
            "arguments": "geom geometry, text, text, integer",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_transform",
            "return_type": "geometry",
            "arguments": "geometry, integer",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_transform",
            "return_type": "geometry",
            "arguments": "geom geometry, to_proj text",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_transform",
            "return_type": "geometry",
            "arguments": "geom geometry, from_proj text, to_proj text",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_transform",
            "return_type": "geometry",
            "arguments": "geom geometry, from_proj text, to_srid integer",
            "type": "FUNCTION"
        },
        {
            "name": "public.postgis_version",
            "return_type": "text",
            "arguments": "",
            "type": "FUNCTION"
        },
        {
            "name": "public.postgis_liblwgeom_version",
            "return_type": "text",
            "arguments": "",
            "type": "FUNCTION"
        },
        {
            "name": "public.postgis_proj_version",
            "return_type": "text",
            "arguments": "",
            "type": "FUNCTION"
        },
        {
            "name": "public.postgis_wagyu_version",
            "return_type": "text",
            "arguments": "",
            "type": "FUNCTION"
        },
        {
            "name": "public.postgis_scripts_installed",
            "return_type": "text",
            "arguments": "",
            "type": "FUNCTION"
        },
        {
            "name": "public.postgis_lib_version",
            "return_type": "text",
            "arguments": "",
            "type": "FUNCTION"
        },
        {
            "name": "public.postgis_scripts_released",
            "return_type": "text",
            "arguments": "",
            "type": "FUNCTION"
        },
        {
            "name": "public.postgis_geos_version",
            "return_type": "text",
            "arguments": "",
            "type": "FUNCTION"
        },
        {
            "name": "public.postgis_lib_revision",
            "return_type": "text",
            "arguments": "",
            "type": "FUNCTION"
        },
        {
            "name": "public.postgis_svn_version",
            "return_type": "text",
            "arguments": "",
            "type": "FUNCTION"
        },
        {
            "name": "public.postgis_libxml_version",
            "return_type": "text",
            "arguments": "",
            "type": "FUNCTION"
        },
        {
            "name": "public.postgis_scripts_build_date",
            "return_type": "text",
            "arguments": "",
            "type": "FUNCTION"
        },
        {
            "name": "public.postgis_lib_build_date",
            "return_type": "text",
            "arguments": "",
            "type": "FUNCTION"
        },
        {
            "name": "public._postgis_scripts_pgsql_version",
            "return_type": "text",
            "arguments": "",
            "type": "FUNCTION"
        },
        {
            "name": "public._postgis_pgsql_version",
            "return_type": "text",
            "arguments": "",
            "type": "FUNCTION"
        },
        {
            "name": "public.postgis_extensions_upgrade",
            "return_type": "text",
            "arguments": "",
            "type": "FUNCTION"
        },
        {
            "name": "public.postgis_full_version",
            "return_type": "text",
            "arguments": "",
            "type": "FUNCTION"
        },
        {
            "name": "public.box2d",
            "return_type": "box2d",
            "arguments": "geometry",
            "type": "FUNCTION"
        },
        {
            "name": "public.box3d",
            "return_type": "box3d",
            "arguments": "geometry",
            "type": "FUNCTION"
        },
        {
            "name": "public.box",
            "return_type": "box",
            "arguments": "geometry",
            "type": "FUNCTION"
        },
        {
            "name": "public.box2d",
            "return_type": "box2d",
            "arguments": "box3d",
            "type": "FUNCTION"
        },
        {
            "name": "public.box3d",
            "return_type": "box3d",
            "arguments": "box2d",
            "type": "FUNCTION"
        },
        {
            "name": "public.box",
            "return_type": "box",
            "arguments": "box3d",
            "type": "FUNCTION"
        },
        {
            "name": "public.text",
            "return_type": "text",
            "arguments": "geometry",
            "type": "FUNCTION"
        },
        {
            "name": "public.box3dtobox",
            "return_type": "box",
            "arguments": "box3d",
            "type": "FUNCTION"
        },
        {
            "name": "public.geometry",
            "return_type": "geometry",
            "arguments": "box2d",
            "type": "FUNCTION"
        },
        {
            "name": "public.geometry",
            "return_type": "geometry",
            "arguments": "box3d",
            "type": "FUNCTION"
        },
        {
            "name": "public.geometry",
            "return_type": "geometry",
            "arguments": "text",
            "type": "FUNCTION"
        },
        {
            "name": "public.geometry",
            "return_type": "geometry",
            "arguments": "bytea",
            "type": "FUNCTION"
        },
        {
            "name": "public.bytea",
            "return_type": "bytea",
            "arguments": "geometry",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_simplify",
            "return_type": "geometry",
            "arguments": "geometry, double precision",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_simplify",
            "return_type": "geometry",
            "arguments": "geometry, double precision, boolean",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_simplifyvw",
            "return_type": "geometry",
            "arguments": "geometry, double precision",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_seteffectivearea",
            "return_type": "geometry",
            "arguments": "geometry, double precision DEFAULT '-1'::integer, integer DEFAULT 1",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_filterbym",
            "return_type": "geometry",
            "arguments": "geometry, double precision, double precision DEFAULT NULL::double precision, boolean DEFAULT false",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_chaikinsmoothing",
            "return_type": "geometry",
            "arguments": "geometry, integer DEFAULT 1, boolean DEFAULT false",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_snaptogrid",
            "return_type": "geometry",
            "arguments": "geometry, double precision, double precision, double precision, double precision",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_snaptogrid",
            "return_type": "geometry",
            "arguments": "geometry, double precision, double precision",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_snaptogrid",
            "return_type": "geometry",
            "arguments": "geometry, double precision",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_snaptogrid",
            "return_type": "geometry",
            "arguments": "geom1 geometry, geom2 geometry, double precision, double precision, double precision, double precision",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_segmentize",
            "return_type": "geometry",
            "arguments": "geometry, double precision",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_lineinterpolatepoint",
            "return_type": "geometry",
            "arguments": "geometry, double precision",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_lineinterpolatepoints",
            "return_type": "geometry",
            "arguments": "geometry, double precision, repeat boolean DEFAULT true",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_linesubstring",
            "return_type": "geometry",
            "arguments": "geometry, double precision, double precision",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_linelocatepoint",
            "return_type": "float8",
            "arguments": "geom1 geometry, geom2 geometry",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_addmeasure",
            "return_type": "geometry",
            "arguments": "geometry, double precision, double precision",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_closestpointofapproach",
            "return_type": "float8",
            "arguments": "geometry, geometry",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_distancecpa",
            "return_type": "float8",
            "arguments": "geometry, geometry",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_cpawithin",
            "return_type": "bool",
            "arguments": "geometry, geometry, double precision",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_isvalidtrajectory",
            "return_type": "bool",
            "arguments": "geometry",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_intersection",
            "return_type": "geometry",
            "arguments": "geom1 geometry, geom2 geometry, gridsize double precision DEFAULT '-1'::integer",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_buffer",
            "return_type": "geometry",
            "arguments": "geom geometry, radius double precision, options text DEFAULT ''::text",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_buffer",
            "return_type": "geometry",
            "arguments": "geom geometry, radius double precision, quadsegs integer",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_minimumboundingradius",
            "return_type": "record",
            "arguments": "geometry, OUT center geometry, OUT radius double precision",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_minimumboundingcircle",
            "return_type": "geometry",
            "arguments": "inputgeom geometry, segs_per_quarter integer DEFAULT 48",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_orientedenvelope",
            "return_type": "geometry",
            "arguments": "geometry",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_offsetcurve",
            "return_type": "geometry",
            "arguments": "line geometry, distance double precision, params text DEFAULT ''::text",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_generatepoints",
            "return_type": "geometry",
            "arguments": "area geometry, npoints integer",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_generatepoints",
            "return_type": "geometry",
            "arguments": "area geometry, npoints integer, seed integer",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_convexhull",
            "return_type": "geometry",
            "arguments": "geometry",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_simplifypreservetopology",
            "return_type": "geometry",
            "arguments": "geometry, double precision",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_isvalidreason",
            "return_type": "text",
            "arguments": "geometry",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_isvaliddetail",
            "return_type": "valid_detail",
            "arguments": "geom geometry, flags integer DEFAULT 0",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_isvalidreason",
            "return_type": "text",
            "arguments": "geometry, integer",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_isvalid",
            "return_type": "bool",
            "arguments": "geometry, integer",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_hausdorffdistance",
            "return_type": "float8",
            "arguments": "geom1 geometry, geom2 geometry",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_hausdorffdistance",
            "return_type": "float8",
            "arguments": "geom1 geometry, geom2 geometry, double precision",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_frechetdistance",
            "return_type": "float8",
            "arguments": "geom1 geometry, geom2 geometry, double precision DEFAULT '-1'::integer",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_maximuminscribedcircle",
            "return_type": "record",
            "arguments": "geometry, OUT center geometry, OUT nearest geometry, OUT radius double precision",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_difference",
            "return_type": "geometry",
            "arguments": "geom1 geometry, geom2 geometry, gridsize double precision DEFAULT '-1.0'::numeric",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_boundary",
            "return_type": "geometry",
            "arguments": "geometry",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_points",
            "return_type": "geometry",
            "arguments": "geometry",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_symdifference",
            "return_type": "geometry",
            "arguments": "geom1 geometry, geom2 geometry, gridsize double precision DEFAULT '-1.0'::numeric",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_symmetricdifference",
            "return_type": "geometry",
            "arguments": "geom1 geometry, geom2 geometry",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_union",
            "return_type": "geometry",
            "arguments": "geom1 geometry, geom2 geometry",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_union",
            "return_type": "geometry",
            "arguments": "geom1 geometry, geom2 geometry, gridsize double precision",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_unaryunion",
            "return_type": "geometry",
            "arguments": "geometry, gridsize double precision DEFAULT '-1.0'::numeric",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_removerepeatedpoints",
            "return_type": "geometry",
            "arguments": "geom geometry, tolerance double precision DEFAULT 0.0",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_clipbybox2d",
            "return_type": "geometry",
            "arguments": "geom geometry, box box2d",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_subdivide",
            "return_type": "geometry",
            "arguments": "geom geometry, maxvertices integer DEFAULT 256, gridsize double precision DEFAULT '-1.0'::numeric",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_reduceprecision",
            "return_type": "geometry",
            "arguments": "geom geometry, gridsize double precision",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_makevalid",
            "return_type": "geometry",
            "arguments": "geometry",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_makevalid",
            "return_type": "geometry",
            "arguments": "geom geometry, params text",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_cleangeometry",
            "return_type": "geometry",
            "arguments": "geometry",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_split",
            "return_type": "geometry",
            "arguments": "geom1 geometry, geom2 geometry",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_sharedpaths",
            "return_type": "geometry",
            "arguments": "geom1 geometry, geom2 geometry",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_snap",
            "return_type": "geometry",
            "arguments": "geom1 geometry, geom2 geometry, double precision",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_relatematch",
            "return_type": "bool",
            "arguments": "text, text",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_node",
            "return_type": "geometry",
            "arguments": "g geometry",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_delaunaytriangles",
            "return_type": "geometry",
            "arguments": "g1 geometry, tolerance double precision DEFAULT 0.0, flags integer DEFAULT 0",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_triangulatepolygon",
            "return_type": "geometry",
            "arguments": "g1 geometry",
            "type": "FUNCTION"
        },
        {
            "name": "public._st_voronoi",
            "return_type": "geometry",
            "arguments": "g1 geometry, clip geometry DEFAULT NULL::geometry, tolerance double precision DEFAULT 0.0, return_polygons boolean DEFAULT true",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_voronoipolygons",
            "return_type": "geometry",
            "arguments": "g1 geometry, tolerance double precision DEFAULT 0.0, extend_to geometry DEFAULT NULL::geometry",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_voronoilines",
            "return_type": "geometry",
            "arguments": "g1 geometry, tolerance double precision DEFAULT 0.0, extend_to geometry DEFAULT NULL::geometry",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_combinebbox",
            "return_type": "box3d",
            "arguments": "box3d, geometry",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_combinebbox",
            "return_type": "box3d",
            "arguments": "box3d, box3d",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_combinebbox",
            "return_type": "box2d",
            "arguments": "box2d, geometry",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_extent",
            "return_type": "box2d",
            "arguments": "geometry",
            "type": "a"
        },
        {
            "name": "public.st_3dextent",
            "return_type": "box3d",
            "arguments": "geometry",
            "type": "a"
        },
        {
            "name": "public.st_collect",
            "return_type": "geometry",
            "arguments": "geom1 geometry, geom2 geometry",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_memcollect",
            "return_type": "geometry",
            "arguments": "geometry",
            "type": "a"
        },
        {
            "name": "public.st_collect",
            "return_type": "geometry",
            "arguments": "geometry[]",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_memunion",
            "return_type": "geometry",
            "arguments": "geometry",
            "type": "a"
        },
        {
            "name": "public.pgis_geometry_accum_transfn",
            "return_type": "internal",
            "arguments": "internal, geometry",
            "type": "FUNCTION"
        },
        {
            "name": "public.pgis_geometry_accum_transfn",
            "return_type": "internal",
            "arguments": "internal, geometry, double precision",
            "type": "FUNCTION"
        },
        {
            "name": "public.pgis_geometry_accum_transfn",
            "return_type": "internal",
            "arguments": "internal, geometry, double precision, integer",
            "type": "FUNCTION"
        },
        {
            "name": "public.pgis_geometry_collect_finalfn",
            "return_type": "geometry",
            "arguments": "internal",
            "type": "FUNCTION"
        },
        {
            "name": "public.pgis_geometry_polygonize_finalfn",
            "return_type": "geometry",
            "arguments": "internal",
            "type": "FUNCTION"
        },
        {
            "name": "public.pgis_geometry_clusterintersecting_finalfn",
            "return_type": "_geometry",
            "arguments": "internal",
            "type": "FUNCTION"
        },
        {
            "name": "public.pgis_geometry_clusterwithin_finalfn",
            "return_type": "_geometry",
            "arguments": "internal",
            "type": "FUNCTION"
        },
        {
            "name": "public.pgis_geometry_makeline_finalfn",
            "return_type": "geometry",
            "arguments": "internal",
            "type": "FUNCTION"
        },
        {
            "name": "public.pgis_geometry_union_parallel_transfn",
            "return_type": "internal",
            "arguments": "internal, geometry",
            "type": "FUNCTION"
        },
        {
            "name": "public.pgis_geometry_union_parallel_transfn",
            "return_type": "internal",
            "arguments": "internal, geometry, double precision",
            "type": "FUNCTION"
        },
        {
            "name": "public.pgis_geometry_union_parallel_combinefn",
            "return_type": "internal",
            "arguments": "internal, internal",
            "type": "FUNCTION"
        },
        {
            "name": "public.pgis_geometry_union_parallel_serialfn",
            "return_type": "bytea",
            "arguments": "internal",
            "type": "FUNCTION"
        },
        {
            "name": "public.pgis_geometry_union_parallel_deserialfn",
            "return_type": "internal",
            "arguments": "bytea, internal",
            "type": "FUNCTION"
        },
        {
            "name": "public.pgis_geometry_union_parallel_finalfn",
            "return_type": "geometry",
            "arguments": "internal",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_union",
            "return_type": "geometry",
            "arguments": "geometry[]",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_union",
            "return_type": "geometry",
            "arguments": "geometry",
            "type": "a"
        },
        {
            "name": "public.st_union",
            "return_type": "geometry",
            "arguments": "geometry, gridsize double precision",
            "type": "a"
        },
        {
            "name": "public.st_collect",
            "return_type": "geometry",
            "arguments": "geometry",
            "type": "a"
        },
        {
            "name": "public.st_clusterintersecting",
            "return_type": "_geometry",
            "arguments": "geometry",
            "type": "a"
        },
        {
            "name": "public.st_clusterwithin",
            "return_type": "_geometry",
            "arguments": "geometry, double precision",
            "type": "a"
        },
        {
            "name": "public.st_polygonize",
            "return_type": "geometry",
            "arguments": "geometry",
            "type": "a"
        },
        {
            "name": "public.st_makeline",
            "return_type": "geometry",
            "arguments": "geometry",
            "type": "a"
        },
        {
            "name": "public.st_clusterkmeans",
            "return_type": "int4",
            "arguments": "geom geometry, k integer, max_radius double precision DEFAULT NULL::double precision",
            "type": "w"
        },
        {
            "name": "public.st_relate",
            "return_type": "text",
            "arguments": "geom1 geometry, geom2 geometry",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_relate",
            "return_type": "text",
            "arguments": "geom1 geometry, geom2 geometry, integer",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_relate",
            "return_type": "bool",
            "arguments": "geom1 geometry, geom2 geometry, text",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_disjoint",
            "return_type": "bool",
            "arguments": "geom1 geometry, geom2 geometry",
            "type": "FUNCTION"
        },
        {
            "name": "public._st_linecrossingdirection",
            "return_type": "int4",
            "arguments": "line1 geometry, line2 geometry",
            "type": "FUNCTION"
        },
        {
            "name": "public._st_dwithin",
            "return_type": "bool",
            "arguments": "geom1 geometry, geom2 geometry, double precision",
            "type": "FUNCTION"
        },
        {
            "name": "public._st_touches",
            "return_type": "bool",
            "arguments": "geom1 geometry, geom2 geometry",
            "type": "FUNCTION"
        },
        {
            "name": "public._st_intersects",
            "return_type": "bool",
            "arguments": "geom1 geometry, geom2 geometry",
            "type": "FUNCTION"
        },
        {
            "name": "public._st_crosses",
            "return_type": "bool",
            "arguments": "geom1 geometry, geom2 geometry",
            "type": "FUNCTION"
        },
        {
            "name": "public._st_contains",
            "return_type": "bool",
            "arguments": "geom1 geometry, geom2 geometry",
            "type": "FUNCTION"
        },
        {
            "name": "public._st_containsproperly",
            "return_type": "bool",
            "arguments": "geom1 geometry, geom2 geometry",
            "type": "FUNCTION"
        },
        {
            "name": "public._st_covers",
            "return_type": "bool",
            "arguments": "geom1 geometry, geom2 geometry",
            "type": "FUNCTION"
        },
        {
            "name": "public._st_coveredby",
            "return_type": "bool",
            "arguments": "geom1 geometry, geom2 geometry",
            "type": "FUNCTION"
        },
        {
            "name": "public._st_within",
            "return_type": "bool",
            "arguments": "geom1 geometry, geom2 geometry",
            "type": "FUNCTION"
        },
        {
            "name": "public._st_overlaps",
            "return_type": "bool",
            "arguments": "geom1 geometry, geom2 geometry",
            "type": "FUNCTION"
        },
        {
            "name": "public._st_dfullywithin",
            "return_type": "bool",
            "arguments": "geom1 geometry, geom2 geometry, double precision",
            "type": "FUNCTION"
        },
        {
            "name": "public._st_3ddwithin",
            "return_type": "bool",
            "arguments": "geom1 geometry, geom2 geometry, double precision",
            "type": "FUNCTION"
        },
        {
            "name": "public._st_3ddfullywithin",
            "return_type": "bool",
            "arguments": "geom1 geometry, geom2 geometry, double precision",
            "type": "FUNCTION"
        },
        {
            "name": "public._st_3dintersects",
            "return_type": "bool",
            "arguments": "geom1 geometry, geom2 geometry",
            "type": "FUNCTION"
        },
        {
            "name": "public._st_orderingequals",
            "return_type": "bool",
            "arguments": "geom1 geometry, geom2 geometry",
            "type": "FUNCTION"
        },
        {
            "name": "public._st_equals",
            "return_type": "bool",
            "arguments": "geom1 geometry, geom2 geometry",
            "type": "FUNCTION"
        },
        {
            "name": "public.postgis_index_supportfn",
            "return_type": "internal",
            "arguments": "internal",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_linecrossingdirection",
            "return_type": "int4",
            "arguments": "line1 geometry, line2 geometry",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_dwithin",
            "return_type": "bool",
            "arguments": "geom1 geometry, geom2 geometry, double precision",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_touches",
            "return_type": "bool",
            "arguments": "geom1 geometry, geom2 geometry",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_intersects",
            "return_type": "bool",
            "arguments": "geom1 geometry, geom2 geometry",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_crosses",
            "return_type": "bool",
            "arguments": "geom1 geometry, geom2 geometry",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_contains",
            "return_type": "bool",
            "arguments": "geom1 geometry, geom2 geometry",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_containsproperly",
            "return_type": "bool",
            "arguments": "geom1 geometry, geom2 geometry",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_within",
            "return_type": "bool",
            "arguments": "geom1 geometry, geom2 geometry",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_covers",
            "return_type": "bool",
            "arguments": "geom1 geometry, geom2 geometry",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_coveredby",
            "return_type": "bool",
            "arguments": "geom1 geometry, geom2 geometry",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_overlaps",
            "return_type": "bool",
            "arguments": "geom1 geometry, geom2 geometry",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_dfullywithin",
            "return_type": "bool",
            "arguments": "geom1 geometry, geom2 geometry, double precision",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_3ddwithin",
            "return_type": "bool",
            "arguments": "geom1 geometry, geom2 geometry, double precision",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_3ddfullywithin",
            "return_type": "bool",
            "arguments": "geom1 geometry, geom2 geometry, double precision",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_3dintersects",
            "return_type": "bool",
            "arguments": "geom1 geometry, geom2 geometry",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_orderingequals",
            "return_type": "bool",
            "arguments": "geom1 geometry, geom2 geometry",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_equals",
            "return_type": "bool",
            "arguments": "geom1 geometry, geom2 geometry",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_isvalid",
            "return_type": "bool",
            "arguments": "geometry",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_minimumclearance",
            "return_type": "float8",
            "arguments": "geometry",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_minimumclearanceline",
            "return_type": "geometry",
            "arguments": "geometry",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_centroid",
            "return_type": "geometry",
            "arguments": "geometry",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_geometricmedian",
            "return_type": "geometry",
            "arguments": "g geometry, tolerance double precision DEFAULT NULL::double precision, max_iter integer DEFAULT 10000, fail_if_not_converged boolean DEFAULT false",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_isring",
            "return_type": "bool",
            "arguments": "geometry",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_pointonsurface",
            "return_type": "geometry",
            "arguments": "geometry",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_issimple",
            "return_type": "bool",
            "arguments": "geometry",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_iscollection",
            "return_type": "bool",
            "arguments": "geometry",
            "type": "FUNCTION"
        },
        {
            "name": "public.equals",
            "return_type": "bool",
            "arguments": "geom1 geometry, geom2 geometry",
            "type": "FUNCTION"
        },
        {
            "name": "public._st_geomfromgml",
            "return_type": "geometry",
            "arguments": "text, integer",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_geomfromgml",
            "return_type": "geometry",
            "arguments": "text, integer",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_geomfromgml",
            "return_type": "geometry",
            "arguments": "text",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_gmltosql",
            "return_type": "geometry",
            "arguments": "text",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_gmltosql",
            "return_type": "geometry",
            "arguments": "text, integer",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_geomfromkml",
            "return_type": "geometry",
            "arguments": "text",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_geomfrommarc21",
            "return_type": "geometry",
            "arguments": "marc21xml text",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_asmarc21",
            "return_type": "text",
            "arguments": "geom geometry, format text DEFAULT 'hdddmmss'::text",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_geomfromgeojson",
            "return_type": "geometry",
            "arguments": "text",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_geomfromgeojson",
            "return_type": "geometry",
            "arguments": "json",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_geomfromgeojson",
            "return_type": "geometry",
            "arguments": "jsonb",
            "type": "FUNCTION"
        },
        {
            "name": "public.postgis_libjson_version",
            "return_type": "text",
            "arguments": "",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_linefromencodedpolyline",
            "return_type": "geometry",
            "arguments": "txtin text, nprecision integer DEFAULT 5",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_asencodedpolyline",
            "return_type": "text",
            "arguments": "geom geometry, nprecision integer DEFAULT 5",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_assvg",
            "return_type": "text",
            "arguments": "geom geometry, rel integer DEFAULT 0, maxdecimaldigits integer DEFAULT 15",
            "type": "FUNCTION"
        },
        {
            "name": "public._st_asgml",
            "return_type": "text",
            "arguments": "integer, geometry, integer, integer, text, text",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_asgml",
            "return_type": "text",
            "arguments": "geom geometry, maxdecimaldigits integer DEFAULT 15, options integer DEFAULT 0",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_asgml",
            "return_type": "text",
            "arguments": "version integer, geom geometry, maxdecimaldigits integer DEFAULT 15, options integer DEFAULT 0, nprefix text DEFAULT NULL::text, id text DEFAULT NULL::text",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_askml",
            "return_type": "text",
            "arguments": "geom geometry, maxdecimaldigits integer DEFAULT 15, nprefix text DEFAULT ''::text",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_asgeojson",
            "return_type": "text",
            "arguments": "geom geometry, maxdecimaldigits integer DEFAULT 9, options integer DEFAULT 8",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_asgeojson",
            "return_type": "text",
            "arguments": "r record, geom_column text DEFAULT ''::text, maxdecimaldigits integer DEFAULT 9, pretty_bool boolean DEFAULT false",
            "type": "FUNCTION"
        },
        {
            "name": "public.json",
            "return_type": "json",
            "arguments": "geometry",
            "type": "FUNCTION"
        },
        {
            "name": "public.jsonb",
            "return_type": "jsonb",
            "arguments": "geometry",
            "type": "FUNCTION"
        },
        {
            "name": "public.pgis_asmvt_transfn",
            "return_type": "internal",
            "arguments": "internal, anyelement",
            "type": "FUNCTION"
        },
        {
            "name": "public.pgis_asmvt_transfn",
            "return_type": "internal",
            "arguments": "internal, anyelement, text",
            "type": "FUNCTION"
        },
        {
            "name": "public.pgis_asmvt_transfn",
            "return_type": "internal",
            "arguments": "internal, anyelement, text, integer",
            "type": "FUNCTION"
        },
        {
            "name": "public.pgis_asmvt_transfn",
            "return_type": "internal",
            "arguments": "internal, anyelement, text, integer, text",
            "type": "FUNCTION"
        },
        {
            "name": "public.pgis_asmvt_transfn",
            "return_type": "internal",
            "arguments": "internal, anyelement, text, integer, text, text",
            "type": "FUNCTION"
        },
        {
            "name": "public.pgis_asmvt_finalfn",
            "return_type": "bytea",
            "arguments": "internal",
            "type": "FUNCTION"
        },
        {
            "name": "public.pgis_asmvt_combinefn",
            "return_type": "internal",
            "arguments": "internal, internal",
            "type": "FUNCTION"
        },
        {
            "name": "public.pgis_asmvt_serialfn",
            "return_type": "bytea",
            "arguments": "internal",
            "type": "FUNCTION"
        },
        {
            "name": "public.pgis_asmvt_deserialfn",
            "return_type": "internal",
            "arguments": "bytea, internal",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_asmvt",
            "return_type": "bytea",
            "arguments": "anyelement",
            "type": "a"
        },
        {
            "name": "public.st_asmvt",
            "return_type": "bytea",
            "arguments": "anyelement, text",
            "type": "a"
        },
        {
            "name": "public.st_asmvt",
            "return_type": "bytea",
            "arguments": "anyelement, text, integer",
            "type": "a"
        },
        {
            "name": "public.st_asmvt",
            "return_type": "bytea",
            "arguments": "anyelement, text, integer, text",
            "type": "a"
        },
        {
            "name": "public.st_asmvt",
            "return_type": "bytea",
            "arguments": "anyelement, text, integer, text, text",
            "type": "a"
        },
        {
            "name": "public.st_asmvtgeom",
            "return_type": "geometry",
            "arguments": "geom geometry, bounds box2d, extent integer DEFAULT 4096, buffer integer DEFAULT 256, clip_geom boolean DEFAULT true",
            "type": "FUNCTION"
        },
        {
            "name": "public.postgis_libprotobuf_version",
            "return_type": "text",
            "arguments": "",
            "type": "FUNCTION"
        },
        {
            "name": "public.pgis_asgeobuf_transfn",
            "return_type": "internal",
            "arguments": "internal, anyelement",
            "type": "FUNCTION"
        },
        {
            "name": "public.pgis_asgeobuf_transfn",
            "return_type": "internal",
            "arguments": "internal, anyelement, text",
            "type": "FUNCTION"
        },
        {
            "name": "public.pgis_asgeobuf_finalfn",
            "return_type": "bytea",
            "arguments": "internal",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_asgeobuf",
            "return_type": "bytea",
            "arguments": "anyelement",
            "type": "a"
        },
        {
            "name": "public.st_asgeobuf",
            "return_type": "bytea",
            "arguments": "anyelement, text",
            "type": "a"
        },
        {
            "name": "public.pgis_asflatgeobuf_transfn",
            "return_type": "internal",
            "arguments": "internal, anyelement",
            "type": "FUNCTION"
        },
        {
            "name": "public.pgis_asflatgeobuf_transfn",
            "return_type": "internal",
            "arguments": "internal, anyelement, boolean",
            "type": "FUNCTION"
        },
        {
            "name": "public.pgis_asflatgeobuf_transfn",
            "return_type": "internal",
            "arguments": "internal, anyelement, boolean, text",
            "type": "FUNCTION"
        },
        {
            "name": "public.pgis_asflatgeobuf_finalfn",
            "return_type": "bytea",
            "arguments": "internal",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_asflatgeobuf",
            "return_type": "bytea",
            "arguments": "anyelement",
            "type": "a"
        },
        {
            "name": "public.st_asflatgeobuf",
            "return_type": "bytea",
            "arguments": "anyelement, boolean",
            "type": "a"
        },
        {
            "name": "public.st_asflatgeobuf",
            "return_type": "bytea",
            "arguments": "anyelement, boolean, text",
            "type": "a"
        },
        {
            "name": "public.st_fromflatgeobuftotable",
            "return_type": "void",
            "arguments": "text, text, bytea",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_fromflatgeobuf",
            "return_type": "anyelement",
            "arguments": "anyelement, bytea",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_geohash",
            "return_type": "text",
            "arguments": "geom geometry, maxchars integer DEFAULT 0",
            "type": "FUNCTION"
        },
        {
            "name": "public._st_sortablehash",
            "return_type": "int8",
            "arguments": "geom geometry",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_box2dfromgeohash",
            "return_type": "box2d",
            "arguments": "text, integer DEFAULT NULL::integer",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_pointfromgeohash",
            "return_type": "geometry",
            "arguments": "text, integer DEFAULT NULL::integer",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_geomfromgeohash",
            "return_type": "geometry",
            "arguments": "text, integer DEFAULT NULL::integer",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_numpoints",
            "return_type": "int4",
            "arguments": "geometry",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_numgeometries",
            "return_type": "int4",
            "arguments": "geometry",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_geometryn",
            "return_type": "geometry",
            "arguments": "geometry, integer",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_dimension",
            "return_type": "int4",
            "arguments": "geometry",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_exteriorring",
            "return_type": "geometry",
            "arguments": "geometry",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_numinteriorrings",
            "return_type": "int4",
            "arguments": "geometry",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_numinteriorring",
            "return_type": "int4",
            "arguments": "geometry",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_interiorringn",
            "return_type": "geometry",
            "arguments": "geometry, integer",
            "type": "FUNCTION"
        },
        {
            "name": "public.geometrytype",
            "return_type": "text",
            "arguments": "geometry",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_geometrytype",
            "return_type": "text",
            "arguments": "geometry",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_pointn",
            "return_type": "geometry",
            "arguments": "geometry, integer",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_numpatches",
            "return_type": "int4",
            "arguments": "geometry",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_patchn",
            "return_type": "geometry",
            "arguments": "geometry, integer",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_startpoint",
            "return_type": "geometry",
            "arguments": "geometry",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_endpoint",
            "return_type": "geometry",
            "arguments": "geometry",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_isclosed",
            "return_type": "bool",
            "arguments": "geometry",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_isempty",
            "return_type": "bool",
            "arguments": "geometry",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_asbinary",
            "return_type": "bytea",
            "arguments": "geometry, text",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_asbinary",
            "return_type": "bytea",
            "arguments": "geometry",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_astext",
            "return_type": "text",
            "arguments": "geometry",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_astext",
            "return_type": "text",
            "arguments": "geometry, integer",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_geometryfromtext",
            "return_type": "geometry",
            "arguments": "text",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_geometryfromtext",
            "return_type": "geometry",
            "arguments": "text, integer",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_geomfromtext",
            "return_type": "geometry",
            "arguments": "text",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_geomfromtext",
            "return_type": "geometry",
            "arguments": "text, integer",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_wkttosql",
            "return_type": "geometry",
            "arguments": "text",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_pointfromtext",
            "return_type": "geometry",
            "arguments": "text",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_pointfromtext",
            "return_type": "geometry",
            "arguments": "text, integer",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_linefromtext",
            "return_type": "geometry",
            "arguments": "text",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_linefromtext",
            "return_type": "geometry",
            "arguments": "text, integer",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_polyfromtext",
            "return_type": "geometry",
            "arguments": "text",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_polyfromtext",
            "return_type": "geometry",
            "arguments": "text, integer",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_polygonfromtext",
            "return_type": "geometry",
            "arguments": "text, integer",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_polygonfromtext",
            "return_type": "geometry",
            "arguments": "text",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_mlinefromtext",
            "return_type": "geometry",
            "arguments": "text, integer",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_mlinefromtext",
            "return_type": "geometry",
            "arguments": "text",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_multilinestringfromtext",
            "return_type": "geometry",
            "arguments": "text",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_multilinestringfromtext",
            "return_type": "geometry",
            "arguments": "text, integer",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_mpointfromtext",
            "return_type": "geometry",
            "arguments": "text, integer",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_mpointfromtext",
            "return_type": "geometry",
            "arguments": "text",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_multipointfromtext",
            "return_type": "geometry",
            "arguments": "text",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_mpolyfromtext",
            "return_type": "geometry",
            "arguments": "text, integer",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_mpolyfromtext",
            "return_type": "geometry",
            "arguments": "text",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_multipolygonfromtext",
            "return_type": "geometry",
            "arguments": "text, integer",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_multipolygonfromtext",
            "return_type": "geometry",
            "arguments": "text",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_geomcollfromtext",
            "return_type": "geometry",
            "arguments": "text, integer",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_geomcollfromtext",
            "return_type": "geometry",
            "arguments": "text",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_geomfromwkb",
            "return_type": "geometry",
            "arguments": "bytea",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_geomfromwkb",
            "return_type": "geometry",
            "arguments": "bytea, integer",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_pointfromwkb",
            "return_type": "geometry",
            "arguments": "bytea, integer",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_pointfromwkb",
            "return_type": "geometry",
            "arguments": "bytea",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_linefromwkb",
            "return_type": "geometry",
            "arguments": "bytea, integer",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_linefromwkb",
            "return_type": "geometry",
            "arguments": "bytea",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_linestringfromwkb",
            "return_type": "geometry",
            "arguments": "bytea, integer",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_linestringfromwkb",
            "return_type": "geometry",
            "arguments": "bytea",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_polyfromwkb",
            "return_type": "geometry",
            "arguments": "bytea, integer",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_polyfromwkb",
            "return_type": "geometry",
            "arguments": "bytea",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_polygonfromwkb",
            "return_type": "geometry",
            "arguments": "bytea, integer",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_polygonfromwkb",
            "return_type": "geometry",
            "arguments": "bytea",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_mpointfromwkb",
            "return_type": "geometry",
            "arguments": "bytea, integer",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_mpointfromwkb",
            "return_type": "geometry",
            "arguments": "bytea",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_multipointfromwkb",
            "return_type": "geometry",
            "arguments": "bytea, integer",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_multipointfromwkb",
            "return_type": "geometry",
            "arguments": "bytea",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_multilinefromwkb",
            "return_type": "geometry",
            "arguments": "bytea",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_mlinefromwkb",
            "return_type": "geometry",
            "arguments": "bytea, integer",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_mlinefromwkb",
            "return_type": "geometry",
            "arguments": "bytea",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_mpolyfromwkb",
            "return_type": "geometry",
            "arguments": "bytea, integer",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_mpolyfromwkb",
            "return_type": "geometry",
            "arguments": "bytea",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_multipolyfromwkb",
            "return_type": "geometry",
            "arguments": "bytea, integer",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_multipolyfromwkb",
            "return_type": "geometry",
            "arguments": "bytea",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_geomcollfromwkb",
            "return_type": "geometry",
            "arguments": "bytea, integer",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_geomcollfromwkb",
            "return_type": "geometry",
            "arguments": "bytea",
            "type": "FUNCTION"
        },
        {
            "name": "public._st_maxdistance",
            "return_type": "float8",
            "arguments": "geom1 geometry, geom2 geometry",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_maxdistance",
            "return_type": "float8",
            "arguments": "geom1 geometry, geom2 geometry",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_closestpoint",
            "return_type": "geometry",
            "arguments": "geom1 geometry, geom2 geometry",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_shortestline",
            "return_type": "geometry",
            "arguments": "geom1 geometry, geom2 geometry",
            "type": "FUNCTION"
        },
        {
            "name": "public._st_longestline",
            "return_type": "geometry",
            "arguments": "geom1 geometry, geom2 geometry",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_longestline",
            "return_type": "geometry",
            "arguments": "geom1 geometry, geom2 geometry",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_swapordinates",
            "return_type": "geometry",
            "arguments": "geom geometry, ords cstring",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_flipcoordinates",
            "return_type": "geometry",
            "arguments": "geometry",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_bdpolyfromtext",
            "return_type": "geometry",
            "arguments": "text, integer",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_bdmpolyfromtext",
            "return_type": "geometry",
            "arguments": "text, integer",
            "type": "FUNCTION"
        },
        {
            "name": "public.unlockrows",
            "return_type": "int4",
            "arguments": "text",
            "type": "FUNCTION"
        },
        {
            "name": "public.lockrow",
            "return_type": "int4",
            "arguments": "text, text, text, text, timestamp without time zone",
            "type": "FUNCTION"
        },
        {
            "name": "public.lockrow",
            "return_type": "int4",
            "arguments": "text, text, text, text",
            "type": "FUNCTION"
        },
        {
            "name": "public.lockrow",
            "return_type": "int4",
            "arguments": "text, text, text",
            "type": "FUNCTION"
        },
        {
            "name": "public.lockrow",
            "return_type": "int4",
            "arguments": "text, text, text, timestamp without time zone",
            "type": "FUNCTION"
        },
        {
            "name": "public.addauth",
            "return_type": "bool",
            "arguments": "text",
            "type": "FUNCTION"
        },
        {
            "name": "public.checkauth",
            "return_type": "int4",
            "arguments": "text, text, text",
            "type": "FUNCTION"
        },
        {
            "name": "public.checkauth",
            "return_type": "int4",
            "arguments": "text, text",
            "type": "FUNCTION"
        },
        {
            "name": "public.checkauthtrigger",
            "return_type": "trigger",
            "arguments": "",
            "type": "FUNCTION"
        },
        {
            "name": "public.gettransactionid",
            "return_type": "xid",
            "arguments": "",
            "type": "FUNCTION"
        },
        {
            "name": "public.enablelongtransactions",
            "return_type": "text",
            "arguments": "",
            "type": "FUNCTION"
        },
        {
            "name": "public.longtransactionsenabled",
            "return_type": "bool",
            "arguments": "",
            "type": "FUNCTION"
        },
        {
            "name": "public.disablelongtransactions",
            "return_type": "text",
            "arguments": "",
            "type": "FUNCTION"
        },
        {
            "name": "public.geography_typmod_in",
            "return_type": "int4",
            "arguments": "cstring[]",
            "type": "FUNCTION"
        },
        {
            "name": "public.geography_typmod_out",
            "return_type": "cstring",
            "arguments": "integer",
            "type": "FUNCTION"
        },
        {
            "name": "public.geography_in",
            "return_type": "geography",
            "arguments": "cstring, oid, integer",
            "type": "FUNCTION"
        },
        {
            "name": "public.geography_out",
            "return_type": "cstring",
            "arguments": "geography",
            "type": "FUNCTION"
        },
        {
            "name": "public.geography_recv",
            "return_type": "geography",
            "arguments": "internal, oid, integer",
            "type": "FUNCTION"
        },
        {
            "name": "public.geography_send",
            "return_type": "bytea",
            "arguments": "geography",
            "type": "FUNCTION"
        },
        {
            "name": "public.geography_analyze",
            "return_type": "bool",
            "arguments": "internal",
            "type": "FUNCTION"
        },
        {
            "name": "public.geography",
            "return_type": "geography",
            "arguments": "geography, integer, boolean",
            "type": "FUNCTION"
        },
        {
            "name": "public.geography",
            "return_type": "geography",
            "arguments": "bytea",
            "type": "FUNCTION"
        },
        {
            "name": "public.bytea",
            "return_type": "bytea",
            "arguments": "geography",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_astext",
            "return_type": "text",
            "arguments": "geography",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_astext",
            "return_type": "text",
            "arguments": "geography, integer",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_astext",
            "return_type": "text",
            "arguments": "text",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_geographyfromtext",
            "return_type": "geography",
            "arguments": "text",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_geogfromtext",
            "return_type": "geography",
            "arguments": "text",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_geogfromwkb",
            "return_type": "geography",
            "arguments": "bytea",
            "type": "FUNCTION"
        },
        {
            "name": "public.postgis_typmod_dims",
            "return_type": "int4",
            "arguments": "integer",
            "type": "FUNCTION"
        },
        {
            "name": "public.postgis_typmod_srid",
            "return_type": "int4",
            "arguments": "integer",
            "type": "FUNCTION"
        },
        {
            "name": "public.postgis_typmod_type",
            "return_type": "text",
            "arguments": "integer",
            "type": "FUNCTION"
        },
        {
            "name": "public.geography",
            "return_type": "geography",
            "arguments": "geometry",
            "type": "FUNCTION"
        },
        {
            "name": "public.geometry",
            "return_type": "geometry",
            "arguments": "geography",
            "type": "FUNCTION"
        },
        {
            "name": "public.geography_gist_consistent",
            "return_type": "bool",
            "arguments": "internal, geography, integer",
            "type": "FUNCTION"
        },
        {
            "name": "public.geography_gist_compress",
            "return_type": "internal",
            "arguments": "internal",
            "type": "FUNCTION"
        },
        {
            "name": "public.geography_gist_penalty",
            "return_type": "internal",
            "arguments": "internal, internal, internal",
            "type": "FUNCTION"
        },
        {
            "name": "public.geography_gist_picksplit",
            "return_type": "internal",
            "arguments": "internal, internal",
            "type": "FUNCTION"
        },
        {
            "name": "public.geography_gist_union",
            "return_type": "internal",
            "arguments": "bytea, internal",
            "type": "FUNCTION"
        },
        {
            "name": "public.geography_gist_same",
            "return_type": "internal",
            "arguments": "box2d, box2d, internal",
            "type": "FUNCTION"
        },
        {
            "name": "public.geography_gist_decompress",
            "return_type": "internal",
            "arguments": "internal",
            "type": "FUNCTION"
        },
        {
            "name": "public.geography_overlaps",
            "return_type": "bool",
            "arguments": "geography, geography",
            "type": "FUNCTION"
        },
        {
            "name": "public.geography_distance_knn",
            "return_type": "float8",
            "arguments": "geography, geography",
            "type": "FUNCTION"
        },
        {
            "name": "public.geography_gist_distance",
            "return_type": "float8",
            "arguments": "internal, geography, integer",
            "type": "FUNCTION"
        },
        {
            "name": "public.overlaps_geog",
            "return_type": "bool",
            "arguments": "gidx, geography",
            "type": "FUNCTION"
        },
        {
            "name": "public.overlaps_geog",
            "return_type": "bool",
            "arguments": "gidx, gidx",
            "type": "FUNCTION"
        },
        {
            "name": "public.overlaps_geog",
            "return_type": "bool",
            "arguments": "geography, gidx",
            "type": "FUNCTION"
        },
        {
            "name": "public.geog_brin_inclusion_add_value",
            "return_type": "bool",
            "arguments": "internal, internal, internal, internal",
            "type": "FUNCTION"
        },
        {
            "name": "public.geography_lt",
            "return_type": "bool",
            "arguments": "geography, geography",
            "type": "FUNCTION"
        },
        {
            "name": "public.geography_le",
            "return_type": "bool",
            "arguments": "geography, geography",
            "type": "FUNCTION"
        },
        {
            "name": "public.geography_gt",
            "return_type": "bool",
            "arguments": "geography, geography",
            "type": "FUNCTION"
        },
        {
            "name": "public.geography_ge",
            "return_type": "bool",
            "arguments": "geography, geography",
            "type": "FUNCTION"
        },
        {
            "name": "public.geography_eq",
            "return_type": "bool",
            "arguments": "geography, geography",
            "type": "FUNCTION"
        },
        {
            "name": "public.geography_cmp",
            "return_type": "int4",
            "arguments": "geography, geography",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_assvg",
            "return_type": "text",
            "arguments": "geog geography, rel integer DEFAULT 0, maxdecimaldigits integer DEFAULT 15",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_assvg",
            "return_type": "text",
            "arguments": "text",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_asgml",
            "return_type": "text",
            "arguments": "version integer, geog geography, maxdecimaldigits integer DEFAULT 15, options integer DEFAULT 0, nprefix text DEFAULT 'gml'::text, id text DEFAULT ''::text",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_asgml",
            "return_type": "text",
            "arguments": "geog geography, maxdecimaldigits integer DEFAULT 15, options integer DEFAULT 0, nprefix text DEFAULT 'gml'::text, id text DEFAULT ''::text",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_asgml",
            "return_type": "text",
            "arguments": "text",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_askml",
            "return_type": "text",
            "arguments": "geog geography, maxdecimaldigits integer DEFAULT 15, nprefix text DEFAULT ''::text",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_askml",
            "return_type": "text",
            "arguments": "text",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_asgeojson",
            "return_type": "text",
            "arguments": "geog geography, maxdecimaldigits integer DEFAULT 9, options integer DEFAULT 0",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_asgeojson",
            "return_type": "text",
            "arguments": "text",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_distance",
            "return_type": "float8",
            "arguments": "geog1 geography, geog2 geography, use_spheroid boolean DEFAULT true",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_distance",
            "return_type": "float8",
            "arguments": "text, text",
            "type": "FUNCTION"
        },
        {
            "name": "public._st_expand",
            "return_type": "geography",
            "arguments": "geography, double precision",
            "type": "FUNCTION"
        },
        {
            "name": "public._st_distanceuncached",
            "return_type": "float8",
            "arguments": "geography, geography, double precision, boolean",
            "type": "FUNCTION"
        },
        {
            "name": "public._st_distanceuncached",
            "return_type": "float8",
            "arguments": "geography, geography, boolean",
            "type": "FUNCTION"
        },
        {
            "name": "public._st_distanceuncached",
            "return_type": "float8",
            "arguments": "geography, geography",
            "type": "FUNCTION"
        },
        {
            "name": "public._st_distancetree",
            "return_type": "float8",
            "arguments": "geography, geography, double precision, boolean",
            "type": "FUNCTION"
        },
        {
            "name": "public._st_distancetree",
            "return_type": "float8",
            "arguments": "geography, geography",
            "type": "FUNCTION"
        },
        {
            "name": "public._st_dwithinuncached",
            "return_type": "bool",
            "arguments": "geography, geography, double precision, boolean",
            "type": "FUNCTION"
        },
        {
            "name": "public._st_dwithinuncached",
            "return_type": "bool",
            "arguments": "geography, geography, double precision",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_area",
            "return_type": "float8",
            "arguments": "geog geography, use_spheroid boolean DEFAULT true",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_area",
            "return_type": "float8",
            "arguments": "text",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_length",
            "return_type": "float8",
            "arguments": "geog geography, use_spheroid boolean DEFAULT true",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_length",
            "return_type": "float8",
            "arguments": "text",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_project",
            "return_type": "geography",
            "arguments": "geog geography, distance double precision, azimuth double precision",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_azimuth",
            "return_type": "float8",
            "arguments": "geog1 geography, geog2 geography",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_perimeter",
            "return_type": "float8",
            "arguments": "geog geography, use_spheroid boolean DEFAULT true",
            "type": "FUNCTION"
        },
        {
            "name": "public._st_pointoutside",
            "return_type": "geography",
            "arguments": "geography",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_segmentize",
            "return_type": "geography",
            "arguments": "geog geography, max_segment_length double precision",
            "type": "FUNCTION"
        },
        {
            "name": "public._st_bestsrid",
            "return_type": "int4",
            "arguments": "geography, geography",
            "type": "FUNCTION"
        },
        {
            "name": "public._st_bestsrid",
            "return_type": "int4",
            "arguments": "geography",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_buffer",
            "return_type": "geography",
            "arguments": "geography, double precision",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_buffer",
            "return_type": "geography",
            "arguments": "geography, double precision, integer",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_buffer",
            "return_type": "geography",
            "arguments": "geography, double precision, text",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_buffer",
            "return_type": "geometry",
            "arguments": "text, double precision",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_buffer",
            "return_type": "geometry",
            "arguments": "text, double precision, integer",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_buffer",
            "return_type": "geometry",
            "arguments": "text, double precision, text",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_intersection",
            "return_type": "geography",
            "arguments": "geography, geography",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_intersection",
            "return_type": "geometry",
            "arguments": "text, text",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_asbinary",
            "return_type": "bytea",
            "arguments": "geography",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_asbinary",
            "return_type": "bytea",
            "arguments": "geography, text",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_asewkt",
            "return_type": "text",
            "arguments": "geography",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_asewkt",
            "return_type": "text",
            "arguments": "geography, integer",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_asewkt",
            "return_type": "text",
            "arguments": "text",
            "type": "FUNCTION"
        },
        {
            "name": "public.geometrytype",
            "return_type": "text",
            "arguments": "geography",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_summary",
            "return_type": "text",
            "arguments": "geography",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_geohash",
            "return_type": "text",
            "arguments": "geog geography, maxchars integer DEFAULT 0",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_srid",
            "return_type": "int4",
            "arguments": "geog geography",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_setsrid",
            "return_type": "geography",
            "arguments": "geog geography, srid integer",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_centroid",
            "return_type": "geography",
            "arguments": "geography, use_spheroid boolean DEFAULT true",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_centroid",
            "return_type": "geometry",
            "arguments": "text",
            "type": "FUNCTION"
        },
        {
            "name": "public._st_covers",
            "return_type": "bool",
            "arguments": "geog1 geography, geog2 geography",
            "type": "FUNCTION"
        },
        {
            "name": "public._st_dwithin",
            "return_type": "bool",
            "arguments": "geog1 geography, geog2 geography, tolerance double precision, use_spheroid boolean DEFAULT true",
            "type": "FUNCTION"
        },
        {
            "name": "public._st_coveredby",
            "return_type": "bool",
            "arguments": "geog1 geography, geog2 geography",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_covers",
            "return_type": "bool",
            "arguments": "geog1 geography, geog2 geography",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_dwithin",
            "return_type": "bool",
            "arguments": "geog1 geography, geog2 geography, tolerance double precision, use_spheroid boolean DEFAULT true",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_coveredby",
            "return_type": "bool",
            "arguments": "geog1 geography, geog2 geography",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_intersects",
            "return_type": "bool",
            "arguments": "geog1 geography, geog2 geography",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_covers",
            "return_type": "bool",
            "arguments": "text, text",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_coveredby",
            "return_type": "bool",
            "arguments": "text, text",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_dwithin",
            "return_type": "bool",
            "arguments": "text, text, double precision",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_intersects",
            "return_type": "bool",
            "arguments": "text, text",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_distancesphere",
            "return_type": "float8",
            "arguments": "geom1 geometry, geom2 geometry",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_distancesphere",
            "return_type": "float8",
            "arguments": "geom1 geometry, geom2 geometry, radius double precision",
            "type": "FUNCTION"
        },
        {
            "name": "public.postgis_type_name",
            "return_type": "varchar",
            "arguments": "geomname character varying, coord_dimension integer, use_new_name boolean DEFAULT true",
            "type": "FUNCTION"
        },
        {
            "name": "public.postgis_constraint_srid",
            "return_type": "int4",
            "arguments": "geomschema text, geomtable text, geomcolumn text",
            "type": "FUNCTION"
        },
        {
            "name": "public.postgis_constraint_dims",
            "return_type": "int4",
            "arguments": "geomschema text, geomtable text, geomcolumn text",
            "type": "FUNCTION"
        },
        {
            "name": "public.postgis_constraint_type",
            "return_type": "varchar",
            "arguments": "geomschema text, geomtable text, geomcolumn text",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_3ddistance",
            "return_type": "float8",
            "arguments": "geom1 geometry, geom2 geometry",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_3dmaxdistance",
            "return_type": "float8",
            "arguments": "geom1 geometry, geom2 geometry",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_3dclosestpoint",
            "return_type": "geometry",
            "arguments": "geom1 geometry, geom2 geometry",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_3dshortestline",
            "return_type": "geometry",
            "arguments": "geom1 geometry, geom2 geometry",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_3dlongestline",
            "return_type": "geometry",
            "arguments": "geom1 geometry, geom2 geometry",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_coorddim",
            "return_type": "int2",
            "arguments": "geometry geometry",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_curvetoline",
            "return_type": "geometry",
            "arguments": "geom geometry, tol double precision DEFAULT 32, toltype integer DEFAULT 0, flags integer DEFAULT 0",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_hasarc",
            "return_type": "bool",
            "arguments": "geometry geometry",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_linetocurve",
            "return_type": "geometry",
            "arguments": "geometry geometry",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_point",
            "return_type": "geometry",
            "arguments": "double precision, double precision",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_point",
            "return_type": "geometry",
            "arguments": "double precision, double precision, srid integer",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_pointz",
            "return_type": "geometry",
            "arguments": "xcoordinate double precision, ycoordinate double precision, zcoordinate double precision, srid integer DEFAULT 0",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_pointm",
            "return_type": "geometry",
            "arguments": "xcoordinate double precision, ycoordinate double precision, mcoordinate double precision, srid integer DEFAULT 0",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_pointzm",
            "return_type": "geometry",
            "arguments": "xcoordinate double precision, ycoordinate double precision, zcoordinate double precision, mcoordinate double precision, srid integer DEFAULT 0",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_polygon",
            "return_type": "geometry",
            "arguments": "geometry, integer",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_wkbtosql",
            "return_type": "geometry",
            "arguments": "wkb bytea",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_locatebetween",
            "return_type": "geometry",
            "arguments": "geometry geometry, frommeasure double precision, tomeasure double precision, leftrightoffset double precision DEFAULT 0.0",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_locatealong",
            "return_type": "geometry",
            "arguments": "geometry geometry, measure double precision, leftrightoffset double precision DEFAULT 0.0",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_locatebetweenelevations",
            "return_type": "geometry",
            "arguments": "geometry geometry, fromelevation double precision, toelevation double precision",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_interpolatepoint",
            "return_type": "float8",
            "arguments": "line geometry, point geometry",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_hexagon",
            "return_type": "geometry",
            "arguments": "size double precision, cell_i integer, cell_j integer, origin geometry DEFAULT '010100000000000000000000000000000000000000'::geometry",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_square",
            "return_type": "geometry",
            "arguments": "size double precision, cell_i integer, cell_j integer, origin geometry DEFAULT '010100000000000000000000000000000000000000'::geometry",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_hexagongrid",
            "return_type": "record",
            "arguments": "size double precision, bounds geometry, OUT geom geometry, OUT i integer, OUT j integer",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_squaregrid",
            "return_type": "record",
            "arguments": "size double precision, bounds geometry, OUT geom geometry, OUT i integer, OUT j integer",
            "type": "FUNCTION"
        },
        {
            "name": "public.contains_2d",
            "return_type": "bool",
            "arguments": "box2df, geometry",
            "type": "FUNCTION"
        },
        {
            "name": "public.is_contained_2d",
            "return_type": "bool",
            "arguments": "box2df, geometry",
            "type": "FUNCTION"
        },
        {
            "name": "public.overlaps_2d",
            "return_type": "bool",
            "arguments": "box2df, geometry",
            "type": "FUNCTION"
        },
        {
            "name": "public.overlaps_2d",
            "return_type": "bool",
            "arguments": "box2df, box2df",
            "type": "FUNCTION"
        },
        {
            "name": "public.contains_2d",
            "return_type": "bool",
            "arguments": "box2df, box2df",
            "type": "FUNCTION"
        },
        {
            "name": "public.is_contained_2d",
            "return_type": "bool",
            "arguments": "box2df, box2df",
            "type": "FUNCTION"
        },
        {
            "name": "public.contains_2d",
            "return_type": "bool",
            "arguments": "geometry, box2df",
            "type": "FUNCTION"
        },
        {
            "name": "public.is_contained_2d",
            "return_type": "bool",
            "arguments": "geometry, box2df",
            "type": "FUNCTION"
        },
        {
            "name": "public.overlaps_2d",
            "return_type": "bool",
            "arguments": "geometry, box2df",
            "type": "FUNCTION"
        },
        {
            "name": "public.overlaps_nd",
            "return_type": "bool",
            "arguments": "gidx, geometry",
            "type": "FUNCTION"
        },
        {
            "name": "public.overlaps_nd",
            "return_type": "bool",
            "arguments": "gidx, gidx",
            "type": "FUNCTION"
        },
        {
            "name": "public.overlaps_nd",
            "return_type": "bool",
            "arguments": "geometry, gidx",
            "type": "FUNCTION"
        },
        {
            "name": "public.geom2d_brin_inclusion_add_value",
            "return_type": "bool",
            "arguments": "internal, internal, internal, internal",
            "type": "FUNCTION"
        },
        {
            "name": "public.geom3d_brin_inclusion_add_value",
            "return_type": "bool",
            "arguments": "internal, internal, internal, internal",
            "type": "FUNCTION"
        },
        {
            "name": "public.geom4d_brin_inclusion_add_value",
            "return_type": "bool",
            "arguments": "internal, internal, internal, internal",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_simplifypolygonhull",
            "return_type": "geometry",
            "arguments": "geom geometry, vertex_fraction double precision, is_outer boolean DEFAULT true",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_concavehull",
            "return_type": "geometry",
            "arguments": "param_geom geometry, param_pctconvex double precision, param_allow_holes boolean DEFAULT false",
            "type": "FUNCTION"
        },
        {
            "name": "public._st_asx3d",
            "return_type": "text",
            "arguments": "integer, geometry, integer, integer, text",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_asx3d",
            "return_type": "text",
            "arguments": "geom geometry, maxdecimaldigits integer DEFAULT 15, options integer DEFAULT 0",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_angle",
            "return_type": "float8",
            "arguments": "line1 geometry, line2 geometry",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_3dlineinterpolatepoint",
            "return_type": "geometry",
            "arguments": "geometry, double precision",
            "type": "FUNCTION"
        },
        {
            "name": "public.geometry_spgist_config_2d",
            "return_type": "void",
            "arguments": "internal, internal",
            "type": "FUNCTION"
        },
        {
            "name": "public.geometry_spgist_choose_2d",
            "return_type": "void",
            "arguments": "internal, internal",
            "type": "FUNCTION"
        },
        {
            "name": "public.geometry_spgist_picksplit_2d",
            "return_type": "void",
            "arguments": "internal, internal",
            "type": "FUNCTION"
        },
        {
            "name": "public.geometry_spgist_inner_consistent_2d",
            "return_type": "void",
            "arguments": "internal, internal",
            "type": "FUNCTION"
        },
        {
            "name": "public.geometry_spgist_leaf_consistent_2d",
            "return_type": "bool",
            "arguments": "internal, internal",
            "type": "FUNCTION"
        },
        {
            "name": "public.geometry_spgist_compress_2d",
            "return_type": "internal",
            "arguments": "internal",
            "type": "FUNCTION"
        },
        {
            "name": "public.geometry_overlaps_3d",
            "return_type": "bool",
            "arguments": "geom1 geometry, geom2 geometry",
            "type": "FUNCTION"
        },
        {
            "name": "public.geometry_contains_3d",
            "return_type": "bool",
            "arguments": "geom1 geometry, geom2 geometry",
            "type": "FUNCTION"
        },
        {
            "name": "public.geometry_contained_3d",
            "return_type": "bool",
            "arguments": "geom1 geometry, geom2 geometry",
            "type": "FUNCTION"
        },
        {
            "name": "public.geometry_same_3d",
            "return_type": "bool",
            "arguments": "geom1 geometry, geom2 geometry",
            "type": "FUNCTION"
        },
        {
            "name": "public.geometry_spgist_config_3d",
            "return_type": "void",
            "arguments": "internal, internal",
            "type": "FUNCTION"
        },
        {
            "name": "public.geometry_spgist_choose_3d",
            "return_type": "void",
            "arguments": "internal, internal",
            "type": "FUNCTION"
        },
        {
            "name": "public.geometry_spgist_picksplit_3d",
            "return_type": "void",
            "arguments": "internal, internal",
            "type": "FUNCTION"
        },
        {
            "name": "public.geometry_spgist_inner_consistent_3d",
            "return_type": "void",
            "arguments": "internal, internal",
            "type": "FUNCTION"
        },
        {
            "name": "public.geometry_spgist_leaf_consistent_3d",
            "return_type": "bool",
            "arguments": "internal, internal",
            "type": "FUNCTION"
        },
        {
            "name": "public.geometry_spgist_compress_3d",
            "return_type": "internal",
            "arguments": "internal",
            "type": "FUNCTION"
        },
        {
            "name": "public.geometry_spgist_config_nd",
            "return_type": "void",
            "arguments": "internal, internal",
            "type": "FUNCTION"
        },
        {
            "name": "public.geometry_spgist_choose_nd",
            "return_type": "void",
            "arguments": "internal, internal",
            "type": "FUNCTION"
        },
        {
            "name": "public.geometry_spgist_picksplit_nd",
            "return_type": "void",
            "arguments": "internal, internal",
            "type": "FUNCTION"
        },
        {
            "name": "public.geometry_spgist_inner_consistent_nd",
            "return_type": "void",
            "arguments": "internal, internal",
            "type": "FUNCTION"
        },
        {
            "name": "public.geometry_spgist_leaf_consistent_nd",
            "return_type": "bool",
            "arguments": "internal, internal",
            "type": "FUNCTION"
        },
        {
            "name": "public.geometry_spgist_compress_nd",
            "return_type": "internal",
            "arguments": "internal",
            "type": "FUNCTION"
        },
        {
            "name": "public.geography_spgist_config_nd",
            "return_type": "void",
            "arguments": "internal, internal",
            "type": "FUNCTION"
        },
        {
            "name": "public.geography_spgist_choose_nd",
            "return_type": "void",
            "arguments": "internal, internal",
            "type": "FUNCTION"
        },
        {
            "name": "public.geography_spgist_picksplit_nd",
            "return_type": "void",
            "arguments": "internal, internal",
            "type": "FUNCTION"
        },
        {
            "name": "public.geography_spgist_inner_consistent_nd",
            "return_type": "void",
            "arguments": "internal, internal",
            "type": "FUNCTION"
        },
        {
            "name": "public.geography_spgist_leaf_consistent_nd",
            "return_type": "bool",
            "arguments": "internal, internal",
            "type": "FUNCTION"
        },
        {
            "name": "public.geography_spgist_compress_nd",
            "return_type": "internal",
            "arguments": "internal",
            "type": "FUNCTION"
        },
        {
            "name": "public.st_letters",
            "return_type": "geometry",
            "arguments": "letters text, font json DEFAULT NULL::json",
            "type": "FUNCTION"
        },
        {
            "name": "public.unaccent",
            "return_type": "text",
            "arguments": "regdictionary, text",
            "type": "FUNCTION"
        },
        {
            "name": "public.unaccent",
            "return_type": "text",
            "arguments": "text",
            "type": "FUNCTION"
        },
        {
            "name": "public.unaccent_init",
            "return_type": "internal",
            "arguments": "internal",
            "type": "FUNCTION"
        },
        {
            "name": "public.unaccent_lexize",
            "return_type": "internal",
            "arguments": "internal, internal, internal, internal",
            "type": "FUNCTION"
        },
        {
            "name": "ap.collectionunitobject",
            "return_type": "record",
            "arguments": "_collectionunitid integer",
            "type": "FUNCTION"
        },
        {
            "name": "ap.datasetobject",
            "return_type": "record",
            "arguments": "_datasetid integer",
            "type": "FUNCTION"
        },
        {
            "name": "ap.explorersearch",
            "return_type": "record",
            "arguments": "_taxonids integer[] DEFAULT NULL::integer[], _elemtypeids integer[] DEFAULT NULL::integer[], _taphtypeids integer[] DEFAULT NULL::integer[], _depenvids integer[] DEFAULT NULL::integer[], _abundpct integer DEFAULT NULL::integer, _datasettypeid integer DEFAULT NULL::integer, _keywordid integer DEFAULT NULL::integer, _coords character varying DEFAULT NULL::character varying, _gpid integer DEFAULT NULL::integer, _altmin integer DEFAULT NULL::integer, _altmax integer DEFAULT NULL::integer, _coltypeid integer DEFAULT NULL::integer, _dbid integer DEFAULT NULL::integer, _sitename character varying DEFAULT NULL::character varying, _contactid integer DEFAULT NULL::integer, _ageold integer DEFAULT NULL::integer, _ageyoung integer DEFAULT NULL::integer, _agedocontain boolean DEFAULT true, _agedirectdate boolean DEFAULT false, _subdate date DEFAULT NULL::date, _debug boolean DEFAULT false",
            "type": "FUNCTION"
        },
        {
            "name": "ap.getauthors",
            "return_type": "record",
            "arguments": "",
            "type": "FUNCTION"
        },
        {
            "name": "ap.getcollectiontypes",
            "return_type": "record",
            "arguments": "",
            "type": "FUNCTION"
        },
        {
            "name": "ap.getdatasettypes",
            "return_type": "record",
            "arguments": "",
            "type": "FUNCTION"
        },
        {
            "name": "ap.getdeptenvtypes",
            "return_type": "record",
            "arguments": "_depenvtid integer",
            "type": "FUNCTION"
        },
        {
            "name": "ap.getdeptenvtypesroot",
            "return_type": "record",
            "arguments": "",
            "type": "FUNCTION"
        },
        {
            "name": "ap.getelementtypes",
            "return_type": "record",
            "arguments": "_taxagroupid character varying",
            "type": "FUNCTION"
        },
        {
            "name": "ap.getelementtypesbytaxonid",
            "return_type": "record",
            "arguments": "_taxonid integer",
            "type": "FUNCTION"
        },
        {
            "name": "ap.getgeochrondatasetbyassociateddatasetid",
            "return_type": "record",
            "arguments": "_datasetid integer",
            "type": "FUNCTION"
        },
        {
            "name": "ap.getkeywords",
            "return_type": "record",
            "arguments": "",
            "type": "FUNCTION"
        },
        {
            "name": "ap.getpeople",
            "return_type": "record",
            "arguments": "",
            "type": "FUNCTION"
        },
        {
            "name": "ap.gettaphonomicsystems",
            "return_type": "record",
            "arguments": "datasettypeid integer",
            "type": "FUNCTION"
        },
        {
            "name": "ap.gettaphonomictypes",
            "return_type": "record",
            "arguments": "_taphonomicsystemid integer",
            "type": "FUNCTION"
        },
        {
            "name": "ap.gettaxagrouptypes",
            "return_type": "record",
            "arguments": "",
            "type": "FUNCTION"
        },
        {
            "name": "ap.sample",
            "return_type": "record",
            "arguments": "_datasetid integer",
            "type": "FUNCTION"
        },
        {
            "name": "ap.searchsitename",
            "return_type": "record",
            "arguments": "_sitename character varying",
            "type": "FUNCTION"
        },
        {
            "name": "ap.sitelink",
            "return_type": "record",
            "arguments": "_siteid integer",
            "type": "FUNCTION"
        },
        {
            "name": "ap.siteobject",
            "return_type": "record",
            "arguments": "_siteid integer[]",
            "type": "FUNCTION"
        },
        {
            "name": "ap.siteobject",
            "return_type": "record",
            "arguments": "_siteid integer",
            "type": "FUNCTION"
        },
        {
            "name": "ap.updategpsites",
            "return_type": "trigger",
            "arguments": "",
            "type": "FUNCTION"
        },
        {
            "name": "da.chronologybyid",
            "return_type": "record",
            "arguments": "_chronid integer",
            "type": "FUNCTION"
        },
        {
            "name": "da.datasetbyid",
            "return_type": "record",
            "arguments": "_dataid integer",
            "type": "FUNCTION"
        },
        {
            "name": "doi.agerange",
            "return_type": "record",
            "arguments": "dsid integer[]",
            "type": "FUNCTION"
        },
        {
            "name": "doi.agerange",
            "return_type": "record",
            "arguments": "dsid integer",
            "type": "FUNCTION"
        },
        {
            "name": "doi.chronmeta",
            "return_type": "record",
            "arguments": "dsid integer[]",
            "type": "FUNCTION"
        },
        {
            "name": "doi.datasetauthors",
            "return_type": "record",
            "arguments": "dsid integer[]",
            "type": "FUNCTION"
        },
        {
            "name": "doi.datasetauthors",
            "return_type": "record",
            "arguments": "dsid integer",
            "type": "FUNCTION"
        },
        {
            "name": "doi.datasetchanged",
            "return_type": "record",
            "arguments": "",
            "type": "FUNCTION"
        },
        {
            "name": "doi.datasetinfo",
            "return_type": "record",
            "arguments": "dsid integer[]",
            "type": "FUNCTION"
        },
        {
            "name": "doi.datasetinfo",
            "return_type": "record",
            "arguments": "dsid integer",
            "type": "FUNCTION"
        },
        {
            "name": "doi.doiapi",
            "return_type": "jsonb",
            "arguments": "dsid integer[]",
            "type": "FUNCTION"
        },
        {
            "name": "doi.doifreeze",
            "return_type": "record",
            "arguments": "dsid integer[]",
            "type": "FUNCTION"
        },
        {
            "name": "doi.doireturn",
            "return_type": "record",
            "arguments": "dsid integer[]",
            "type": "FUNCTION"
        },
        {
            "name": "doi.doireturn",
            "return_type": "record",
            "arguments": "dsid integer",
            "type": "FUNCTION"
        },
        {
            "name": "doi.inds",
            "return_type": "bool",
            "arguments": "dsid integer",
            "type": "FUNCTION"
        },
        {
            "name": "doi.lastdayds",
            "return_type": "record",
            "arguments": "",
            "type": "FUNCTION"
        },
        {
            "name": "doi.ndbdata",
            "return_type": "record",
            "arguments": "dsid integer[]",
            "type": "FUNCTION"
        },
        {
            "name": "doi.ndbdata",
            "return_type": "record",
            "arguments": "dsid integer",
            "type": "FUNCTION"
        },
        {
            "name": "ndb.compute_cnratio",
            "return_type": "trigger",
            "arguments": "",
            "type": "FUNCTION"
        },
        {
            "name": "ndb.contacts_delete_fn",
            "return_type": "trigger",
            "arguments": "",
            "type": "FUNCTION"
        },
        {
            "name": "ndb.datasetconstitdb",
            "return_type": "record",
            "arguments": "startperiod integer DEFAULT 0, endperiod integer DEFAULT 1",
            "type": "FUNCTION"
        },
        {
            "name": "ndb.datasetcontribs",
            "return_type": "record",
            "arguments": "startperiod integer DEFAULT 0, endperiod integer DEFAULT 1",
            "type": "FUNCTION"
        },
        {
            "name": "ndb.datasetsummary",
            "return_type": "record",
            "arguments": "startperiod integer DEFAULT 0, endperiod integer DEFAULT 1",
            "type": "FUNCTION"
        },
        {
            "name": "ndb.datasettypecontrib",
            "return_type": "record",
            "arguments": "startperiod integer DEFAULT 0, endperiod integer DEFAULT 1",
            "type": "FUNCTION"
        },
        {
            "name": "ndb.getalltables",
            "return_type": "record",
            "arguments": "_schema text",
            "type": "FUNCTION"
        },
        {
            "name": "ndb.rawbymonth",
            "return_type": "record",
            "arguments": "startperiod integer DEFAULT 0, endperiod integer DEFAULT 1",
            "type": "FUNCTION"
        },
        {
            "name": "ndb.sites_update_bbox_fn",
            "return_type": "trigger",
            "arguments": "",
            "type": "FUNCTION"
        },
        {
            "name": "ndb.stewardcontrib",
            "return_type": "record",
            "arguments": "startperiod integer DEFAULT 0, endperiod integer DEFAULT 1",
            "type": "FUNCTION"
        },
        {
            "name": "ndb.update_recdatemodified",
            "return_type": "trigger",
            "arguments": "",
            "type": "FUNCTION"
        },
        {
            "name": "public.datasetchanged",
            "return_type": "record",
            "arguments": "",
            "type": "FUNCTION"
        },
        {
            "name": "public.getdatasettypeshavingdata",
            "return_type": "record",
            "arguments": "",
            "type": "FUNCTION"
        },
        {
            "name": "public.getspecimenisotopedataset",
            "return_type": "record",
            "arguments": "_datasetid integer",
            "type": "FUNCTION"
        },
        {
            "name": "public.gettaphonomictypesbyidlist",
            "return_type": "record",
            "arguments": "_taphonomictypeids character varying",
            "type": "FUNCTION"
        },
        {
            "name": "public.inds",
            "return_type": "bool",
            "arguments": "dsid integer",
            "type": "FUNCTION"
        },
        {
            "name": "public.ndbdata",
            "return_type": "json",
            "arguments": "dsid integer",
            "type": "FUNCTION"
        },
        {
            "name": "public.teststuff",
            "return_type": "bool",
            "arguments": "",
            "type": "FUNCTION"
        },
        {
            "name": "public.teststuff",
            "return_type": "bool",
            "arguments": "_handle character varying",
            "type": "FUNCTION"
        },
        {
            "name": "public.updatereplacepublicationid",
            "return_type": "record",
            "arguments": "_keeppubid integer, _deposepubid integer",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getagetypeid",
            "return_type": "int4",
            "arguments": "_agetype character varying",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getagetypestable",
            "return_type": "agetypes",
            "arguments": "",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getaggregatechronbydatasetid",
            "return_type": "record",
            "arguments": "_aggregatedatasetid integer",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getaggregatedatasetbyname",
            "return_type": "record",
            "arguments": "_name character varying",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getaggregateordertypes",
            "return_type": "record",
            "arguments": "",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getaliascontactnames",
            "return_type": "record",
            "arguments": "",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getalldatasetauthors",
            "return_type": "varchar",
            "arguments": "",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getalldatasetpis",
            "return_type": "varchar",
            "arguments": "",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getanalysisunit",
            "return_type": "int4",
            "arguments": "_collectionunitid integer, _analunitname character varying DEFAULT NULL::character varying, _depth double precision DEFAULT NULL::double precision, _thickness double precision DEFAULT NULL::double precision",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getanalysisunitbyid",
            "return_type": "record",
            "arguments": "_analunitid integer",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getanalysisunitsamplecount",
            "return_type": "int4",
            "arguments": "_analunitid integer",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getanalysisunitsbycollunitid",
            "return_type": "record",
            "arguments": "_collunitid integer",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getbiochemdatasetbyid",
            "return_type": "record",
            "arguments": "_datasetid integer",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getcalibrationcurvestable",
            "return_type": "record",
            "arguments": "",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getcalibrationprogramstable",
            "return_type": "record",
            "arguments": "",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getchildtaxa",
            "return_type": "record",
            "arguments": "_taxonname character varying",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getchildtaxacount",
            "return_type": "int4",
            "arguments": "_highertaxonid integer",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getchildtaxaforallsites",
            "return_type": "record",
            "arguments": "_taxonname character varying",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getchronconroltypebyname",
            "return_type": "record",
            "arguments": "_chroncontroltype character varying",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getchroncontrolsbychroncontrolid",
            "return_type": "record",
            "arguments": "_chroncontrolid integer",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getchroncontroltypehighestid",
            "return_type": "record",
            "arguments": "_chroncontroltypeid integer",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getchroncontroltypestable",
            "return_type": "record",
            "arguments": "",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getchronocontrolsbyanalysisunitid",
            "return_type": "int4",
            "arguments": "_analunitid integer",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getchronocontrolsbychronologyid",
            "return_type": "record",
            "arguments": "_chronologyid integer",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getchronologiesbycollunitid",
            "return_type": "record",
            "arguments": "_collectionunitid integer",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getcollectiontypebyid",
            "return_type": "record",
            "arguments": "_colltypeid integer",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getcollectiontypestable",
            "return_type": "record",
            "arguments": "",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getcollector",
            "return_type": "record",
            "arguments": "_collectionunitid integer",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getcollunitbyid",
            "return_type": "record",
            "arguments": "_collectionunitid integer",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getcollunitbyidv2",
            "return_type": "record",
            "arguments": "_collectionunitid integer",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getcollunithandlecount",
            "return_type": "int8",
            "arguments": "_handle character varying",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getcollunitsbysiteid",
            "return_type": "record",
            "arguments": "_siteid integer",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getcollunitsummarybysiteid",
            "return_type": "record",
            "arguments": "_siteid integer",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getconstituentdatabasenamebyid",
            "return_type": "varchar",
            "arguments": "_databaseid integer",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getconstituentdatabases",
            "return_type": "record",
            "arguments": "",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getcontactbycontactname",
            "return_type": "record",
            "arguments": "_contactname character varying",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getcontactbyfamilyname",
            "return_type": "record",
            "arguments": "_familyname character varying",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getcontactbyfamilynameandinitials",
            "return_type": "record",
            "arguments": "_familyname character varying, _initials character varying",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getcontactbyid",
            "return_type": "record",
            "arguments": "_contactid integer",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getcontactdatasets",
            "return_type": "record",
            "arguments": "_contactid integer",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getcontactlinks",
            "return_type": "record",
            "arguments": "_contactid integer",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getcontactpublications",
            "return_type": "record",
            "arguments": "_contactid integer",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getcontactstable",
            "return_type": "record",
            "arguments": "",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getcontactstatusestable",
            "return_type": "record",
            "arguments": "",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getcontextdatasettypecount",
            "return_type": "int8",
            "arguments": "_datasettypeid integer, _variablecontextid integer",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getcontextsdatasettypestable",
            "return_type": "record",
            "arguments": "",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getdataprocessor",
            "return_type": "record",
            "arguments": "_datasetid integer",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getdatasetauthorsdatasettypes",
            "return_type": "record",
            "arguments": "_datasettypeidlist character varying",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getdatasetchrons",
            "return_type": "record",
            "arguments": "_datasetid integer",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getdatasetcitations",
            "return_type": "record",
            "arguments": "_datasetid integer",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getdatasetcountbycollunittype",
            "return_type": "record",
            "arguments": "_collunittypeid integer",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getdatasetdata",
            "return_type": "record",
            "arguments": "_datasetid integer",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getdatasetdatabase",
            "return_type": "record",
            "arguments": "_datasetid integer",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getdatasetidbycollunitandtype",
            "return_type": "int4",
            "arguments": "_collunitid integer, _datasettypeid integer",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getdatasetidfordatasettypeidforgeochronanalunit",
            "return_type": "int4",
            "arguments": "_geochronid integer, _datasettypeid integer",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getdatasetidsbytaxonid",
            "return_type": "int4",
            "arguments": "_taxonid integer",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getdatasetpis",
            "return_type": "record",
            "arguments": "_datasetid integer",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getdatasetpisdatasettypes",
            "return_type": "record",
            "arguments": "_datasettypeidlist character varying DEFAULT NULL::character varying",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getdatasetpublicationids",
            "return_type": "int4",
            "arguments": "_datasetid integer",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getdatasetpublications",
            "return_type": "record",
            "arguments": "_datasetid integer",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getdatasetpublicationstatus",
            "return_type": "bool",
            "arguments": "_datasetid integer, _publicationid integer",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getdatasetpublicationstatusv2",
            "return_type": "bool",
            "arguments": "_datasetid integer, _publicationid integer",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getdatasetrepository",
            "return_type": "record",
            "arguments": "_datasetid integer",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getdatasetrepositoryspecimennotes",
            "return_type": "record",
            "arguments": "_datasetid integer",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getdatasetsampleanalysts",
            "return_type": "record",
            "arguments": "_datasetid integer",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getdatasetsampledepagents",
            "return_type": "record",
            "arguments": "_datasetid integer",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getdatasetsampleids",
            "return_type": "int4",
            "arguments": "_datasetid integer",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getdatasetsamplekeywords",
            "return_type": "record",
            "arguments": "_datasetid integer",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getdatasetsamples",
            "return_type": "record",
            "arguments": "_datasetid integer",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getdatasetsbycontactid",
            "return_type": "record",
            "arguments": "_contactid integer",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getdatasetsbyid",
            "return_type": "record",
            "arguments": "_datasets text",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getdatasetsbysiteid",
            "return_type": "record",
            "arguments": "_siteid integer",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getdatasetsbysitename",
            "return_type": "record",
            "arguments": "_sitename character varying",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getdatasetsbytaxon",
            "return_type": "record",
            "arguments": "_taxon character varying",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getdatasetspecimendates",
            "return_type": "record",
            "arguments": "_datasetid integer",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getdatasetspecimengenbanknrs",
            "return_type": "record",
            "arguments": "_datasetid integer",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getdatasetspecimens",
            "return_type": "record",
            "arguments": "_datasetid integer",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getdatasetspecimentaphonomy",
            "return_type": "record",
            "arguments": "_datasetid integer",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getdatasetsynonyms",
            "return_type": "record",
            "arguments": "_datasetid integer",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getdatasettaxonnotes",
            "return_type": "record",
            "arguments": "_datasetid integer",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getdatasettaxonnotesbytaxonid",
            "return_type": "record",
            "arguments": "_datasetid integer, _taxonid integer",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getdatasettypes",
            "return_type": "record",
            "arguments": "",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getdatasettypesbyname",
            "return_type": "record",
            "arguments": "_datasettype character varying",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getdatasettypesbytaxagroupid",
            "return_type": "record",
            "arguments": "_taxagroupid character varying",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getdatasettypeshavingdata",
            "return_type": "record",
            "arguments": "",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getdatasetvariables",
            "return_type": "record",
            "arguments": "_datasetid integer",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getdatasetvariablesynonyms",
            "return_type": "record",
            "arguments": "_datasetid integer, _variableid integer",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getdatasetvariableunits",
            "return_type": "record",
            "arguments": "_datasetid integer",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getdepagentbyname",
            "return_type": "record",
            "arguments": "_depagent character varying",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getdepagentstypestable",
            "return_type": "record",
            "arguments": "",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getdepenvtbyid",
            "return_type": "record",
            "arguments": "_depenvtid integer",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getdepenvttypestable",
            "return_type": "record",
            "arguments": "",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getecolgroupsbyecolsetid",
            "return_type": "record",
            "arguments": "_ecolsetid integer",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getecolgroupsbytaxagroupidlist",
            "return_type": "record",
            "arguments": "_taxagrouplist text",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getecolgroupsbyvariableidlist",
            "return_type": "record",
            "arguments": "_variableids text",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getecolgroupstable",
            "return_type": "record",
            "arguments": "",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getecolgrouptypestable",
            "return_type": "record",
            "arguments": "",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getecolsetcountsbytaxagroupid",
            "return_type": "record",
            "arguments": "_taxagroupid character varying",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getecolsetsgroupsbytaxonid",
            "return_type": "record",
            "arguments": "_taxonid integer",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getecolsettypestable",
            "return_type": "record",
            "arguments": "",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getelementdatasettaxagroupcount",
            "return_type": "int4",
            "arguments": "_datasettypeid integer, _taxagroupid character varying, _elementtypeid integer",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getelementdatasettaxagroupstable",
            "return_type": "record",
            "arguments": "",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getelementmaturitiestable",
            "return_type": "record",
            "arguments": "",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getelementmaturitybyname",
            "return_type": "record",
            "arguments": "_maturity character varying",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getelementpartid",
            "return_type": "record",
            "arguments": "_partname character varying",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getelementportionbyname",
            "return_type": "record",
            "arguments": "_portion character varying",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getelementportionstable",
            "return_type": "record",
            "arguments": "",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getelementsbytaxonid",
            "return_type": "record",
            "arguments": "_taxonid integer",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getelementsymmetriestable",
            "return_type": "record",
            "arguments": "",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getelementsymmetrybyname",
            "return_type": "record",
            "arguments": "_symmetry character varying",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getelementtaxagroupid",
            "return_type": "int4",
            "arguments": "_taxagroupid character varying, _elementtypeid integer",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getelementtaxagroupmaturitiestable",
            "return_type": "record",
            "arguments": "",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getelementtaxagroupportionstable",
            "return_type": "record",
            "arguments": "",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getelementtaxagroupstable",
            "return_type": "record",
            "arguments": "",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getelementtaxagroupsymmetriestable",
            "return_type": "record",
            "arguments": "",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getelementtypebydatasettypeid",
            "return_type": "record",
            "arguments": "_datasettypeid integer",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getelementtypebyname",
            "return_type": "record",
            "arguments": "_elementtype character varying",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getelementtypefromvariableelement",
            "return_type": "record",
            "arguments": "_variableelement character varying",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getelementtypesbynamelist",
            "return_type": "record",
            "arguments": "_elementtypes character varying",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getelementtypesbytaxagroupid",
            "return_type": "record",
            "arguments": "_taxagroupid character varying",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getelementtypesfortaxontaxagroup",
            "return_type": "record",
            "arguments": "_taxonid integer",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getelementtypestable",
            "return_type": "record",
            "arguments": "",
            "type": "FUNCTION"
        },
        {
            "name": "ti.geteventbyname",
            "return_type": "record",
            "arguments": "_eventname character varying",
            "type": "FUNCTION"
        },
        {
            "name": "ti.geteventchroncontroltypeid",
            "return_type": "record",
            "arguments": "_eventname character varying",
            "type": "FUNCTION"
        },
        {
            "name": "ti.geteventpublications",
            "return_type": "record",
            "arguments": "_eventid integer",
            "type": "FUNCTION"
        },
        {
            "name": "ti.geteventsbychronologyid",
            "return_type": "record",
            "arguments": "_chronologyid integer",
            "type": "FUNCTION"
        },
        {
            "name": "ti.geteventstable",
            "return_type": "record",
            "arguments": "",
            "type": "FUNCTION"
        },
        {
            "name": "ti.geteventtypebyname",
            "return_type": "record",
            "arguments": "_eventtype character varying",
            "type": "FUNCTION"
        },
        {
            "name": "ti.geteventtypestable",
            "return_type": "record",
            "arguments": "",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getfaciestypebyname",
            "return_type": "record",
            "arguments": "_facies character varying",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getfaciestypestable",
            "return_type": "record",
            "arguments": "",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getfaunmap1relativeagesbychroncontrolidlist",
            "return_type": "record",
            "arguments": "_chroncontrolids character varying",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getfractiondatedbyname",
            "return_type": "record",
            "arguments": "_fraction character varying",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getfractiondatedtable",
            "return_type": "record",
            "arguments": "",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getfractionsdatedbylist",
            "return_type": "record",
            "arguments": "_fractions character varying",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getfunctioninputparams",
            "return_type": "record",
            "arguments": "_functionname character varying",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getgeochronanalysisunit",
            "return_type": "record",
            "arguments": "_geochronid integer",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getgeochronanalysisunitsbydatasetid",
            "return_type": "record",
            "arguments": "_datasetid integer",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getgeochronbydatasetid",
            "return_type": "record",
            "arguments": "_datasetid integer",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getgeochronbygeochronid",
            "return_type": "record",
            "arguments": "_geochronid integer",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getgeochroncontrolcount",
            "return_type": "int4",
            "arguments": "_geochronid integer",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getgeochroncontrolsbychronologyid",
            "return_type": "record",
            "arguments": "_chronologyid integer",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getgeochroncounts",
            "return_type": "record",
            "arguments": "",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getgeochronidcount",
            "return_type": "int4",
            "arguments": "_geochronid integer",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getgeochrontypeid",
            "return_type": "int4",
            "arguments": "_geochrontype character varying",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getgeochrontypestable",
            "return_type": "record",
            "arguments": "",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getgeopolbysitename",
            "return_type": "record",
            "arguments": "_sitename character varying, _east double precision, _north double precision, _west double precision, _south double precision",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getgeopoliticalunitstable",
            "return_type": "geopoliticalunits",
            "arguments": "",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getgeopolnumberofsubdivs",
            "return_type": "int4",
            "arguments": "_highergeopolid integer",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getgeopolunitbyhigherid",
            "return_type": "record",
            "arguments": "_highergeopolid integer",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getgeopolunitbyid",
            "return_type": "record",
            "arguments": "_geopolid integer",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getgeopolunitbynameandhigherid",
            "return_type": "record",
            "arguments": "_geopolname character varying, _highergeopolid integer",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getgeopolunitbynameandrank",
            "return_type": "record",
            "arguments": "_geopolname character varying, _rank integer",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getgeopolunitbyrank",
            "return_type": "record",
            "arguments": "_rank integer",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getgeopolunitrank",
            "return_type": "record",
            "arguments": "_rank integer",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getgeopolunitsbysiteid",
            "return_type": "record",
            "arguments": "_siteid integer",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getinvalidtaxabytaxagroupid",
            "return_type": "record",
            "arguments": "_taxagroupid character varying",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getinvalidtaxabytaxagroupidlist",
            "return_type": "record",
            "arguments": "_taxagrouplist text",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getinvalidtaxonbyname",
            "return_type": "record",
            "arguments": "_taxonname character varying",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getinvalidtaxonsynonymycount",
            "return_type": "int4",
            "arguments": "_reftaxonid integer",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getinvestigator",
            "return_type": "record",
            "arguments": "_datasetid integer",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getisobiomarkers",
            "return_type": "record",
            "arguments": "",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getisoinstrumentationtypes",
            "return_type": "record",
            "arguments": "",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getisomaterialanalyzedandsubstrate",
            "return_type": "record",
            "arguments": "",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getisomaterialanalyzedtypes",
            "return_type": "record",
            "arguments": "",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getisopretreatmenttypes",
            "return_type": "record",
            "arguments": "",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getisosampleintrosystemtypes",
            "return_type": "record",
            "arguments": "",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getisosampleorigintypes",
            "return_type": "record",
            "arguments": "",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getisostandardtypes",
            "return_type": "record",
            "arguments": "",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getisosubstrates",
            "return_type": "record",
            "arguments": "",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getisovariablescaleids",
            "return_type": "record",
            "arguments": "",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getisovariablescaletypes",
            "return_type": "record",
            "arguments": "",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getkeywordstable",
            "return_type": "record",
            "arguments": "",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getlakeparametertypestable",
            "return_type": "lakeparametertypes",
            "arguments": "",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getlakeparamsbysiteid",
            "return_type": "record",
            "arguments": "_siteid integer",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getlithologybycollunitid",
            "return_type": "record",
            "arguments": "_collunitid integer",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getmaxpubidbypubidtype",
            "return_type": "int4",
            "arguments": "_pubtypeid integer",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getminpubidbypubidtype",
            "return_type": "int4",
            "arguments": "_pubtypeid integer",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getnearestsites",
            "return_type": "record",
            "arguments": "_east numeric, _north numeric, _west numeric, _south numeric, _distkm numeric",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getnextlowergeopolcountbynames",
            "return_type": "int8",
            "arguments": "_name1 character varying, _rank1 integer, _name2 character varying, _rank2 integer",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getnextpublicationbyid",
            "return_type": "record",
            "arguments": "_publicationid integer",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getnextpublicationbyidandpubtypeid",
            "return_type": "record",
            "arguments": "_publicationid integer, _pubtypeid integer",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getpollensporehighertaxa",
            "return_type": "record",
            "arguments": "_taxaidlist character varying",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getpredefinedtaxaecolgroupsbydatasettypelist",
            "return_type": "record",
            "arguments": "_datasettypeids character varying",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getpreviouspublicationbyid",
            "return_type": "record",
            "arguments": "_publicationid integer",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getpreviouspublicationbyidandpubtypeid",
            "return_type": "record",
            "arguments": "_publicationid integer, _pubtypeid integer",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getprocedureinputparams",
            "return_type": "record",
            "arguments": "_procedurename character varying",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getpublicationauthors",
            "return_type": "record",
            "arguments": "_publicationid integer",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getpublicationbycitation",
            "return_type": "record",
            "arguments": "_citation character varying",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getpublicationbydatasetid",
            "return_type": "record",
            "arguments": "_datasetid integer",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getpublicationbyfamilyname",
            "return_type": "record",
            "arguments": "_familyname character varying",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getpublicationbyid",
            "return_type": "record",
            "arguments": "_publicationid integer",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getpublicationbyidlist",
            "return_type": "record",
            "arguments": "_publicationidlist character varying",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getpublicationeditors",
            "return_type": "record",
            "arguments": "_publicationid integer",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getpublicationsbycontactid",
            "return_type": "record",
            "arguments": "_contactid integer",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getpublicationsbygeochronid",
            "return_type": "record",
            "arguments": "_geochronidlist character varying",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getpublicationstable",
            "return_type": "publications",
            "arguments": "",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getpublicationtranslators",
            "return_type": "record",
            "arguments": "_publicationid integer",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getpublicationtypestable",
            "return_type": "publicationtypes",
            "arguments": "",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getradiocarbonbygeochronid",
            "return_type": "record",
            "arguments": "_geochronidlist character varying",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getradiocarbonmethodid",
            "return_type": "int4",
            "arguments": "_radiocarbonmethod character varying",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getradiocarbonmethodstable",
            "return_type": "record",
            "arguments": "",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getrecentuploads",
            "return_type": "record",
            "arguments": "_months integer DEFAULT 1, _databaseid integer DEFAULT NULL::integer, _datasettypeid integer DEFAULT NULL::integer, _limit integer DEFAULT 400",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getrelativeagebyname",
            "return_type": "record",
            "arguments": "_relativeage character varying",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getrelativeagechroncontroltype",
            "return_type": "record",
            "arguments": "_relativeage character varying",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getrelativeagepublications",
            "return_type": "record",
            "arguments": "_relativeageid integer",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getrelativeagesbychronologyid",
            "return_type": "record",
            "arguments": "_chronologyid integer",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getrelativeagescalebyname",
            "return_type": "record",
            "arguments": "_relativeagescale character varying",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getrelativeagescalestable",
            "return_type": "record",
            "arguments": "",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getrelativeagestable",
            "return_type": "record",
            "arguments": "",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getrelativeageunitsbyagescale",
            "return_type": "record",
            "arguments": "_relativeagescale character varying",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getrelativeageunitsbyname",
            "return_type": "record",
            "arguments": "_relativeagescale character varying",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getrepositoryinstitution",
            "return_type": "record",
            "arguments": "_acronym character varying DEFAULT NULL::character varying, _repository character varying DEFAULT NULL::character varying",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getrepositoryinstitutionstable",
            "return_type": "record",
            "arguments": "",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getrocktypebyid",
            "return_type": "record",
            "arguments": "_rocktypeid integer",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getrocktypebyname",
            "return_type": "record",
            "arguments": "_rocktype character varying",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getrocktypestable",
            "return_type": "record",
            "arguments": "",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getsampleage",
            "return_type": "record",
            "arguments": "_chronologyid integer, _sampleid integer",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getsampleagesbychronid",
            "return_type": "record",
            "arguments": "_chronologyid integer",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getsampleidfordatasetidfromgeochronanalunit",
            "return_type": "int4",
            "arguments": "_geochronid integer, _datasetid integer",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getsampleidfordatasettypeidfromgeochronanalunit",
            "return_type": "int4",
            "arguments": "_geochronid integer, _datasettypeid integer",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getsamplekeywords",
            "return_type": "record",
            "arguments": "_sampleid integer",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getsampleparents",
            "return_type": "record",
            "arguments": "_sampleid integer",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getsampletaxoncount",
            "return_type": "int4",
            "arguments": "_sampleid integer, _taxonid integer",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getsitebyname",
            "return_type": "record",
            "arguments": "_sitename character varying",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getsitemetadata",
            "return_type": "record",
            "arguments": "_siteid integer",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getsites",
            "return_type": "record",
            "arguments": "_datasettypeid integer DEFAULT NULL::integer, _sitename character varying DEFAULT NULL::character varying, _geopoliticalid integer DEFAULT NULL::integer, _contactid integer DEFAULT NULL::integer, _authorid integer DEFAULT NULL::integer",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getsitesbydatabaseanddatasettype",
            "return_type": "record",
            "arguments": "_databaseid integer, _datasettypeid integer",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getsitesbydatasettype",
            "return_type": "record",
            "arguments": "_datasettypeid integer",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getspecimenbyidcount",
            "return_type": "int8",
            "arguments": "_specimenid integer",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getspecimendatebyspecimendateid",
            "return_type": "record",
            "arguments": "_specimendateid integer",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getspecimendatecalbyspecimendateid",
            "return_type": "record",
            "arguments": "_specimendateid integer",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getspecimendatesbygeochrondatasetid",
            "return_type": "record",
            "arguments": "_geochrondatasetid integer",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getspecimendatesbytaxonid",
            "return_type": "record",
            "arguments": "_taxonid integer",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getspecimendomesticstatusbyname",
            "return_type": "record",
            "arguments": "_domesticstatus character varying",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getspecimendomesticstatustypes",
            "return_type": "record",
            "arguments": "",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getspecimenisotopedataset",
            "return_type": "record",
            "arguments": "_datasetid integer",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getspecimensampleid",
            "return_type": "int4",
            "arguments": "_specimenid integer",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getspecimensexbyname",
            "return_type": "record",
            "arguments": "_sex character varying",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getspecimensextypes",
            "return_type": "record",
            "arguments": "",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getspecimentaxonid",
            "return_type": "int4",
            "arguments": "_specimenid integer",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getstatscolltypedatasetcount",
            "return_type": "record",
            "arguments": "",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getsynonymsforinvalidtaxonid",
            "return_type": "record",
            "arguments": "_invalidtaxonid integer",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getsynonymsforvalidtaxonid",
            "return_type": "record",
            "arguments": "_validtaxonid integer",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getsynonymtype",
            "return_type": "record",
            "arguments": "_synonymtype character varying",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getsynonymtypestable",
            "return_type": "synonymtypes",
            "arguments": "",
            "type": "FUNCTION"
        },
        {
            "name": "ti.gettablecolumns",
            "return_type": "record",
            "arguments": "_tablename character varying",
            "type": "FUNCTION"
        },
        {
            "name": "ti.gettablemaxid",
            "return_type": "int4",
            "arguments": "_tablename character varying, _columnname character varying",
            "type": "FUNCTION"
        },
        {
            "name": "ti.gettableminid",
            "return_type": "int4",
            "arguments": "_tablename character varying, _columnname character varying",
            "type": "FUNCTION"
        },
        {
            "name": "ti.gettablerecordcount",
            "return_type": "int4",
            "arguments": "_tablename character varying",
            "type": "FUNCTION"
        },
        {
            "name": "ti.gettablerecordcountbymonth",
            "return_type": "record",
            "arguments": "_tablename character varying",
            "type": "FUNCTION"
        },
        {
            "name": "ti.gettaphonomicsystembydatasettype",
            "return_type": "record",
            "arguments": "_datasettypeid integer",
            "type": "FUNCTION"
        },
        {
            "name": "ti.gettaphonomicsystembyname",
            "return_type": "record",
            "arguments": "_taphonomicsystem character varying",
            "type": "FUNCTION"
        },
        {
            "name": "ti.gettaphonomicsystemsbydatasettype",
            "return_type": "record",
            "arguments": "_datasettypeid integer",
            "type": "FUNCTION"
        },
        {
            "name": "ti.gettaphonomicsystemsdatasettypestable",
            "return_type": "record",
            "arguments": "",
            "type": "FUNCTION"
        },
        {
            "name": "ti.gettaphonomicsystemstable",
            "return_type": "record",
            "arguments": "",
            "type": "FUNCTION"
        },
        {
            "name": "ti.gettaphonomictypeid",
            "return_type": "int4",
            "arguments": "_taphonomicsystemid integer, _taphonomictype character varying",
            "type": "FUNCTION"
        },
        {
            "name": "ti.gettaphonomictypesbyidlist",
            "return_type": "record",
            "arguments": "_taphonomictypeids character varying",
            "type": "FUNCTION"
        },
        {
            "name": "ti.gettaphonomictypesbysystem",
            "return_type": "record",
            "arguments": "_taphonomicsystemid integer",
            "type": "FUNCTION"
        },
        {
            "name": "ti.gettaphonomictypestable",
            "return_type": "record",
            "arguments": "",
            "type": "FUNCTION"
        },
        {
            "name": "ti.gettaxabycodeandtaxagroupid",
            "return_type": "record",
            "arguments": "_taxoncode character varying, _taxagroupid character varying",
            "type": "FUNCTION"
        },
        {
            "name": "ti.gettaxabynamelist",
            "return_type": "record",
            "arguments": "_taxanames text",
            "type": "FUNCTION"
        },
        {
            "name": "ti.gettaxabynamescount",
            "return_type": "int8",
            "arguments": "_taxanames character varying",
            "type": "FUNCTION"
        },
        {
            "name": "ti.gettaxabytaxagroupid",
            "return_type": "record",
            "arguments": "_taxagroupid character varying",
            "type": "FUNCTION"
        },
        {
            "name": "ti.gettaxaecolgroupsbydatasettypelist",
            "return_type": "record",
            "arguments": "_datasettypeids character varying",
            "type": "FUNCTION"
        },
        {
            "name": "ti.gettaxagroupbyid",
            "return_type": "record",
            "arguments": "_taxagroupid character varying",
            "type": "FUNCTION"
        },
        {
            "name": "ti.gettaxagroupcodes",
            "return_type": "record",
            "arguments": "",
            "type": "FUNCTION"
        },
        {
            "name": "ti.gettaxagroupecolsetids",
            "return_type": "record",
            "arguments": "_taxagroupid character varying",
            "type": "FUNCTION"
        },
        {
            "name": "ti.gettaxagroupelementtypes",
            "return_type": "record",
            "arguments": "",
            "type": "FUNCTION"
        },
        {
            "name": "ti.gettaxagroupid",
            "return_type": "record",
            "arguments": "_taxagroup character varying",
            "type": "FUNCTION"
        },
        {
            "name": "ti.gettaxagrouppublications",
            "return_type": "record",
            "arguments": "_taxagroupid character varying",
            "type": "FUNCTION"
        },
        {
            "name": "ti.gettaxagroupsfordatasettype",
            "return_type": "record",
            "arguments": "_datasettypeid integer",
            "type": "FUNCTION"
        },
        {
            "name": "ti.gettaxagrouptypes",
            "return_type": "record",
            "arguments": "",
            "type": "FUNCTION"
        },
        {
            "name": "ti.gettaxalookupsynonymybytaxagroupidlist",
            "return_type": "record",
            "arguments": "_taxagrouplist character varying",
            "type": "FUNCTION"
        },
        {
            "name": "ti.gettaxatable",
            "return_type": "record",
            "arguments": "",
            "type": "FUNCTION"
        },
        {
            "name": "ti.gettaxonbyid",
            "return_type": "record",
            "arguments": "_taxonid integer",
            "type": "FUNCTION"
        },
        {
            "name": "ti.gettaxonbyname",
            "return_type": "record",
            "arguments": "_taxonname character varying",
            "type": "FUNCTION"
        },
        {
            "name": "ti.gettaxondatarecordscount",
            "return_type": "int8",
            "arguments": "_taxonid integer",
            "type": "FUNCTION"
        },
        {
            "name": "ti.gettaxonhierarchy",
            "return_type": "record",
            "arguments": "_taxonname character varying",
            "type": "FUNCTION"
        },
        {
            "name": "ti.gettaxonspecimendatescount",
            "return_type": "int8",
            "arguments": "_taxonid integer",
            "type": "FUNCTION"
        },
        {
            "name": "ti.gettaxonsynonymscount",
            "return_type": "int8",
            "arguments": "_validtaxonid integer",
            "type": "FUNCTION"
        },
        {
            "name": "ti.gettaxonsynonymycount",
            "return_type": "int8",
            "arguments": "_taxonid integer",
            "type": "FUNCTION"
        },
        {
            "name": "ti.gettaxonvarelements",
            "return_type": "varchar",
            "arguments": "_taxonname character varying",
            "type": "FUNCTION"
        },
        {
            "name": "ti.gettaxonvarunits",
            "return_type": "varchar",
            "arguments": "_taxonname character varying",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getunitsdatasettypecount",
            "return_type": "int8",
            "arguments": "_datasettypeid integer, _variableunitsid integer",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getunitsdatasettypestable",
            "return_type": "unitsdatasettypes",
            "arguments": "",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getvalidsynonymbyinvalidtaxonid",
            "return_type": "record",
            "arguments": "_invalidtaxonid integer",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getvalidtaxabytaxagroupid",
            "return_type": "record",
            "arguments": "_taxagroupid character varying",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getvalidtaxabytaxagroupidlist",
            "return_type": "record",
            "arguments": "_taxagrouplist character varying",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getvalidtaxonbyname",
            "return_type": "record",
            "arguments": "_taxonname character varying",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getvarelemsbydatasettypeandtaxaidlist",
            "return_type": "record",
            "arguments": "_datasettype character varying, _taxaids character varying",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getvariablebycomponentnames",
            "return_type": "int4",
            "arguments": "_taxon character varying, _element character varying DEFAULT NULL::character varying, _units character varying DEFAULT NULL::character varying, _context character varying DEFAULT NULL::character varying",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getvariablebycomponents",
            "return_type": "record",
            "arguments": "_taxonid integer, _variableelementid integer DEFAULT NULL::integer, _variableunitsid integer DEFAULT NULL::integer, _variablecontextid integer DEFAULT NULL::integer",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getvariablebyid",
            "return_type": "record",
            "arguments": "_variableid integer",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getvariablecontextid",
            "return_type": "int4",
            "arguments": "_variablecontext character varying",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getvariablecontextstable",
            "return_type": "record",
            "arguments": "",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getvariablecontextstablebydatasettypeid",
            "return_type": "varchar",
            "arguments": "_datasettypeid integer",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getvariabledatarecordscount",
            "return_type": "int8",
            "arguments": "_variableid integer",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getvariableelementbyname",
            "return_type": "record",
            "arguments": "_variableelement character varying",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getvariableelementbypartids",
            "return_type": "int4",
            "arguments": "_elementtypeid integer, _symmetryid integer, _portionid integer, _maturityid integer",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getvariableelementsbydatasettypeid",
            "return_type": "record",
            "arguments": "_datasettypeid integer",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getvariableelementstable",
            "return_type": "record",
            "arguments": "",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getvariablesbytaxagroupidlist",
            "return_type": "variables",
            "arguments": "_taxagrouplist character varying",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getvariablesbytaxonid",
            "return_type": "record",
            "arguments": "_taxonid integer",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getvariablestable",
            "return_type": "variables",
            "arguments": "",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getvariabletaxonid",
            "return_type": "int4",
            "arguments": "_variableid integer",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getvariabletextbyid",
            "return_type": "record",
            "arguments": "_variableid integer",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getvariabletexybyid",
            "return_type": "record",
            "arguments": "variableid integer",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getvariableunitsid",
            "return_type": "int4",
            "arguments": "_variableunits character varying",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getvariableunitstable",
            "return_type": "variableunits",
            "arguments": "",
            "type": "FUNCTION"
        },
        {
            "name": "ti.getvariableunitstablebydatasettypeid",
            "return_type": "varchar",
            "arguments": "_datasettypeid integer",
            "type": "FUNCTION"
        },
        {
            "name": "ti.reccreate",
            "return_type": "trigger",
            "arguments": "",
            "type": "FUNCTION"
        },
        {
            "name": "ti.site_bounding",
            "return_type": "trigger",
            "arguments": "",
            "type": "FUNCTION"
        },
        {
            "name": "ti.trigger_set_timecreate",
            "return_type": "trigger",
            "arguments": "",
            "type": "FUNCTION"
        },
        {
            "name": "ti.update_dateupdated",
            "return_type": "trigger",
            "arguments": "",
            "type": "FUNCTION"
        },
        {
            "name": "ti.update_recdatemodified",
            "return_type": "trigger",
            "arguments": "",
            "type": "FUNCTION"
        },
        {
            "name": "ti.validateusername",
            "return_type": "record",
            "arguments": "_username character varying",
            "type": "FUNCTION"
        },
        {
            "name": "ts.checksteward",
            "return_type": "record",
            "arguments": "_username character varying, _pwd character varying",
            "type": "FUNCTION"
        },
        {
            "name": "ts.combinecontacts",
            "return_type": "void",
            "arguments": "_keepcontactid integer, _contactidlist character varying",
            "type": "FUNCTION"
        },
        {
            "name": "ts.deleteanalysisunit",
            "return_type": "void",
            "arguments": "_analunitid integer",
            "type": "FUNCTION"
        },
        {
            "name": "ts.deletechronology",
            "return_type": "void",
            "arguments": "_chronologyid integer",
            "type": "FUNCTION"
        },
        {
            "name": "ts.deletecollectionunit",
            "return_type": "void",
            "arguments": "_collectionunitid integer",
            "type": "FUNCTION"
        },
        {
            "name": "ts.deletecollectors",
            "return_type": "void",
            "arguments": "_collunitid integer",
            "type": "FUNCTION"
        },
        {
            "name": "ts.deletedata",
            "return_type": "void",
            "arguments": "_dataid integer",
            "type": "FUNCTION"
        },
        {
            "name": "ts.deletedataprocessor",
            "return_type": "void",
            "arguments": "_datasetid integer, _contactid integer",
            "type": "FUNCTION"
        },
        {
            "name": "ts.deletedataset",
            "return_type": "void",
            "arguments": "_datasetid integer",
            "type": "FUNCTION"
        },
        {
            "name": "ts.deletedatasetpi",
            "return_type": "void",
            "arguments": "_datasetid integer, _contactid integer",
            "type": "FUNCTION"
        },
        {
            "name": "ts.deletedatasetpublication",
            "return_type": "void",
            "arguments": "_datasetid integer, _publicationid integer",
            "type": "FUNCTION"
        },
        {
            "name": "ts.deletedatasettaxonnotes",
            "return_type": "void",
            "arguments": "_datasetid integer, _taxonid integer, _contactid integer",
            "type": "FUNCTION"
        },
        {
            "name": "ts.deletedatasetvariable",
            "return_type": "void",
            "arguments": "_datasetid integer, _variableid integer",
            "type": "FUNCTION"
        },
        {
            "name": "ts.deletedepenvttype",
            "return_type": "void",
            "arguments": "_depenvtid integer",
            "type": "FUNCTION"
        },
        {
            "name": "ts.deleteecolgroup",
            "return_type": "void",
            "arguments": "_taxonid integer, _ecolsetid integer",
            "type": "FUNCTION"
        },
        {
            "name": "ts.deleteeventpublication",
            "return_type": "void",
            "arguments": "_eventid integer, _publicationid integer",
            "type": "FUNCTION"
        },
        {
            "name": "ts.deletegeochron",
            "return_type": "void",
            "arguments": "_geochronid integer",
            "type": "FUNCTION"
        },
        {
            "name": "ts.deletegeochroncontrol",
            "return_type": "void",
            "arguments": "_chroncontrolid integer",
            "type": "FUNCTION"
        },
        {
            "name": "ts.deletegeochronpublication",
            "return_type": "void",
            "arguments": "_geochronid integer, _publicationid integer",
            "type": "FUNCTION"
        },
        {
            "name": "ts.deletepublicationauthor",
            "return_type": "void",
            "arguments": "_authorid integer",
            "type": "FUNCTION"
        },
        {
            "name": "ts.deletepublicationeditor",
            "return_type": "void",
            "arguments": "_editorid integer",
            "type": "FUNCTION"
        },
        {
            "name": "ts.deletepublicationtranslator",
            "return_type": "void",
            "arguments": "_translatorid integer",
            "type": "FUNCTION"
        },
        {
            "name": "ts.deleterelativeagepublication",
            "return_type": "void",
            "arguments": "_relativeageid integer, _publicationid integer",
            "type": "FUNCTION"
        },
        {
            "name": "ts.deleterepositoryspecimen",
            "return_type": "void",
            "arguments": "_datasetid integer, _repositoryid integer",
            "type": "FUNCTION"
        },
        {
            "name": "ts.deletesample",
            "return_type": "void",
            "arguments": "_sampleid integer",
            "type": "FUNCTION"
        },
        {
            "name": "ts.deletesampleanalysts",
            "return_type": "void",
            "arguments": "_sampleid integer",
            "type": "FUNCTION"
        },
        {
            "name": "ts.deletesite",
            "return_type": "void",
            "arguments": "_siteid integer",
            "type": "FUNCTION"
        },
        {
            "name": "ts.deletesynonymy",
            "return_type": "void",
            "arguments": "_synonymyid integer, _contactid integer",
            "type": "FUNCTION"
        },
        {
            "name": "ts.deletetaxon",
            "return_type": "void",
            "arguments": "_taxonid integer",
            "type": "FUNCTION"
        },
        {
            "name": "ts.deletevariablebyvariableid",
            "return_type": "void",
            "arguments": "_variableid integer",
            "type": "FUNCTION"
        },
        {
            "name": "ts.deletevariablecontext",
            "return_type": "void",
            "arguments": "_variablecontextid integer",
            "type": "FUNCTION"
        },
        {
            "name": "ts.deletevariablesbytaxonid",
            "return_type": "void",
            "arguments": "_taxonid integer",
            "type": "FUNCTION"
        },
        {
            "name": "ts.insertaggregatechronology",
            "return_type": "int4",
            "arguments": "_aggregatedatasetid integer, _agetypeid integer, _isdefault boolean, _chronologyname character varying, _ageboundyounger integer, _ageboundolder integer, _notes character varying DEFAULT NULL::character varying",
            "type": "FUNCTION"
        },
        {
            "name": "ts.insertaggregatedataset",
            "return_type": "int4",
            "arguments": "_name character varying, _ordertypeid integer, _notes text DEFAULT NULL::text",
            "type": "FUNCTION"
        },
        {
            "name": "ts.insertaggregatesample",
            "return_type": "void",
            "arguments": "_aggregatedatasetid integer, _sampleid integer",
            "type": "FUNCTION"
        },
        {
            "name": "ts.insertaggregatesampleages",
            "return_type": "void",
            "arguments": "_aggregatedatasetid integer, _aggregatechronid integer",
            "type": "FUNCTION"
        },
        {
            "name": "ts.insertanalysisunit",
            "return_type": "int4",
            "arguments": "_collectionunitid integer, _analysisunitname character varying DEFAULT NULL::character varying, _depth double precision DEFAULT NULL::double precision, _thickness double precision DEFAULT NULL::double precision, _faciesid integer DEFAULT NULL::integer, _mixed boolean DEFAULT NULL::boolean, _igsn character varying DEFAULT NULL::character varying, _notes character varying DEFAULT NULL::character varying",
            "type": "FUNCTION"
        },
        {
            "name": "ts.insertanalysisunitaltdepth",
            "return_type": "void",
            "arguments": "_analysisunitid integer, _altdepthscaleid integer, _altdepth double precision",
            "type": "FUNCTION"
        },
        {
            "name": "ts.insertanalysisunitaltdepthscale",
            "return_type": "int4",
            "arguments": "_altdepthid integer, _altdepthname character varying, _variableunitsid integer, _notes character varying DEFAULT NULL::character varying",
            "type": "FUNCTION"
        },
        {
            "name": "ts.insertcalibrationprogram",
            "return_type": "int4",
            "arguments": "_calibrationprogram character varying, _version character varying",
            "type": "FUNCTION"
        },
        {
            "name": "ts.insertchroncontrol",
            "return_type": "int4",
            "arguments": "_chronologyid integer, _chroncontroltypeid integer, _analysisunitid integer DEFAULT NULL::integer, _depth double precision DEFAULT NULL::double precision, _thickness double precision DEFAULT NULL::double precision, _agetypeid integer DEFAULT NULL::integer, _age double precision DEFAULT NULL::double precision, _agelimityounger double precision DEFAULT NULL::double precision, _agelimitolder double precision DEFAULT NULL::double precision, _notes character varying DEFAULT NULL::character varying",
            "type": "FUNCTION"
        },
        {
            "name": "ts.insertchroncontrolcal14c",
            "return_type": "void",
            "arguments": "_chroncontrolid integer, _calibrationcurveid integer, _calibrationprogramid integer",
            "type": "FUNCTION"
        },
        {
            "name": "ts.insertchroncontroltype",
            "return_type": "int4",
            "arguments": "_chroncontroltype character varying, _higherchroncontroltypeid integer",
            "type": "FUNCTION"
        },
        {
            "name": "ts.insertchronology",
            "return_type": "int4",
            "arguments": "_collectionunitid integer, _agetypeid integer DEFAULT NULL::integer, _contactid integer DEFAULT NULL::integer, _isdefault boolean DEFAULT NULL::boolean, _chronologyname character varying DEFAULT NULL::character varying, _dateprepared date DEFAULT NULL::date, _agemodel character varying DEFAULT NULL::character varying, _ageboundyounger integer DEFAULT NULL::integer, _ageboundolder integer DEFAULT NULL::integer, _notes text DEFAULT NULL::text",
            "type": "FUNCTION"
        },
        {
            "name": "ts.insertcollectionunit",
            "return_type": "int4",
            "arguments": "_handle character varying, _siteid integer, _colltypeid integer DEFAULT NULL::integer, _depenvtid integer DEFAULT NULL::integer, _collunitname character varying DEFAULT NULL::character varying, _colldate date DEFAULT NULL::date, _colldevice character varying DEFAULT NULL::character varying, _gpslatitude double precision DEFAULT NULL::double precision, _gpslongitude double precision DEFAULT NULL::double precision, _gpsaltitude double precision DEFAULT NULL::double precision, _gpserror double precision DEFAULT NULL::double precision, _waterdepth double precision DEFAULT NULL::double precision, _watertabledepth double precision DEFAULT NULL::double precision, _substrateid integer DEFAULT NULL::integer, _slopeaspect integer DEFAULT NULL::integer, _slopeangle integer DEFAULT NULL::integer, _location character varying DEFAULT NULL::character varying, _notes character varying DEFAULT NULL::character varying",
            "type": "FUNCTION"
        },
        {
            "name": "ts.insertcollector",
            "return_type": "int4",
            "arguments": "_collunitid integer, _contactid integer, _collectororder integer",
            "type": "FUNCTION"
        },
        {
            "name": "ts.insertcontact",
            "return_type": "int4",
            "arguments": "_aliasid integer DEFAULT NULL::integer, _contactname character varying DEFAULT NULL::character varying, _statusid integer DEFAULT NULL::integer, _familyname character varying DEFAULT NULL::character varying, _initials character varying DEFAULT NULL::character varying, _givennames character varying DEFAULT NULL::character varying, _suffix character varying DEFAULT NULL::character varying, _title character varying DEFAULT NULL::character varying, _phone character varying DEFAULT NULL::character varying, _fax character varying DEFAULT NULL::character varying, _email character varying DEFAULT NULL::character varying, _url character varying DEFAULT NULL::character varying, _address character varying DEFAULT NULL::character varying, _notes character varying DEFAULT NULL::character varying",
            "type": "FUNCTION"
        },
        {
            "name": "ts.insertcontextdatasettypes",
            "return_type": "void",
            "arguments": "_datasettypeid integer, _variablecontextid integer",
            "type": "FUNCTION"
        },
        {
            "name": "ts.insertdata",
            "return_type": "int4",
            "arguments": "_sampleid integer, _variableid integer, _value double precision",
            "type": "FUNCTION"
        },
        {
            "name": "ts.insertdataprocessor",
            "return_type": "void",
            "arguments": "_datasetid integer, _contactid integer",
            "type": "FUNCTION"
        },
        {
            "name": "ts.insertdataset",
            "return_type": "int4",
            "arguments": "_collectionunitid integer, _datasettypeid integer, _datasetname character varying DEFAULT NULL::character varying, _notes character varying DEFAULT NULL::character varying",
            "type": "FUNCTION"
        },
        {
            "name": "ts.insertdatasetdatabase",
            "return_type": "void",
            "arguments": "_datasetid integer, _databaseid integer",
            "type": "FUNCTION"
        },
        {
            "name": "ts.insertdatasetpi",
            "return_type": "void",
            "arguments": "_datasetid integer, _contactid integer, _piorder integer",
            "type": "FUNCTION"
        },
        {
            "name": "ts.insertdatasetpublication",
            "return_type": "void",
            "arguments": "_datasetid integer, _publicationid integer, _primarypub boolean",
            "type": "FUNCTION"
        },
        {
            "name": "ts.insertdatasetrepository",
            "return_type": "void",
            "arguments": "_datasetid integer, _repositoryid integer, _notes character varying DEFAULT NULL::character varying",
            "type": "FUNCTION"
        },
        {
            "name": "ts.insertdatasetsubmission",
            "return_type": "int4",
            "arguments": "_datasetid integer, _databaseid integer, _contactid integer, _submissiontypeid integer, _submissiondate character varying, _notes character varying DEFAULT NULL::character varying",
            "type": "FUNCTION"
        },
        {
            "name": "ts.insertdatasettaxonnotes",
            "return_type": "void",
            "arguments": "_datasetid integer, _taxonid integer, _contactid integer, _date character varying, _notes character varying, _update boolean",
            "type": "FUNCTION"
        },
        {
            "name": "ts.insertdepagent",
            "return_type": "void",
            "arguments": "_analysisunitid integer, _depagentid integer",
            "type": "FUNCTION"
        },
        {
            "name": "ts.insertdepagenttypes",
            "return_type": "int4",
            "arguments": "_depagent character varying",
            "type": "FUNCTION"
        },
        {
            "name": "ts.insertdepenvttype",
            "return_type": "int4",
            "arguments": "_depenvt character varying, _depenvthigherid integer DEFAULT NULL::integer",
            "type": "FUNCTION"
        },
        {
            "name": "ts.insertecolgroup",
            "return_type": "void",
            "arguments": "_taxonid integer, _ecolsetid integer, _ecolgroupid character varying",
            "type": "FUNCTION"
        },
        {
            "name": "ts.insertecolgrouptype",
            "return_type": "varchar",
            "arguments": "_ecolgroupid character varying, _ecolgroup character varying",
            "type": "FUNCTION"
        },
        {
            "name": "ts.insertelementdatasettaxagroups",
            "return_type": "void",
            "arguments": "_datasettypeid integer, _taxagroupid character varying, _elementtypeid integer",
            "type": "FUNCTION"
        },
        {
            "name": "ts.insertelementmaturity",
            "return_type": "int4",
            "arguments": "_maturity character varying",
            "type": "FUNCTION"
        },
        {
            "name": "ts.insertelementportion",
            "return_type": "int4",
            "arguments": "_portion character varying",
            "type": "FUNCTION"
        },
        {
            "name": "ts.insertelementsymmetry",
            "return_type": "int4",
            "arguments": "_symmetry character varying",
            "type": "FUNCTION"
        },
        {
            "name": "ts.insertelementtaxagroupmaturity",
            "return_type": "void",
            "arguments": "_elementtaxagroupid integer, _maturityid integer",
            "type": "FUNCTION"
        },
        {
            "name": "ts.insertelementtaxagroupportion",
            "return_type": "void",
            "arguments": "_elementtaxagroupid integer, _portionid integer",
            "type": "FUNCTION"
        },
        {
            "name": "ts.insertelementtaxagroups",
            "return_type": "int4",
            "arguments": "_taxagroupid character varying, _elementtypeid integer",
            "type": "FUNCTION"
        },
        {
            "name": "ts.insertelementtaxagroupsymmetry",
            "return_type": "void",
            "arguments": "_elementtaxagroupid integer, _symmetryid integer",
            "type": "FUNCTION"
        },
        {
            "name": "ts.insertelementtype",
            "return_type": "int4",
            "arguments": "_elementtype character varying",
            "type": "FUNCTION"
        },
        {
            "name": "ts.insertevent",
            "return_type": "int4",
            "arguments": "_eventtypeid integer, _eventname character varying, _c14age double precision DEFAULT NULL::double precision, _c14ageyounger double precision DEFAULT NULL::double precision, _c14ageolder double precision DEFAULT NULL::double precision, _calage double precision DEFAULT NULL::double precision, _calageyounger double precision DEFAULT NULL::double precision, _calageolder double precision DEFAULT NULL::double precision, _notes character varying DEFAULT NULL::character varying",
            "type": "FUNCTION"
        },
        {
            "name": "ts.inserteventchronology",
            "return_type": "int4",
            "arguments": "_analysisunitid integer, _eventid integer, _chroncontrolid integer, _notes character varying DEFAULT NULL::character varying",
            "type": "FUNCTION"
        },
        {
            "name": "ts.inserteventpublication",
            "return_type": "void",
            "arguments": "_eventid integer, _publicationid integer",
            "type": "FUNCTION"
        },
        {
            "name": "ts.insertfaciestypes",
            "return_type": "int4",
            "arguments": "_facies character varying",
            "type": "FUNCTION"
        },
        {
            "name": "ts.insertformtaxon",
            "return_type": "int4",
            "arguments": "_taxonid integer, _affinityid integer, _publicationid integer, _systematicdescription boolean",
            "type": "FUNCTION"
        },
        {
            "name": "ts.insertfractiondated",
            "return_type": "int4",
            "arguments": "_fraction character varying",
            "type": "FUNCTION"
        },
        {
            "name": "ts.insertgeochron",
            "return_type": "int4",
            "arguments": "_sampleid integer, _geochrontypeid integer, _agetypeid integer, _age double precision DEFAULT NULL::double precision, _errorolder double precision DEFAULT NULL::double precision, _erroryounger double precision DEFAULT NULL::double precision, _infinite boolean DEFAULT false, _delta13c double precision DEFAULT NULL::double precision, _labnumber character varying DEFAULT NULL::character varying, _materialdated character varying DEFAULT NULL::character varying, _notes character varying DEFAULT NULL::character varying",
            "type": "FUNCTION"
        },
        {
            "name": "ts.insertgeochroncontrol",
            "return_type": "void",
            "arguments": "_chroncontrolid integer, _geochronid integer",
            "type": "FUNCTION"
        },
        {
            "name": "ts.insertgeochronpublication",
            "return_type": "void",
            "arguments": "_geochronid integer, _publicationid integer",
            "type": "FUNCTION"
        },
        {
            "name": "ts.insertgeopoliticalunit",
            "return_type": "int4",
            "arguments": "_geopolname character varying, _geopolunit character varying, _rank integer, _higherid integer",
            "type": "FUNCTION"
        },
        {
            "name": "ts.insertisoinstrumention",
            "return_type": "void",
            "arguments": "_datasetid integer, _variableid integer, _isoinstrumentationtypeid integer DEFAULT NULL::integer, _isosampleintrosystemtypeid integer DEFAULT NULL::integer, _insterrorpercent double precision DEFAULT NULL::double precision, _insterrorrunsd double precision DEFAULT NULL::double precision, _insterrorlongtermpercent double precision DEFAULT NULL::double precision, _notes character varying DEFAULT NULL::character varying",
            "type": "FUNCTION"
        },
        {
            "name": "ts.insertisometadata",
            "return_type": "void",
            "arguments": "_dataid integer, _isomatanaltypeid integer DEFAULT NULL::integer, _isosubstratetypeid integer DEFAULT NULL::integer, _analystid integer DEFAULT NULL::integer, _lab character varying DEFAULT NULL::character varying, _labnumber character varying DEFAULT NULL::character varying, _massmg double precision DEFAULT NULL::double precision, _weightpercent double precision DEFAULT NULL::double precision, _atomicpercent double precision DEFAULT NULL::double precision, _reps integer DEFAULT NULL::integer",
            "type": "FUNCTION"
        },
        {
            "name": "ts.insertisosamplepretreatments",
            "return_type": "void",
            "arguments": "_dataid integer, _isopretreatmenttypeid integer, _order integer, _value double precision DEFAULT NULL::double precision",
            "type": "FUNCTION"
        },
        {
            "name": "ts.insertisospecimendata",
            "return_type": "void",
            "arguments": "_dataid integer, _specimenid integer, _sd double precision DEFAULT NULL::double precision",
            "type": "FUNCTION"
        },
        {
            "name": "ts.insertisospecimentaphonomy",
            "return_type": "void",
            "arguments": "_specimenid integer, _taphonomictypeid integer",
            "type": "FUNCTION"
        },
        {
            "name": "ts.insertisosrmetadata",
            "return_type": "void",
            "arguments": "_datasetid integer, _variableid integer, _srlocalvalue double precision DEFAULT NULL::double precision, _srlocalgeolcontext character varying DEFAULT NULL::character varying",
            "type": "FUNCTION"
        },
        {
            "name": "ts.insertisostandards",
            "return_type": "void",
            "arguments": "_datasetid integer, _variableid integer, _isostandardid integer, _value double precision",
            "type": "FUNCTION"
        },
        {
            "name": "ts.insertisostratdata",
            "return_type": "void",
            "arguments": "_dataid integer, _sd double precision DEFAULT NULL::double precision, _taxonid integer DEFAULT NULL::integer, _elementtypeid integer DEFAULT NULL::integer",
            "type": "FUNCTION"
        },
        {
            "name": "ts.insertlakeparameter",
            "return_type": "void",
            "arguments": "_siteid integer, _lakeparameterid integer, _value double precision",
            "type": "FUNCTION"
        },
        {
            "name": "ts.insertlithology",
            "return_type": "int4",
            "arguments": "_collectionunitid integer, _depthtop double precision DEFAULT NULL::double precision, _depthbottom double precision DEFAULT NULL::double precision, _lowerboundary character varying DEFAULT NULL::character varying, _description character varying DEFAULT NULL::character varying",
            "type": "FUNCTION"
        },
        {
            "name": "ts.insertnewdatasetpi",
            "return_type": "void",
            "arguments": "_datasetid integer, _contactid integer",
            "type": "FUNCTION"
        },
        {
            "name": "ts.insertpublication",
            "return_type": "int4",
            "arguments": "_pubtypeid integer, _year character varying DEFAULT NULL::character varying, _citation character varying DEFAULT NULL::character varying, _title character varying DEFAULT NULL::character varying, _journal character varying DEFAULT NULL::character varying, _vol character varying DEFAULT NULL::character varying, _issue character varying DEFAULT NULL::character varying, _pages character varying DEFAULT NULL::character varying, _citnumber character varying DEFAULT NULL::character varying, _doi character varying DEFAULT NULL::character varying, _booktitle character varying DEFAULT NULL::character varying, _numvol character varying DEFAULT NULL::character varying, _edition character varying DEFAULT NULL::character varying, _voltitle character varying DEFAULT NULL::character varying, _sertitle character varying DEFAULT NULL::character varying, _servol character varying DEFAULT NULL::character varying, _publisher character varying DEFAULT NULL::character varying, _url character varying DEFAULT NULL::character varying, _city character varying DEFAULT NULL::character varying, _state character varying DEFAULT NULL::character varying, _country character varying DEFAULT NULL::character varying, _origlang character varying DEFAULT NULL::character varying, _notes character varying DEFAULT NULL::character varying",
            "type": "FUNCTION"
        },
        {
            "name": "ts.insertpublicationauthors",
            "return_type": "int4",
            "arguments": "_publicationid integer, _authororder integer, _familyname character varying, _initials character varying DEFAULT NULL::character varying, _suffix character varying DEFAULT NULL::character varying, _contactid integer DEFAULT NULL::integer",
            "type": "FUNCTION"
        },
        {
            "name": "ts.insertpublicationeditors",
            "return_type": "int4",
            "arguments": "_publicationid integer, _editororder integer, _familyname character varying, _initials character varying DEFAULT NULL::character varying, _suffix character varying DEFAULT NULL::character varying",
            "type": "FUNCTION"
        },
        {
            "name": "ts.insertpublicationtranslators",
            "return_type": "int4",
            "arguments": "_publicationid integer, _translatororder integer, _familyname character varying, _initials character varying DEFAULT NULL::character varying, _suffix character varying DEFAULT NULL::character varying",
            "type": "FUNCTION"
        },
        {
            "name": "ts.insertradiocarbon",
            "return_type": "void",
            "arguments": "_geochronid integer, _radiocarbonmethodid integer DEFAULT NULL::integer, _percentc double precision DEFAULT NULL::double precision, _percentn double precision DEFAULT NULL::double precision, _delta13c double precision DEFAULT NULL::double precision, _delta15n double precision DEFAULT NULL::double precision, _cnratio double precision DEFAULT NULL::double precision, _masscmg double precision DEFAULT NULL::double precision, _percentcollagen double precision DEFAULT NULL::double precision, _reservoir double precision DEFAULT NULL::double precision",
            "type": "FUNCTION"
        },
        {
            "name": "ts.insertrelativeage",
            "return_type": "int4",
            "arguments": "_relativeageunitid integer, _relativeagescaleid integer, _relativeage character varying, _c14ageyounger double precision DEFAULT NULL::double precision, _c14ageolder double precision DEFAULT NULL::double precision, _calageyounger double precision DEFAULT NULL::double precision, _calageolder double precision DEFAULT NULL::double precision, _notes character varying DEFAULT NULL::character varying",
            "type": "FUNCTION"
        },
        {
            "name": "ts.insertrelativeagepublication",
            "return_type": "void",
            "arguments": "_relativeageid integer, _publicationid integer",
            "type": "FUNCTION"
        },
        {
            "name": "ts.insertrelativechronology",
            "return_type": "int4",
            "arguments": "_analysisunitid integer, _relativeageid integer, _chroncontrolid integer, _notes character varying DEFAULT NULL::character varying",
            "type": "FUNCTION"
        },
        {
            "name": "ts.insertrepositoryinstitution",
            "return_type": "int4",
            "arguments": "_acronym character varying, _repository character varying, _notes character varying DEFAULT NULL::character varying",
            "type": "FUNCTION"
        },
        {
            "name": "ts.insertsample",
            "return_type": "int4",
            "arguments": "_analysisunitid integer, _datasetid integer, _samplename character varying DEFAULT NULL::character varying, _sampledate character varying DEFAULT NULL::character varying, _analysisdate character varying DEFAULT NULL::character varying, _taxonid integer DEFAULT NULL::integer, _labnumber character varying DEFAULT NULL::character varying, _prepmethod character varying DEFAULT NULL::character varying, _notes character varying DEFAULT NULL::character varying",
            "type": "FUNCTION"
        },
        {
            "name": "ts.insertsampleage",
            "return_type": "int4",
            "arguments": "_sampleid integer, _chronologyid integer, _age double precision DEFAULT NULL::double precision, _ageyounger double precision DEFAULT NULL::double precision, _ageolder double precision DEFAULT NULL::double precision",
            "type": "FUNCTION"
        },
        {
            "name": "ts.insertsampleanalyst",
            "return_type": "int4",
            "arguments": "_sampleid integer, _contactid integer, _analystorder integer",
            "type": "FUNCTION"
        },
        {
            "name": "ts.insertsamplekeyword",
            "return_type": "void",
            "arguments": "_sampleid integer, _keywordid integer",
            "type": "FUNCTION"
        },
        {
            "name": "ts.insertsite",
            "return_type": "int4",
            "arguments": "_sitename character varying, _east numeric, _north numeric, _west numeric, _south numeric, _altitude integer DEFAULT NULL::integer, _area numeric DEFAULT NULL::numeric, _descript character varying DEFAULT NULL::character varying, _notes character varying DEFAULT NULL::character varying",
            "type": "FUNCTION"
        },
        {
            "name": "ts.insertsitegeopol",
            "return_type": "int4",
            "arguments": "_siteid integer, _geopoliticalid integer",
            "type": "FUNCTION"
        },
        {
            "name": "ts.insertspecimen",
            "return_type": "int4",
            "arguments": "_dataid integer, _elementtypeid integer DEFAULT NULL::integer, _symmetryid integer DEFAULT NULL::integer, _portionid integer DEFAULT NULL::integer, _maturityid integer DEFAULT NULL::integer, _sexid integer DEFAULT NULL::integer, _domesticstatusid integer DEFAULT NULL::integer, _preservative character varying DEFAULT NULL::character varying, _nisp double precision DEFAULT NULL::double precision, _repositoryid integer DEFAULT NULL::integer, _specimennr character varying DEFAULT NULL::character varying, _fieldnr character varying DEFAULT NULL::character varying, _arctosnr character varying DEFAULT NULL::character varying, _notes character varying DEFAULT NULL::character varying",
            "type": "FUNCTION"
        },
        {
            "name": "ts.insertspecimendate",
            "return_type": "int4",
            "arguments": "_geochronid integer, _specimenid integer DEFAULT NULL::integer, _taxonid integer DEFAULT NULL::integer, _elementtypeid integer DEFAULT NULL::integer, _fractionid integer DEFAULT NULL::integer, _sampleid integer DEFAULT NULL::integer, _notes character varying DEFAULT NULL::character varying",
            "type": "FUNCTION"
        },
        {
            "name": "ts.insertspecimendatecal",
            "return_type": "int4",
            "arguments": "_specimendateid integer, _calage double precision DEFAULT NULL::double precision, _calageolder double precision DEFAULT NULL::double precision, _calageyounger double precision DEFAULT NULL::double precision, _calibrationcurveid integer DEFAULT NULL::integer, _calibrationprogramid integer DEFAULT NULL::integer, _datecalibrated character varying DEFAULT NULL::character varying",
            "type": "FUNCTION"
        },
        {
            "name": "ts.insertspecimengenbanknr",
            "return_type": "void",
            "arguments": "_specimenid integer, _genbanknr character varying",
            "type": "FUNCTION"
        },
        {
            "name": "ts.insertspecimentaphonomy",
            "return_type": "void",
            "arguments": "_specimenid integer, _taphonomictypeid integer",
            "type": "FUNCTION"
        },
        {
            "name": "ts.insertsteward",
            "return_type": "int4",
            "arguments": "_contactid integer, _username character varying, _password character varying, _taxonomyexpert boolean, _databaseid integer",
            "type": "FUNCTION"
        },
        {
            "name": "ts.insertsummarydatataphonomy",
            "return_type": "void",
            "arguments": "_dataid integer, _taphonomictypeid integer",
            "type": "FUNCTION"
        },
        {
            "name": "ts.insertsynonym",
            "return_type": "int4",
            "arguments": "_invalidtaxonid integer, _validtaxonid integer, _synonymtypeid integer DEFAULT NULL::integer",
            "type": "FUNCTION"
        },
        {
            "name": "ts.insertsynonymtype",
            "return_type": "int4",
            "arguments": "_synonymtype character varying",
            "type": "FUNCTION"
        },
        {
            "name": "ts.insertsynonymy",
            "return_type": "int4",
            "arguments": "_datasetid integer, _taxonid integer, _reftaxonid integer, _fromcontributor boolean DEFAULT false, _publicationid integer DEFAULT NULL::integer, _notes character varying DEFAULT NULL::character varying, _contactid integer DEFAULT NULL::integer, _datesynoynmized character varying DEFAULT NULL::character varying",
            "type": "FUNCTION"
        },
        {
            "name": "ts.inserttaphonomicsystem",
            "return_type": "int4",
            "arguments": "_taphonomicsystem character varying, _notes character varying DEFAULT NULL::character varying",
            "type": "FUNCTION"
        },
        {
            "name": "ts.inserttaphonomicsystemdatasettype",
            "return_type": "void",
            "arguments": "_datasettypeid integer, _taphonomicsystemid integer",
            "type": "FUNCTION"
        },
        {
            "name": "ts.inserttaphonomictype",
            "return_type": "int4",
            "arguments": "_taphonomicsystemid integer, _taphonomictype character varying, _notes character varying DEFAULT NULL::character varying",
            "type": "FUNCTION"
        },
        {
            "name": "ts.inserttaxagroup",
            "return_type": "void",
            "arguments": "_taxagroupid character varying, _taxagroup character varying",
            "type": "FUNCTION"
        },
        {
            "name": "ts.inserttaxon",
            "return_type": "int4",
            "arguments": "_code character varying, _name character varying, _extinct boolean, _groupid character, _author character varying DEFAULT NULL::character varying, _valid boolean DEFAULT true, _higherid integer DEFAULT NULL::integer, _pubid integer DEFAULT NULL::integer, _validatorid integer DEFAULT NULL::integer, _validatedate character varying DEFAULT NULL::character varying, _notes character varying DEFAULT NULL::character varying",
            "type": "FUNCTION"
        },
        {
            "name": "ts.inserttephra",
            "return_type": "int4",
            "arguments": "_eventid integer, _analysisunitid integer, _notes character varying DEFAULT NULL::character varying",
            "type": "FUNCTION"
        },
        {
            "name": "ts.insertunitsdatasettypes",
            "return_type": "void",
            "arguments": "_datasettypeid integer, _variableunitsid integer",
            "type": "FUNCTION"
        },
        {
            "name": "ts.insertvariable",
            "return_type": "int4",
            "arguments": "_taxonid integer, _variableelementid integer, _variableunitsid integer DEFAULT NULL::integer, _variablecontextid integer DEFAULT NULL::integer",
            "type": "FUNCTION"
        },
        {
            "name": "ts.insertvariablecontext",
            "return_type": "int4",
            "arguments": "_context character varying",
            "type": "FUNCTION"
        },
        {
            "name": "ts.insertvariableelement",
            "return_type": "int4",
            "arguments": "_variableelement character varying, _elementtype integer, _symmetryid integer DEFAULT NULL::integer, _portionid integer DEFAULT NULL::integer, _maturityid integer DEFAULT NULL::integer",
            "type": "FUNCTION"
        },
        {
            "name": "ts.insertvariableunits",
            "return_type": "int4",
            "arguments": "_units character varying",
            "type": "FUNCTION"
        },
        {
            "name": "ts.linkhigher",
            "return_type": "void",
            "arguments": "",
            "type": "FUNCTION"
        },
        {
            "name": "ts.update_recdatemodified",
            "return_type": "trigger",
            "arguments": "",
            "type": "FUNCTION"
        },
        {
            "name": "ts.updateanalysisunitdepth",
            "return_type": "void",
            "arguments": "_analysisunitid integer, _depth double precision",
            "type": "FUNCTION"
        },
        {
            "name": "ts.updateanalysisunitname",
            "return_type": "void",
            "arguments": "_analysisunitid integer, _analysisunitname character varying",
            "type": "FUNCTION"
        },
        {
            "name": "ts.updateanalysisunitthickness",
            "return_type": "void",
            "arguments": "_analysisunitid integer, _thickness double precision",
            "type": "FUNCTION"
        },
        {
            "name": "ts.updatechroncontrolage",
            "return_type": "void",
            "arguments": "_chroncontrolid integer, _age double precision DEFAULT NULL::double precision",
            "type": "FUNCTION"
        },
        {
            "name": "ts.updatechroncontrolagebasis",
            "return_type": "void",
            "arguments": "_chroncontrolid integer, _chroncontroltypeid integer",
            "type": "FUNCTION"
        },
        {
            "name": "ts.updatechroncontrolageolder",
            "return_type": "void",
            "arguments": "_chroncontrolid integer, _agelimitolder double precision DEFAULT NULL::double precision",
            "type": "FUNCTION"
        },
        {
            "name": "ts.updatechroncontrolagetype",
            "return_type": "void",
            "arguments": "_chroncontrolid integer, _agetypeid integer",
            "type": "FUNCTION"
        },
        {
            "name": "ts.updatechroncontrolageyounger",
            "return_type": "void",
            "arguments": "_chroncontrolid integer, _ageyounger double precision DEFAULT NULL::double precision",
            "type": "FUNCTION"
        },
        {
            "name": "ts.updatechroncontrolanalysisunit",
            "return_type": "void",
            "arguments": "_chroncontrolid integer, _depth integer, _thickness integer, _analunitid integer",
            "type": "FUNCTION"
        },
        {
            "name": "ts.updatechroncontroldepththickness",
            "return_type": "void",
            "arguments": "_chroncontrolid integer, _depth integer, _thickness integer, _analunitid integer",
            "type": "FUNCTION"
        },
        {
            "name": "ts.updatechroncontrolevent",
            "return_type": "void",
            "arguments": "_chroncontrolid integer, _eventid integer, _analysisunitid integer DEFAULT NULL::integer",
            "type": "FUNCTION"
        },
        {
            "name": "ts.updatechroncontrolnotes",
            "return_type": "void",
            "arguments": "_chroncontrolid integer, _notes character varying DEFAULT NULL::character varying",
            "type": "FUNCTION"
        },
        {
            "name": "ts.updatechroncontroltype",
            "return_type": "void",
            "arguments": "_chroncontroltypeid integer, _chroncontroltype character varying",
            "type": "FUNCTION"
        },
        {
            "name": "ts.updatechronology",
            "return_type": "void",
            "arguments": "_chronologyid integer, _agetype character varying, _isdefault boolean, _contactid integer DEFAULT NULL::integer, _chronologyname character varying DEFAULT NULL::character varying, _dateprepared character varying DEFAULT NULL::character varying, _agemodel character varying DEFAULT NULL::character varying, _ageboundyounger integer DEFAULT NULL::integer, _ageboundolder integer DEFAULT NULL::integer, _notes character varying DEFAULT NULL::character varying",
            "type": "FUNCTION"
        },
        {
            "name": "ts.updatecollectionunit",
            "return_type": "void",
            "arguments": "_collunitid integer, _stewardcontactid integer, _handle character varying, _colltypeid integer DEFAULT NULL::integer, _depenvtid integer DEFAULT NULL::integer, _collunitname character varying DEFAULT NULL::character varying, _colldate date DEFAULT NULL::date, _colldevice character varying DEFAULT NULL::character varying, _gpslatitude double precision DEFAULT NULL::double precision, _gpslongitude double precision DEFAULT NULL::double precision, _gpsaltitude double precision DEFAULT NULL::double precision, _gpserror double precision DEFAULT NULL::double precision, _waterdepth double precision DEFAULT NULL::double precision, _substrateid integer DEFAULT NULL::integer, _slopeaspect integer DEFAULT NULL::integer, _slopeangle integer DEFAULT NULL::integer, _location character varying DEFAULT NULL::character varying, _notes character varying DEFAULT NULL::character varying",
            "type": "FUNCTION"
        },
        {
            "name": "ts.updatecontact",
            "return_type": "void",
            "arguments": "_contactid integer, _aliasid integer DEFAULT NULL::integer, _contactname character varying DEFAULT NULL::character varying, _statusid integer DEFAULT NULL::integer, _familyname character varying DEFAULT NULL::character varying, _initials character varying DEFAULT NULL::character varying, _givennames character varying DEFAULT NULL::character varying, _suffix character varying DEFAULT NULL::character varying, _title character varying DEFAULT NULL::character varying, _phone character varying DEFAULT NULL::character varying, _fax character varying DEFAULT NULL::character varying, _email character varying DEFAULT NULL::character varying, _url character varying DEFAULT NULL::character varying, _address character varying DEFAULT NULL::character varying, _notes character varying DEFAULT NULL::character varying",
            "type": "FUNCTION"
        },
        {
            "name": "ts.updatecontactaliasid",
            "return_type": "void",
            "arguments": "_contactid integer, _aliasid integer",
            "type": "FUNCTION"
        },
        {
            "name": "ts.updatedata",
            "return_type": "void",
            "arguments": "_dataid integer, _value double precision",
            "type": "FUNCTION"
        },
        {
            "name": "ts.updatedatasetname",
            "return_type": "void",
            "arguments": "_datasetid integer, _datasetname character varying",
            "type": "FUNCTION"
        },
        {
            "name": "ts.updatedatasetnotes",
            "return_type": "void",
            "arguments": "_datasetid integer, _datasetnotes character varying DEFAULT NULL::character varying",
            "type": "FUNCTION"
        },
        {
            "name": "ts.updatedatasetpubprimary",
            "return_type": "void",
            "arguments": "_datasetid integer, _publicationid integer, _primary boolean",
            "type": "FUNCTION"
        },
        {
            "name": "ts.updatedatasetrepositorynotes",
            "return_type": "void",
            "arguments": "_datasetid integer, _repositoryid integer, _notes character varying DEFAULT NULL::character varying",
            "type": "FUNCTION"
        },
        {
            "name": "ts.updatedatasettaxonnotes",
            "return_type": "void",
            "arguments": "_datasetid integer, _taxonid integer, _contactid integer, _date character varying, _notes character varying",
            "type": "FUNCTION"
        },
        {
            "name": "ts.updatedatasettype",
            "return_type": "void",
            "arguments": "_datasetid integer, _datasettype character varying",
            "type": "FUNCTION"
        },
        {
            "name": "ts.updatedatasetvariable",
            "return_type": "void",
            "arguments": "_oldvariableid integer, _newvariableid integer, _sampleid1 integer, _sampleid2 integer",
            "type": "FUNCTION"
        },
        {
            "name": "ts.updatedatavariable",
            "return_type": "void",
            "arguments": "_datasetid integer, _oldvariableid integer, _newvariableid integer",
            "type": "FUNCTION"
        },
        {
            "name": "ts.updatedatavariableid",
            "return_type": "void",
            "arguments": "_oldvariableid integer, _newvariableid integer",
            "type": "FUNCTION"
        },
        {
            "name": "ts.updatedatavariableid_deletevariable",
            "return_type": "void",
            "arguments": "_savevarid integer, _delvarid integer",
            "type": "FUNCTION"
        },
        {
            "name": "ts.updatedepenvthigherid",
            "return_type": "void",
            "arguments": "_depenvtid integer, _depenvthigherid integer",
            "type": "FUNCTION"
        },
        {
            "name": "ts.updatedepenvttype",
            "return_type": "void",
            "arguments": "_depenvtid integer, _depenvt character varying, _depenvthigherid integer",
            "type": "FUNCTION"
        },
        {
            "name": "ts.updateevent",
            "return_type": "void",
            "arguments": "_eventid integer, _eventtypeid integer, _eventname character varying, _c14age double precision DEFAULT NULL::double precision, _c14ageyounger double precision DEFAULT NULL::double precision, _c14ageolder double precision DEFAULT NULL::double precision, _calage double precision DEFAULT NULL::double precision, _calageyounger double precision DEFAULT NULL::double precision, _calageolder double precision DEFAULT NULL::double precision, _notes character varying DEFAULT NULL::character varying",
            "type": "FUNCTION"
        },
        {
            "name": "ts.updategeochron",
            "return_type": "void",
            "arguments": "_geochronid integer, _geochrontypeid integer, _agetypeid integer, _age double precision DEFAULT NULL::double precision, _errorolder double precision DEFAULT NULL::double precision, _erroryounger double precision DEFAULT NULL::double precision, _infinite boolean DEFAULT false, _labnumber character varying DEFAULT NULL::character varying, _materialdated character varying DEFAULT NULL::character varying, _notes character varying DEFAULT NULL::character varying",
            "type": "FUNCTION"
        },
        {
            "name": "ts.updategeochronanalysisunit",
            "return_type": "void",
            "arguments": "_geochronid integer, _analysisunitid integer, _depth double precision DEFAULT NULL::double precision, _thickness double precision DEFAULT NULL::double precision, _analysisunitname character varying DEFAULT NULL::character varying",
            "type": "FUNCTION"
        },
        {
            "name": "ts.updategeochrondatasetpubs",
            "return_type": "void",
            "arguments": "_datasetid integer",
            "type": "FUNCTION"
        },
        {
            "name": "ts.updateissurfacesample",
            "return_type": "void",
            "arguments": "_datasetid integer, _issamp boolean",
            "type": "FUNCTION"
        },
        {
            "name": "ts.updatelakeparam",
            "return_type": "void",
            "arguments": "_siteid integer, _stewardcontactid integer, _lakeparameter character varying, _value numeric DEFAULT NULL::numeric",
            "type": "FUNCTION"
        },
        {
            "name": "ts.updatepublication",
            "return_type": "void",
            "arguments": "_publicationid integer, _pubtypeid integer, _year character varying DEFAULT NULL::character varying, _citation character varying DEFAULT NULL::character varying, _title character varying DEFAULT NULL::character varying, _journal character varying DEFAULT NULL::character varying, _vol character varying DEFAULT NULL::character varying, _issue character varying DEFAULT NULL::character varying, _pages character varying DEFAULT NULL::character varying, _citnumber character varying DEFAULT NULL::character varying, _doi character varying DEFAULT NULL::character varying, _booktitle character varying DEFAULT NULL::character varying, _numvol character varying DEFAULT NULL::character varying, _edition character varying DEFAULT NULL::character varying, _voltitle character varying DEFAULT NULL::character varying, _sertitle character varying DEFAULT NULL::character varying, _servol character varying DEFAULT NULL::character varying, _publisher character varying DEFAULT NULL::character varying, _url character varying DEFAULT NULL::character varying, _city character varying DEFAULT NULL::character varying, _state character varying DEFAULT NULL::character varying, _country character varying DEFAULT NULL::character varying, _origlang character varying DEFAULT NULL::character varying, _notes character varying DEFAULT NULL::character varying",
            "type": "FUNCTION"
        },
        {
            "name": "ts.updatepublicationauthor",
            "return_type": "void",
            "arguments": "_authorid integer, _publicationid integer, _authororder integer, _familyname character varying, _contactid integer, _initials character varying DEFAULT NULL::character varying, _suffix character varying DEFAULT NULL::character varying",
            "type": "FUNCTION"
        },
        {
            "name": "ts.updatepublicationeditor",
            "return_type": "void",
            "arguments": "_editorid integer, _publicationid integer, _editororder integer, _familyname character varying, _initials character varying DEFAULT NULL::character varying, _suffix character varying DEFAULT NULL::character varying",
            "type": "FUNCTION"
        },
        {
            "name": "ts.updatepublicationtranslator",
            "return_type": "void",
            "arguments": "_translatorid integer, _publicationid integer, _translatororder integer, _familyname character varying, _initials character varying DEFAULT NULL::character varying, _suffix character varying DEFAULT NULL::character varying",
            "type": "FUNCTION"
        },
        {
            "name": "ts.updateradiocarbon",
            "return_type": "void",
            "arguments": "_geochronid integer, _radiocarbonmethodid integer DEFAULT NULL::integer, _percentc double precision DEFAULT NULL::double precision, _percentn double precision DEFAULT NULL::double precision, _delta13c double precision DEFAULT NULL::double precision, _delta15n double precision DEFAULT NULL::double precision, _percentcollagen double precision DEFAULT NULL::double precision, _reservoir double precision DEFAULT NULL::double precision",
            "type": "FUNCTION"
        },
        {
            "name": "ts.updaterelativeage",
            "return_type": "void",
            "arguments": "_relativeageid integer, _relativeageunitid integer, _relativeagescaleid integer, _relativeage character varying, _c14ageyounger double precision DEFAULT NULL::double precision, _c14ageolder double precision DEFAULT NULL::double precision, _calageyounger double precision DEFAULT NULL::double precision, _calageolder double precision DEFAULT NULL::double precision, _notes character varying DEFAULT NULL::character varying",
            "type": "FUNCTION"
        },
        {
            "name": "ts.updatesampleage",
            "return_type": "void",
            "arguments": "_sampleageid integer, _age double precision DEFAULT NULL::double precision, _ageyounger double precision DEFAULT NULL::double precision, _ageolder double precision DEFAULT NULL::double precision",
            "type": "FUNCTION"
        },
        {
            "name": "ts.updatesampleanalysisunit",
            "return_type": "void",
            "arguments": "_sampleid integer, _analunitid integer",
            "type": "FUNCTION"
        },
        {
            "name": "ts.updatesamplelabnumber",
            "return_type": "void",
            "arguments": "_sampleid integer, _labnumber character varying DEFAULT NULL::character varying",
            "type": "FUNCTION"
        },
        {
            "name": "ts.updatesite",
            "return_type": "void",
            "arguments": "_siteid integer, _stewardcontactid integer, _sitename character varying DEFAULT NULL::character varying, _east numeric DEFAULT NULL::numeric, _north numeric DEFAULT NULL::numeric, _west numeric DEFAULT NULL::numeric, _south numeric DEFAULT NULL::numeric, _altitude integer DEFAULT NULL::integer, _area numeric DEFAULT NULL::numeric, _descript character varying DEFAULT NULL::character varying, _notes character varying DEFAULT NULL::character varying",
            "type": "FUNCTION"
        },
        {
            "name": "ts.updatesitegeopol",
            "return_type": "void",
            "arguments": "_siteid integer, _stewardcontactid integer, _oldgeopolid integer, _newgeopolid integer",
            "type": "FUNCTION"
        },
        {
            "name": "ts.updatesitegeopoldelete",
            "return_type": "void",
            "arguments": "_stewardcontactid integer, _siteid integer, _geopoliticalid integer",
            "type": "FUNCTION"
        },
        {
            "name": "ts.updatesitegeopolinsert",
            "return_type": "void",
            "arguments": "_siteid integer, _stewardcontactid integer, _geopoliticalid integer",
            "type": "FUNCTION"
        },
        {
            "name": "ts.updatesitelatlon",
            "return_type": "void",
            "arguments": "_siteid integer, _stewardcontactid integer, _east numeric, _north numeric, _west numeric, _south numeric",
            "type": "FUNCTION"
        },
        {
            "name": "ts.updatespecimendatetaxonid",
            "return_type": "void",
            "arguments": "_oldtaxonid integer, _newtaxonid integer",
            "type": "FUNCTION"
        },
        {
            "name": "ts.updatespecimennisp",
            "return_type": "void",
            "arguments": "_specimenid integer, _nisp double precision, _contactid integer",
            "type": "FUNCTION"
        },
        {
            "name": "ts.updatespecimennumber",
            "return_type": "void",
            "arguments": "_specimenid integer, _specimennr integer",
            "type": "FUNCTION"
        },
        {
            "name": "ts.updatesynonymtypeid",
            "return_type": "void",
            "arguments": "_synonymid integer, _synonymtypeid integer",
            "type": "FUNCTION"
        },
        {
            "name": "ts.updatesynonymy",
            "return_type": "void",
            "arguments": "_synonymyid integer, _reftaxonid integer, _fromcontributor boolean DEFAULT false, _publicationid integer DEFAULT NULL::integer, _notes character varying DEFAULT NULL::character varying, _contactid integer DEFAULT NULL::integer, _datesynonymized date DEFAULT NULL::date",
            "type": "FUNCTION"
        },
        {
            "name": "ts.updatetaphonomicsystemnotes",
            "return_type": "void",
            "arguments": "_taphonomicsystemid integer, _notes character varying",
            "type": "FUNCTION"
        },
        {
            "name": "ts.updatetaxonauthor",
            "return_type": "void",
            "arguments": "_taxonid integer, _author character varying DEFAULT NULL::character varying",
            "type": "FUNCTION"
        },
        {
            "name": "ts.updatetaxoncode",
            "return_type": "void",
            "arguments": "_taxonid integer, _taxoncode character varying",
            "type": "FUNCTION"
        },
        {
            "name": "ts.updatetaxonextinct",
            "return_type": "void",
            "arguments": "_taxonid integer, _extinct boolean",
            "type": "FUNCTION"
        },
        {
            "name": "ts.updatetaxonhighertaxonid",
            "return_type": "void",
            "arguments": "_taxonid integer, _highertaxonid integer",
            "type": "FUNCTION"
        },
        {
            "name": "ts.updatetaxonhighertaxonidtonull",
            "return_type": "void",
            "arguments": "_taxonid integer",
            "type": "FUNCTION"
        },
        {
            "name": "ts.updatetaxonname",
            "return_type": "void",
            "arguments": "_taxonid integer, _taxonname character varying",
            "type": "FUNCTION"
        },
        {
            "name": "ts.updatetaxonnotes",
            "return_type": "void",
            "arguments": "_taxonid integer, _notes character varying DEFAULT NULL::character varying",
            "type": "FUNCTION"
        },
        {
            "name": "ts.updatetaxonpublicationid",
            "return_type": "void",
            "arguments": "_taxonid integer, _publicationid integer DEFAULT NULL::integer",
            "type": "FUNCTION"
        },
        {
            "name": "ts.updatetaxonvalidation",
            "return_type": "void",
            "arguments": "_taxonid integer, _validatorid integer, _validatedate character varying",
            "type": "FUNCTION"
        },
        {
            "name": "ts.updatetaxonvalidity",
            "return_type": "void",
            "arguments": "_taxonid integer, _valid boolean",
            "type": "FUNCTION"
        },
        {
            "name": "ts.updatevariabletaxonid",
            "return_type": "void",
            "arguments": "_variableid integer, _newtaxonid integer",
            "type": "FUNCTION"
        },
        {
            "name": "ts.validatesteward",
            "return_type": "int4",
            "arguments": "_username character varying, _pwd character varying",
            "type": "FUNCTION"
        },
        {
            "name": "ts.validateusername",
            "return_type": "record",
            "arguments": "_username character varying",
            "type": "FUNCTION"
        },
        {
            "name": "ap.dailyquerytable",
            "return_type": "record",
            "arguments": "_interval character varying",
            "type": "FUNCTION"
        },
        {
            "name": "ap.dailysummaries",
            "return_type": "record",
            "arguments": "_interval character varying DEFAULT '1'::character varying",
            "type": "FUNCTION"
        },
        {
            "name": "pganalyze.get_column_stats",
            "return_type": "pg_stats",
            "arguments": "",
            "type": "FUNCTION"
        },
        {
            "name": "pganalyze.get_relation_stats_ext",
            "return_type": "record",
            "arguments": "",
            "type": "FUNCTION"
        },
        {
            "name": "cron.schedule",
            "return_type": "int8",
            "arguments": "schedule text, command text",
            "type": "FUNCTION"
        },
        {
            "name": "cron.unschedule",
            "return_type": "bool",
            "arguments": "job_id bigint",
            "type": "FUNCTION"
        },
        {
            "name": "cron.job_cache_invalidate",
            "return_type": "trigger",
            "arguments": "",
            "type": "FUNCTION"
        },
        {
            "name": "cron.schedule",
            "return_type": "int8",
            "arguments": "job_name text, schedule text, command text",
            "type": "FUNCTION"
        },
        {
            "name": "cron.alter_job",
            "return_type": "void",
            "arguments": "job_id bigint, schedule text DEFAULT NULL::text, command text DEFAULT NULL::text, database text DEFAULT NULL::text, username text DEFAULT NULL::text, active boolean DEFAULT NULL::boolean",
            "type": "FUNCTION"
        },
        {
            "name": "cron.schedule_in_database",
            "return_type": "int8",
            "arguments": "job_name text, schedule text, command text, database text, username text DEFAULT NULL::text, active boolean DEFAULT true",
            "type": "FUNCTION"
        },
        {
            "name": "cron.unschedule",
            "return_type": "bool",
            "arguments": "job_name text",
            "type": "FUNCTION"
        },
        {
            "name": "public.insert_lead_model",
            "return_type": "void",
            "arguments": "_pbbasisid numeric, _analysisunitid numeric, _cumulativeinventory numeric",
            "type": "FUNCTION"
        },
        {
            "name": "public.insert_data_uncertainty",
            "return_type": "void",
            "arguments": "_dataid numeric, _uncertaintyvalue numeric DEFAULT NULL::numeric, _uncertaintyunitid numeric DEFAULT NULL::numeric, _uncertaintybasisid numeric DEFAULT NULL::numeric, _notes character varying DEFAULT NULL::character varying",
            "type": "FUNCTION"
        },
        {
            "name": "public.upsert_site",
            "return_type": "int4",
            "arguments": "_siteid integer, _sitename character varying, _altitude integer DEFAULT NULL::integer, _area numeric DEFAULT NULL::numeric, _descript character varying DEFAULT NULL::character varying, _notes character varying DEFAULT NULL::character varying, _east numeric DEFAULT NULL::integer, _north numeric DEFAULT NULL::integer, _west numeric DEFAULT NULL::integer, _south numeric DEFAULT NULL::integer",
            "type": "FUNCTION"
        },
        {
            "name": "public.upsert_collunit",
            "return_type": "int4",
            "arguments": "_collectionunitid integer, _handle character varying, _siteid integer, _colltypeid integer DEFAULT NULL::integer, _depenvtid integer DEFAULT NULL::integer, _collunitname character varying DEFAULT NULL::character varying, _colldate date DEFAULT NULL::date, _colldevice character varying DEFAULT NULL::character varying, _gpslatitude double precision DEFAULT NULL::double precision, _gpslongitude double precision DEFAULT NULL::double precision, _gpsaltitude double precision DEFAULT NULL::double precision, _gpserror double precision DEFAULT NULL::double precision, _waterdepth double precision DEFAULT NULL::double precision, _substrateid integer DEFAULT NULL::integer, _slopeaspect integer DEFAULT NULL::integer, _slopeangle integer DEFAULT NULL::integer, _location character varying DEFAULT NULL::character varying, _notes character varying DEFAULT NULL::character varying",
            "type": "FUNCTION"
        }
    ],
    "driver": {
        "name": "postgres",
        "database_version": "PostgreSQL 15.8 on x86_64-pc-linux-gnu, compiled by gcc (GCC) 7.3.1 20180712 (Red Hat 7.3.1-17), 64-bit",
        "meta": {
            "current_schema": "public",
            "search_paths": [
                "neotomaAdmin",
                "public"
            ],
            "dict": {
                "Functions": "Stored procedures and functions"
            }
        }
    },
    "viewpoints": [
        {
            "name": "Controlled Vocabularies",
            "desc": "Tables with controlled vocabularies.",
            "tables": [
                "ndb.agetypes",
                "ndb.chroncontroltypes",
                "ndb.elementtaxagroups",
                "ndb.elementmaturities",
                "ndb.elementsymmetries",
                "ndb.externaldatabases",
                "ndb.calibrationprograms",
                "ndb.calibrationcurves",
                "ndb.analysisunitaltdepthscales",
                "ndb.datasettaxagrouptypes",
                "ndb.lakeparametertypes",
                "ndb.elementtypes",
                "ndb.eventtypes",
                "ndb.isobiomarkerbandtypes",
                "ndb.isobiomarkertypes",
                "ndb.isoinstrumentationtypes",
                "ndb.isomaterialanalyzedtypes",
                "ndb.isopretreatmenttypes",
                "ndb.depenvttypes"
            ]
        },
        {
            "name": "Hierarchical Tables",
            "desc": "Tables with internal hierarchies.",
            "tables": [
                "ndb.taxa",
                "ndb.chroncontroltypes",
                "ndb.lithostrat",
                "ndb.rocktypes",
                "ndb.taxaalthierarchy",
                "ndb.depenvttypes"
            ]
        },
        {
            "name": "Taxonomic Tables",
            "desc": "Tables related to species, observations and specimens.",
            "tables": [
                "ndb.taxa",
                "ndb.externaltaxa",
                "ndb.formtaxa",
                "ndb.taxaalthierarchy",
                "ndb.taxaalthierarchytypes",
                "ndb.taxonpaths"
            ]
        }
    ]
}